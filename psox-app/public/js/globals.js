if (function (t, e) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = t.document ? e(t, !0) : function (t) {
        if (!t.document) throw new Error("jQuery requires a window with a document");
        return e(t)
    } : e(t)
}("undefined" != typeof window ? window : this, function (t, e) {
    "use strict";
    var i = [], n = t.document, r = Object.getPrototypeOf, o = i.slice, a = i.concat, s = i.push, l = i.indexOf, h = {},
        c = h.toString, u = h.hasOwnProperty, d = u.toString, f = d.call(Object), p = {}, g = function (t) {
            return "function" == typeof t && "number" != typeof t.nodeType
        }, m = function (t) {
            return null != t && t === t.window
        }, v = {type: !0, src: !0, nonce: !0, noModule: !0};

    function y(t, e, i) {
        var r, o, a = (i = i || n).createElement("script");
        if (a.text = t, e) for (r in v) (o = e[r] || e.getAttribute && e.getAttribute(r)) && a.setAttribute(r, o);
        i.head.appendChild(a).parentNode.removeChild(a)
    }

    function x(t) {
        return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? h[c.call(t)] || "object" : typeof t
    }

    var b = "3.4.1", M = function (t, e) {
        return new M.fn.init(t, e)
    }, A = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    function w(t) {
        var e = !!t && "length" in t && t.length, i = x(t);
        return !g(t) && !m(t) && ("array" === i || 0 === e || "number" == typeof e && 0 < e && e - 1 in t)
    }

    M.fn = M.prototype = {
        jquery: b, constructor: M, length: 0, toArray: function () {
            return o.call(this)
        }, get: function (t) {
            return null == t ? o.call(this) : t < 0 ? this[t + this.length] : this[t]
        }, pushStack: function (t) {
            var e = M.merge(this.constructor(), t);
            return e.prevObject = this, e
        }, each: function (t) {
            return M.each(this, t)
        }, map: function (t) {
            return this.pushStack(M.map(this, function (e, i) {
                return t.call(e, i, e)
            }))
        }, slice: function () {
            return this.pushStack(o.apply(this, arguments))
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, eq: function (t) {
            var e = this.length, i = +t + (t < 0 ? e : 0);
            return this.pushStack(0 <= i && i < e ? [this[i]] : [])
        }, end: function () {
            return this.prevObject || this.constructor()
        }, push: s, sort: i.sort, splice: i.splice
    }, M.extend = M.fn.extend = function () {
        var t, e, i, n, r, o, a = arguments[0] || {}, s = 1, l = arguments.length, h = !1;
        for ("boolean" == typeof a && (h = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === l && (a = this, s--); s < l; s++) if (null != (t = arguments[s])) for (e in t) n = t[e], "__proto__" !== e && a !== n && (h && n && (M.isPlainObject(n) || (r = Array.isArray(n))) ? (i = a[e], o = r && !Array.isArray(i) ? [] : r || M.isPlainObject(i) ? i : {}, r = !1, a[e] = M.extend(h, o, n)) : void 0 !== n && (a[e] = n));
        return a
    }, M.extend({
        expando: "jQuery" + (b + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (t) {
            throw new Error(t)
        }, noop: function () {
        }, isPlainObject: function (t) {
            var e, i;
            return !(!t || "[object Object]" !== c.call(t) || (e = r(t)) && ("function" != typeof (i = u.call(e, "constructor") && e.constructor) || d.call(i) !== f))
        }, isEmptyObject: function (t) {
            var e;
            for (e in t) return !1;
            return !0
        }, globalEval: function (t, e) {
            y(t, {nonce: e && e.nonce})
        }, each: function (t, e) {
            var i, n = 0;
            if (w(t)) for (i = t.length; n < i && !1 !== e.call(t[n], n, t[n]); n++) ; else for (n in t) if (!1 === e.call(t[n], n, t[n])) break;
            return t
        }, trim: function (t) {
            return null == t ? "" : (t + "").replace(A, "")
        }, makeArray: function (t, e) {
            var i = e || [];
            return null != t && (w(Object(t)) ? M.merge(i, "string" == typeof t ? [t] : t) : s.call(i, t)), i
        }, inArray: function (t, e, i) {
            return null == e ? -1 : l.call(e, t, i)
        }, merge: function (t, e) {
            for (var i = +e.length, n = 0, r = t.length; n < i; n++) t[r++] = e[n];
            return t.length = r, t
        }, grep: function (t, e, i) {
            for (var n = [], r = 0, o = t.length, a = !i; r < o; r++) !e(t[r], r) !== a && n.push(t[r]);
            return n
        }, map: function (t, e, i) {
            var n, r, o = 0, s = [];
            if (w(t)) for (n = t.length; o < n; o++) null != (r = e(t[o], o, i)) && s.push(r); else for (o in t) null != (r = e(t[o], o, i)) && s.push(r);
            return a.apply([], s)
        }, guid: 1, support: p
    }), "function" == typeof Symbol && (M.fn[Symbol.iterator] = i[Symbol.iterator]), M.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (t, e) {
        h["[object " + e + "]"] = e.toLowerCase()
    });
    var k = function (t) {
        var e, i, n, r, o, a, s, l, h, c, u, d, f, p, g, m, v, y, x, b = "sizzle" + 1 * new Date, M = t.document, A = 0,
            w = 0, k = lt(), S = lt(), T = lt(), E = lt(), C = function (t, e) {
                return t === e && (u = !0), 0
            }, D = {}.hasOwnProperty, P = [], _ = P.pop, O = P.push, L = P.push, N = P.slice, z = function (t, e) {
                for (var i = 0, n = t.length; i < n; i++) if (t[i] === e) return i;
                return -1
            },
            I = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            R = "[\\x20\\t\\r\\n\\f]", B = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            j = "\\[" + R + "*(" + B + ")(?:" + R + "*([*^$|!~]?=)" + R + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + B + "))|)" + R + "*\\]",
            W = ":(" + B + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + j + ")*)|.*)\\)|)",
            H = new RegExp(R + "+", "g"), Y = new RegExp("^" + R + "+|((?:^|[^\\\\])(?:\\\\.)*)" + R + "+$", "g"),
            G = new RegExp("^" + R + "*," + R + "*"), F = new RegExp("^" + R + "*([>+~]|" + R + ")" + R + "*"),
            X = new RegExp(R + "|>"), U = new RegExp(W), q = new RegExp("^" + B + "$"), $ = {
                ID: new RegExp("^#(" + B + ")"),
                CLASS: new RegExp("^\\.(" + B + ")"),
                TAG: new RegExp("^(" + B + "|[*])"),
                ATTR: new RegExp("^" + j),
                PSEUDO: new RegExp("^" + W),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + R + "*(even|odd|(([+-]|)(\\d*)n|)" + R + "*(?:([+-]|)" + R + "*(\\d+)|))" + R + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + I + ")$", "i"),
                needsContext: new RegExp("^" + R + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + R + "*((?:-\\d)?\\d*)" + R + "*\\)|)(?=[^-]|$)", "i")
            }, V = /HTML$/i, K = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, J = /^[^{]+\{\s*\[native \w/,
            Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, tt = /[+~]/,
            et = new RegExp("\\\\([\\da-f]{1,6}" + R + "?|(" + R + ")|.)", "ig"), it = function (t, e, i) {
                var n = "0x" + e - 65536;
                return n != n || i ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
            }, nt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, rt = function (t, e) {
                return e ? "\0" === t ? "\ufffd" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
            }, ot = function () {
                d()
            }, at = bt(function (t) {
                return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
            }, {dir: "parentNode", next: "legend"});
        try {
            L.apply(P = N.call(M.childNodes), M.childNodes), P[M.childNodes.length].nodeType
        } catch (e) {
            L = {
                apply: P.length ? function (t, e) {
                    O.apply(t, N.call(e))
                } : function (t, e) {
                    for (var i = t.length, n = 0; t[i++] = e[n++];) ;
                    t.length = i - 1
                }
            }
        }

        function st(t, e, n, r) {
            var o, s, h, c, u, p, v, y = e && e.ownerDocument, A = e ? e.nodeType : 9;
            if (n = n || [], "string" != typeof t || !t || 1 !== A && 9 !== A && 11 !== A) return n;
            if (!r && ((e ? e.ownerDocument || e : M) !== f && d(e), e = e || f, g)) {
                if (11 !== A && (u = Q.exec(t))) if (o = u[1]) {
                    if (9 === A) {
                        if (!(h = e.getElementById(o))) return n;
                        if (h.id === o) return n.push(h), n
                    } else if (y && (h = y.getElementById(o)) && x(e, h) && h.id === o) return n.push(h), n
                } else {
                    if (u[2]) return L.apply(n, e.getElementsByTagName(t)), n;
                    if ((o = u[3]) && i.getElementsByClassName && e.getElementsByClassName) return L.apply(n, e.getElementsByClassName(o)), n
                }
                if (i.qsa && !E[t + " "] && (!m || !m.test(t)) && (1 !== A || "object" !== e.nodeName.toLowerCase())) {
                    if (v = t, y = e, 1 === A && X.test(t)) {
                        for ((c = e.getAttribute("id")) ? c = c.replace(nt, rt) : e.setAttribute("id", c = b), s = (p = a(t)).length; s--;) p[s] = "#" + c + " " + xt(p[s]);
                        v = p.join(","), y = tt.test(t) && vt(e.parentNode) || e
                    }
                    try {
                        return L.apply(n, y.querySelectorAll(v)), n
                    } catch (e) {
                        E(t, !0)
                    } finally {
                        c === b && e.removeAttribute("id")
                    }
                }
            }
            return l(t.replace(Y, "$1"), e, n, r)
        }

        function lt() {
            var t = [];
            return function e(i, r) {
                return t.push(i + " ") > n.cacheLength && delete e[t.shift()], e[i + " "] = r
            }
        }

        function ht(t) {
            return t[b] = !0, t
        }

        function ct(t) {
            var e = f.createElement("fieldset");
            try {
                return !!t(e)
            } catch (t) {
                return !1
            } finally {
                e.parentNode && e.parentNode.removeChild(e), e = null
            }
        }

        function ut(t, e) {
            for (var i = t.split("|"), r = i.length; r--;) n.attrHandle[i[r]] = e
        }

        function dt(t, e) {
            var i = e && t, n = i && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
            if (n) return n;
            if (i) for (; i = i.nextSibling;) if (i === e) return -1;
            return t ? 1 : -1
        }

        function ft(t) {
            return function (e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t
            }
        }

        function pt(t) {
            return function (e) {
                var i = e.nodeName.toLowerCase();
                return ("input" === i || "button" === i) && e.type === t
            }
        }

        function gt(t) {
            return function (e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && at(e) === t : e.disabled === t : "label" in e && e.disabled === t
            }
        }

        function mt(t) {
            return ht(function (e) {
                return e = +e, ht(function (i, n) {
                    for (var r, o = t([], i.length, e), a = o.length; a--;) i[r = o[a]] && (i[r] = !(n[r] = i[r]))
                })
            })
        }

        function vt(t) {
            return t && void 0 !== t.getElementsByTagName && t
        }

        for (e in i = st.support = {}, o = st.isXML = function (t) {
            var e = t.namespaceURI, i = (t.ownerDocument || t).documentElement;
            return !V.test(e || i && i.nodeName || "HTML")
        }, d = st.setDocument = function (t) {
            var e, r, a = t ? t.ownerDocument || t : M;
            return a !== f && 9 === a.nodeType && a.documentElement && (p = (f = a).documentElement, g = !o(f), M !== f && (r = f.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", ot, !1) : r.attachEvent && r.attachEvent("onunload", ot)), i.attributes = ct(function (t) {
                return t.className = "i", !t.getAttribute("className")
            }), i.getElementsByTagName = ct(function (t) {
                return t.appendChild(f.createComment("")), !t.getElementsByTagName("*").length
            }), i.getElementsByClassName = J.test(f.getElementsByClassName), i.getById = ct(function (t) {
                return p.appendChild(t).id = b, !f.getElementsByName || !f.getElementsByName(b).length
            }), i.getById ? (n.filter.ID = function (t) {
                var e = t.replace(et, it);
                return function (t) {
                    return t.getAttribute("id") === e
                }
            }, n.find.ID = function (t, e) {
                if (void 0 !== e.getElementById && g) {
                    var i = e.getElementById(t);
                    return i ? [i] : []
                }
            }) : (n.filter.ID = function (t) {
                var e = t.replace(et, it);
                return function (t) {
                    var i = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                    return i && i.value === e
                }
            }, n.find.ID = function (t, e) {
                if (void 0 !== e.getElementById && g) {
                    var i, n, r, o = e.getElementById(t);
                    if (o) {
                        if ((i = o.getAttributeNode("id")) && i.value === t) return [o];
                        for (r = e.getElementsByName(t), n = 0; o = r[n++];) if ((i = o.getAttributeNode("id")) && i.value === t) return [o]
                    }
                    return []
                }
            }), n.find.TAG = i.getElementsByTagName ? function (t, e) {
                return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : i.qsa ? e.querySelectorAll(t) : void 0
            } : function (t, e) {
                var i, n = [], r = 0, o = e.getElementsByTagName(t);
                if ("*" === t) {
                    for (; i = o[r++];) 1 === i.nodeType && n.push(i);
                    return n
                }
                return o
            }, n.find.CLASS = i.getElementsByClassName && function (t, e) {
                if (void 0 !== e.getElementsByClassName && g) return e.getElementsByClassName(t)
            }, v = [], m = [], (i.qsa = J.test(f.querySelectorAll)) && (ct(function (t) {
                p.appendChild(t).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && m.push("[*^$]=" + R + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || m.push("\\[" + R + "*(?:value|" + I + ")"), t.querySelectorAll("[id~=" + b + "-]").length || m.push("~="), t.querySelectorAll(":checked").length || m.push(":checked"), t.querySelectorAll("a#" + b + "+*").length || m.push(".#.+[+~]")
            }), ct(function (t) {
                t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var e = f.createElement("input");
                e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && m.push("name" + R + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && m.push(":enabled", ":disabled"), p.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && m.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), m.push(",.*:")
            })), (i.matchesSelector = J.test(y = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.oMatchesSelector || p.msMatchesSelector)) && ct(function (t) {
                i.disconnectedMatch = y.call(t, "*"), y.call(t, "[s!='']:x"), v.push("!=", W)
            }), m = m.length && new RegExp(m.join("|")), v = v.length && new RegExp(v.join("|")), e = J.test(p.compareDocumentPosition), x = e || J.test(p.contains) ? function (t, e) {
                var i = 9 === t.nodeType ? t.documentElement : t, n = e && e.parentNode;
                return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
            } : function (t, e) {
                if (e) for (; e = e.parentNode;) if (e === t) return !0;
                return !1
            }, C = e ? function (t, e) {
                if (t === e) return u = !0, 0;
                var n = !t.compareDocumentPosition - !e.compareDocumentPosition;
                return n || (1 & (n = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !i.sortDetached && e.compareDocumentPosition(t) === n ? t === f || t.ownerDocument === M && x(M, t) ? -1 : e === f || e.ownerDocument === M && x(M, e) ? 1 : c ? z(c, t) - z(c, e) : 0 : 4 & n ? -1 : 1)
            } : function (t, e) {
                if (t === e) return u = !0, 0;
                var i, n = 0, r = t.parentNode, o = e.parentNode, a = [t], s = [e];
                if (!r || !o) return t === f ? -1 : e === f ? 1 : r ? -1 : o ? 1 : c ? z(c, t) - z(c, e) : 0;
                if (r === o) return dt(t, e);
                for (i = t; i = i.parentNode;) a.unshift(i);
                for (i = e; i = i.parentNode;) s.unshift(i);
                for (; a[n] === s[n];) n++;
                return n ? dt(a[n], s[n]) : a[n] === M ? -1 : s[n] === M ? 1 : 0
            }), f
        }, st.matches = function (t, e) {
            return st(t, null, null, e)
        }, st.matchesSelector = function (t, e) {
            if ((t.ownerDocument || t) !== f && d(t), i.matchesSelector && g && !E[e + " "] && (!v || !v.test(e)) && (!m || !m.test(e))) try {
                var n = y.call(t, e);
                if (n || i.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n
            } catch (t) {
                E(e, !0)
            }
            return 0 < st(e, f, null, [t]).length
        }, st.contains = function (t, e) {
            return (t.ownerDocument || t) !== f && d(t), x(t, e)
        }, st.attr = function (t, e) {
            (t.ownerDocument || t) !== f && d(t);
            var r = n.attrHandle[e.toLowerCase()],
                o = r && D.call(n.attrHandle, e.toLowerCase()) ? r(t, e, !g) : void 0;
            return void 0 !== o ? o : i.attributes || !g ? t.getAttribute(e) : (o = t.getAttributeNode(e)) && o.specified ? o.value : null
        }, st.escape = function (t) {
            return (t + "").replace(nt, rt)
        }, st.error = function (t) {
            throw new Error("Syntax error, unrecognized expression: " + t)
        }, st.uniqueSort = function (t) {
            var e, n = [], r = 0, o = 0;
            if (u = !i.detectDuplicates, c = !i.sortStable && t.slice(0), t.sort(C), u) {
                for (; e = t[o++];) e === t[o] && (r = n.push(o));
                for (; r--;) t.splice(n[r], 1)
            }
            return c = null, t
        }, r = st.getText = function (t) {
            var e, i = "", n = 0, o = t.nodeType;
            if (o) {
                if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof t.textContent) return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling) i += r(t)
                } else if (3 === o || 4 === o) return t.nodeValue
            } else for (; e = t[n++];) i += r(e);
            return i
        }, (n = st.selectors = {
            cacheLength: 50,
            createPseudo: ht,
            match: $,
            attrHandle: {},
            find: {},
            relative: {
                ">": {dir: "parentNode", first: !0},
                " ": {dir: "parentNode"},
                "+": {dir: "previousSibling", first: !0},
                "~": {dir: "previousSibling"}
            },
            preFilter: {
                ATTR: function (t) {
                    return t[1] = t[1].replace(et, it), t[3] = (t[3] || t[4] || t[5] || "").replace(et, it), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                }, CHILD: function (t) {
                    return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || st.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && st.error(t[0]), t
                }, PSEUDO: function (t) {
                    var e, i = !t[6] && t[2];
                    return $.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && U.test(i) && (e = a(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
                }
            },
            filter: {
                TAG: function (t) {
                    var e = t.replace(et, it).toLowerCase();
                    return "*" === t ? function () {
                        return !0
                    } : function (t) {
                        return t.nodeName && t.nodeName.toLowerCase() === e
                    }
                }, CLASS: function (t) {
                    var e = k[t + " "];
                    return e || (e = new RegExp("(^|" + R + ")" + t + "(" + R + "|$)")) && k(t, function (t) {
                        return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                    })
                }, ATTR: function (t, e, i) {
                    return function (n) {
                        var r = st.attr(n, t);
                        return null == r ? "!=" === e : !e || (r += "", "=" === e ? r === i : "!=" === e ? r !== i : "^=" === e ? i && 0 === r.indexOf(i) : "*=" === e ? i && -1 < r.indexOf(i) : "$=" === e ? i && r.slice(-i.length) === i : "~=" === e ? -1 < (" " + r.replace(H, " ") + " ").indexOf(i) : "|=" === e && (r === i || r.slice(0, i.length + 1) === i + "-"))
                    }
                }, CHILD: function (t, e, i, n, r) {
                    var o = "nth" !== t.slice(0, 3), a = "last" !== t.slice(-4), s = "of-type" === e;
                    return 1 === n && 0 === r ? function (t) {
                        return !!t.parentNode
                    } : function (e, i, l) {
                        var h, c, u, d, f, p, g = o !== a ? "nextSibling" : "previousSibling", m = e.parentNode,
                            v = s && e.nodeName.toLowerCase(), y = !l && !s, x = !1;
                        if (m) {
                            if (o) {
                                for (; g;) {
                                    for (d = e; d = d[g];) if (s ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                    p = g = "only" === t && !p && "nextSibling"
                                }
                                return !0
                            }
                            if (p = [a ? m.firstChild : m.lastChild], a && y) {
                                for (x = (f = (h = (c = (u = (d = m)[b] || (d[b] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] || [])[0] === A && h[1]) && h[2], d = f && m.childNodes[f]; d = ++f && d && d[g] || (x = f = 0) || p.pop();) if (1 === d.nodeType && ++x && d === e) {
                                    c[t] = [A, f, x];
                                    break
                                }
                            } else if (y && (x = f = (h = (c = (u = (d = e)[b] || (d[b] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] || [])[0] === A && h[1]), !1 === x) for (; (d = ++f && d && d[g] || (x = f = 0) || p.pop()) && ((s ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++x || (y && ((c = (u = d[b] || (d[b] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] = [A, x]), d !== e));) ;
                            return (x -= r) === n || x % n == 0 && 0 <= x / n
                        }
                    }
                }, PSEUDO: function (t, e) {
                    var i, r = n.pseudos[t] || n.setFilters[t.toLowerCase()] || st.error("unsupported pseudo: " + t);
                    return r[b] ? r(e) : 1 < r.length ? (i = [t, t, "", e], n.setFilters.hasOwnProperty(t.toLowerCase()) ? ht(function (t, i) {
                        for (var n, o = r(t, e), a = o.length; a--;) t[n = z(t, o[a])] = !(i[n] = o[a])
                    }) : function (t) {
                        return r(t, 0, i)
                    }) : r
                }
            },
            pseudos: {
                not: ht(function (t) {
                    var e = [], i = [], n = s(t.replace(Y, "$1"));
                    return n[b] ? ht(function (t, e, i, r) {
                        for (var o, a = n(t, null, r, []), s = t.length; s--;) (o = a[s]) && (t[s] = !(e[s] = o))
                    }) : function (t, r, o) {
                        return e[0] = t, n(e, null, o, i), e[0] = null, !i.pop()
                    }
                }), has: ht(function (t) {
                    return function (e) {
                        return 0 < st(t, e).length
                    }
                }), contains: ht(function (t) {
                    return t = t.replace(et, it), function (e) {
                        return -1 < (e.textContent || r(e)).indexOf(t)
                    }
                }), lang: ht(function (t) {
                    return q.test(t || "") || st.error("unsupported lang: " + t), t = t.replace(et, it).toLowerCase(), function (e) {
                        var i;
                        do {
                            if (i = g ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (i = i.toLowerCase()) === t || 0 === i.indexOf(t + "-")
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1
                    }
                }), target: function (e) {
                    var i = t.location && t.location.hash;
                    return i && i.slice(1) === e.id
                }, root: function (t) {
                    return t === p
                }, focus: function (t) {
                    return t === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                }, enabled: gt(!1), disabled: gt(!0), checked: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && !!t.checked || "option" === e && !!t.selected
                }, selected: function (t) {
                    return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                }, empty: function (t) {
                    for (t = t.firstChild; t; t = t.nextSibling) if (t.nodeType < 6) return !1;
                    return !0
                }, parent: function (t) {
                    return !n.pseudos.empty(t)
                }, header: function (t) {
                    return Z.test(t.nodeName)
                }, input: function (t) {
                    return K.test(t.nodeName)
                }, button: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && "button" === t.type || "button" === e
                }, text: function (t) {
                    var e;
                    return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                }, first: mt(function () {
                    return [0]
                }), last: mt(function (t, e) {
                    return [e - 1]
                }), eq: mt(function (t, e, i) {
                    return [i < 0 ? i + e : i]
                }), even: mt(function (t, e) {
                    for (var i = 0; i < e; i += 2) t.push(i);
                    return t
                }), odd: mt(function (t, e) {
                    for (var i = 1; i < e; i += 2) t.push(i);
                    return t
                }), lt: mt(function (t, e, i) {
                    for (var n = i < 0 ? i + e : e < i ? e : i; 0 <= --n;) t.push(n);
                    return t
                }), gt: mt(function (t, e, i) {
                    for (var n = i < 0 ? i + e : i; ++n < e;) t.push(n);
                    return t
                })
            }
        }).pseudos.nth = n.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) n.pseudos[e] = ft(e);
        for (e in {submit: !0, reset: !0}) n.pseudos[e] = pt(e);

        function yt() {
        }

        function xt(t) {
            for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e].value;
            return n
        }

        function bt(t, e, i) {
            var n = e.dir, r = e.next, o = r || n, a = i && "parentNode" === o, s = w++;
            return e.first ? function (e, i, r) {
                for (; e = e[n];) if (1 === e.nodeType || a) return t(e, i, r);
                return !1
            } : function (e, i, l) {
                var h, c, u, d = [A, s];
                if (l) {
                    for (; e = e[n];) if ((1 === e.nodeType || a) && t(e, i, l)) return !0
                } else for (; e = e[n];) if (1 === e.nodeType || a) if (c = (u = e[b] || (e[b] = {}))[e.uniqueID] || (u[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[n] || e; else {
                    if ((h = c[o]) && h[0] === A && h[1] === s) return d[2] = h[2];
                    if ((c[o] = d)[2] = t(e, i, l)) return !0
                }
                return !1
            }
        }

        function Mt(t) {
            return 1 < t.length ? function (e, i, n) {
                for (var r = t.length; r--;) if (!t[r](e, i, n)) return !1;
                return !0
            } : t[0]
        }

        function At(t, e, i, n, r) {
            for (var o, a = [], s = 0, l = t.length, h = null != e; s < l; s++) (o = t[s]) && (i && !i(o, n, r) || (a.push(o), h && e.push(s)));
            return a
        }

        function wt(t, e, i, n, r, o) {
            return n && !n[b] && (n = wt(n)), r && !r[b] && (r = wt(r, o)), ht(function (o, a, s, l) {
                var h, c, u, d = [], f = [], p = a.length, g = o || function (t, e, i) {
                        for (var n = 0, r = e.length; n < r; n++) st(t, e[n], i);
                        return i
                    }(e || "*", s.nodeType ? [s] : s, []), m = !t || !o && e ? g : At(g, d, t, s, l),
                    v = i ? r || (o ? t : p || n) ? [] : a : m;
                if (i && i(m, v, s, l), n) for (h = At(v, f), n(h, [], s, l), c = h.length; c--;) (u = h[c]) && (v[f[c]] = !(m[f[c]] = u));
                if (o) {
                    if (r || t) {
                        if (r) {
                            for (h = [], c = v.length; c--;) (u = v[c]) && h.push(m[c] = u);
                            r(null, v = [], h, l)
                        }
                        for (c = v.length; c--;) (u = v[c]) && -1 < (h = r ? z(o, u) : d[c]) && (o[h] = !(a[h] = u))
                    }
                } else v = At(v === a ? v.splice(p, v.length) : v), r ? r(null, a, v, l) : L.apply(a, v)
            })
        }

        function kt(t) {
            for (var e, i, r, o = t.length, a = n.relative[t[0].type], s = a || n.relative[" "], l = a ? 1 : 0, c = bt(function (t) {
                return t === e
            }, s, !0), u = bt(function (t) {
                return -1 < z(e, t)
            }, s, !0), d = [function (t, i, n) {
                var r = !a && (n || i !== h) || ((e = i).nodeType ? c(t, i, n) : u(t, i, n));
                return e = null, r
            }]; l < o; l++) if (i = n.relative[t[l].type]) d = [bt(Mt(d), i)]; else {
                if ((i = n.filter[t[l].type].apply(null, t[l].matches))[b]) {
                    for (r = ++l; r < o && !n.relative[t[r].type]; r++) ;
                    return wt(1 < l && Mt(d), 1 < l && xt(t.slice(0, l - 1).concat({value: " " === t[l - 2].type ? "*" : ""})).replace(Y, "$1"), i, l < r && kt(t.slice(l, r)), r < o && kt(t = t.slice(r)), r < o && xt(t))
                }
                d.push(i)
            }
            return Mt(d)
        }

        return yt.prototype = n.filters = n.pseudos, n.setFilters = new yt, a = st.tokenize = function (t, e) {
            var i, r, o, a, s, l, h, c = S[t + " "];
            if (c) return e ? 0 : c.slice(0);
            for (s = t, l = [], h = n.preFilter; s;) {
                for (a in i && !(r = G.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), i = !1, (r = F.exec(s)) && (i = r.shift(), o.push({
                    value: i,
                    type: r[0].replace(Y, " ")
                }), s = s.slice(i.length)), n.filter) !(r = $[a].exec(s)) || h[a] && !(r = h[a](r)) || (i = r.shift(), o.push({
                    value: i,
                    type: a,
                    matches: r
                }), s = s.slice(i.length));
                if (!i) break
            }
            return e ? s.length : s ? st.error(t) : S(t, l).slice(0)
        }, s = st.compile = function (t, e) {
            var i, r, o, s, l, c, u = [], p = [], m = T[t + " "];
            if (!m) {
                for (e || (e = a(t)), i = e.length; i--;) (m = kt(e[i]))[b] ? u.push(m) : p.push(m);
                (m = T(t, (r = p, s = 0 < (o = u).length, l = 0 < r.length, c = function (t, e, i, a, c) {
                    var u, p, m, v = 0, y = "0", x = t && [], b = [], M = h, w = t || l && n.find.TAG("*", c),
                        k = A += null == M ? 1 : Math.random() || .1, S = w.length;
                    for (c && (h = e === f || e || c); y !== S && null != (u = w[y]); y++) {
                        if (l && u) {
                            for (p = 0, e || u.ownerDocument === f || (d(u), i = !g); m = r[p++];) if (m(u, e || f, i)) {
                                a.push(u);
                                break
                            }
                            c && (A = k)
                        }
                        s && ((u = !m && u) && v--, t && x.push(u))
                    }
                    if (v += y, s && y !== v) {
                        for (p = 0; m = o[p++];) m(x, b, e, i);
                        if (t) {
                            if (0 < v) for (; y--;) x[y] || b[y] || (b[y] = _.call(a));
                            b = At(b)
                        }
                        L.apply(a, b), c && !t && 0 < b.length && 1 < v + o.length && st.uniqueSort(a)
                    }
                    return c && (A = k, h = M), x
                }, s ? ht(c) : c))).selector = t
            }
            return m
        }, l = st.select = function (t, e, i, r) {
            var o, l, h, c, u, d = "function" == typeof t && t, f = !r && a(t = d.selector || t);
            if (i = i || [], 1 === f.length) {
                if (2 < (l = f[0] = f[0].slice(0)).length && "ID" === (h = l[0]).type && 9 === e.nodeType && g && n.relative[l[1].type]) {
                    if (!(e = (n.find.ID(h.matches[0].replace(et, it), e) || [])[0])) return i;
                    d && (e = e.parentNode), t = t.slice(l.shift().value.length)
                }
                for (o = $.needsContext.test(t) ? 0 : l.length; o-- && (h = l[o], !n.relative[c = h.type]);) if ((u = n.find[c]) && (r = u(h.matches[0].replace(et, it), tt.test(l[0].type) && vt(e.parentNode) || e))) {
                    if (l.splice(o, 1), !(t = r.length && xt(l))) return L.apply(i, r), i;
                    break
                }
            }
            return (d || s(t, f))(r, e, !g, i, !e || tt.test(t) && vt(e.parentNode) || e), i
        }, i.sortStable = b.split("").sort(C).join("") === b, i.detectDuplicates = !!u, d(), i.sortDetached = ct(function (t) {
            return 1 & t.compareDocumentPosition(f.createElement("fieldset"))
        }), ct(function (t) {
            return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
        }) || ut("type|href|height|width", function (t, e, i) {
            if (!i) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
        }), i.attributes && ct(function (t) {
            return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
        }) || ut("value", function (t, e, i) {
            if (!i && "input" === t.nodeName.toLowerCase()) return t.defaultValue
        }), ct(function (t) {
            return null == t.getAttribute("disabled")
        }) || ut(I, function (t, e, i) {
            var n;
            if (!i) return !0 === t[e] ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
        }), st
    }(t);
    M.find = k, M.expr = k.selectors, M.expr[":"] = M.expr.pseudos, M.uniqueSort = M.unique = k.uniqueSort, M.text = k.getText, M.isXMLDoc = k.isXML, M.contains = k.contains, M.escapeSelector = k.escape;
    var S = function (t, e, i) {
        for (var n = [], r = void 0 !== i; (t = t[e]) && 9 !== t.nodeType;) if (1 === t.nodeType) {
            if (r && M(t).is(i)) break;
            n.push(t)
        }
        return n
    }, T = function (t, e) {
        for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
        return i
    }, E = M.expr.match.needsContext;

    function C(t, e) {
        return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
    }

    var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    function P(t, e, i) {
        return g(e) ? M.grep(t, function (t, n) {
            return !!e.call(t, n, t) !== i
        }) : e.nodeType ? M.grep(t, function (t) {
            return t === e !== i
        }) : "string" != typeof e ? M.grep(t, function (t) {
            return -1 < l.call(e, t) !== i
        }) : M.filter(e, t, i)
    }

    M.filter = function (t, e, i) {
        var n = e[0];
        return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? M.find.matchesSelector(n, t) ? [n] : [] : M.find.matches(t, M.grep(e, function (t) {
            return 1 === t.nodeType
        }))
    }, M.fn.extend({
        find: function (t) {
            var e, i, n = this.length, r = this;
            if ("string" != typeof t) return this.pushStack(M(t).filter(function () {
                for (e = 0; e < n; e++) if (M.contains(r[e], this)) return !0
            }));
            for (i = this.pushStack([]), e = 0; e < n; e++) M.find(t, r[e], i);
            return 1 < n ? M.uniqueSort(i) : i
        }, filter: function (t) {
            return this.pushStack(P(this, t || [], !1))
        }, not: function (t) {
            return this.pushStack(P(this, t || [], !0))
        }, is: function (t) {
            return !!P(this, "string" == typeof t && E.test(t) ? M(t) : t || [], !1).length
        }
    });
    var _, O = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (M.fn.init = function (t, e, i) {
        var r, o;
        if (!t) return this;
        if (i = i || _, "string" == typeof t) {
            if (!(r = "<" === t[0] && ">" === t[t.length - 1] && 3 <= t.length ? [null, t, null] : O.exec(t)) || !r[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
            if (r[1]) {
                if (e = e instanceof M ? e[0] : e, M.merge(this, M.parseHTML(r[1], e && e.nodeType ? e.ownerDocument || e : n, !0)), D.test(r[1]) && M.isPlainObject(e)) for (r in e) g(this[r]) ? this[r](e[r]) : this.attr(r, e[r]);
                return this
            }
            return (o = n.getElementById(r[2])) && (this[0] = o, this.length = 1), this
        }
        return t.nodeType ? (this[0] = t, this.length = 1, this) : g(t) ? void 0 !== i.ready ? i.ready(t) : t(M) : M.makeArray(t, this)
    }).prototype = M.fn, _ = M(n);
    var L = /^(?:parents|prev(?:Until|All))/, N = {children: !0, contents: !0, next: !0, prev: !0};

    function z(t, e) {
        for (; (t = t[e]) && 1 !== t.nodeType;) ;
        return t
    }

    M.fn.extend({
        has: function (t) {
            var e = M(t, this), i = e.length;
            return this.filter(function () {
                for (var t = 0; t < i; t++) if (M.contains(this, e[t])) return !0
            })
        }, closest: function (t, e) {
            var i, n = 0, r = this.length, o = [], a = "string" != typeof t && M(t);
            if (!E.test(t)) for (; n < r; n++) for (i = this[n]; i && i !== e; i = i.parentNode) if (i.nodeType < 11 && (a ? -1 < a.index(i) : 1 === i.nodeType && M.find.matchesSelector(i, t))) {
                o.push(i);
                break
            }
            return this.pushStack(1 < o.length ? M.uniqueSort(o) : o)
        }, index: function (t) {
            return t ? "string" == typeof t ? l.call(M(t), this[0]) : l.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        }, add: function (t, e) {
            return this.pushStack(M.uniqueSort(M.merge(this.get(), M(t, e))))
        }, addBack: function (t) {
            return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
        }
    }), M.each({
        parent: function (t) {
            var e = t.parentNode;
            return e && 11 !== e.nodeType ? e : null
        }, parents: function (t) {
            return S(t, "parentNode")
        }, parentsUntil: function (t, e, i) {
            return S(t, "parentNode", i)
        }, next: function (t) {
            return z(t, "nextSibling")
        }, prev: function (t) {
            return z(t, "previousSibling")
        }, nextAll: function (t) {
            return S(t, "nextSibling")
        }, prevAll: function (t) {
            return S(t, "previousSibling")
        }, nextUntil: function (t, e, i) {
            return S(t, "nextSibling", i)
        }, prevUntil: function (t, e, i) {
            return S(t, "previousSibling", i)
        }, siblings: function (t) {
            return T((t.parentNode || {}).firstChild, t)
        }, children: function (t) {
            return T(t.firstChild)
        }, contents: function (t) {
            return void 0 !== t.contentDocument ? t.contentDocument : (C(t, "template") && (t = t.content || t), M.merge([], t.childNodes))
        }
    }, function (t, e) {
        M.fn[t] = function (i, n) {
            var r = M.map(this, e, i);
            return "Until" !== t.slice(-5) && (n = i), n && "string" == typeof n && (r = M.filter(n, r)), 1 < this.length && (N[t] || M.uniqueSort(r), L.test(t) && r.reverse()), this.pushStack(r)
        }
    });
    var I = /[^\x20\t\r\n\f]+/g;

    function R(t) {
        return t
    }

    function B(t) {
        throw t
    }

    function j(t, e, i, n) {
        var r;
        try {
            t && g(r = t.promise) ? r.call(t).done(e).fail(i) : t && g(r = t.then) ? r.call(t, e, i) : e.apply(void 0, [t].slice(n))
        } catch (t) {
            i.apply(void 0, [t])
        }
    }

    M.Callbacks = function (t) {
        var e, i;
        t = "string" == typeof t ? (e = t, i = {}, M.each(e.match(I) || [], function (t, e) {
            i[e] = !0
        }), i) : M.extend({}, t);
        var n, r, o, a, s = [], l = [], h = -1, c = function () {
            for (a = a || t.once, o = n = !0; l.length; h = -1) for (r = l.shift(); ++h < s.length;) !1 === s[h].apply(r[0], r[1]) && t.stopOnFalse && (h = s.length, r = !1);
            t.memory || (r = !1), n = !1, a && (s = r ? [] : "")
        }, u = {
            add: function () {
                return s && (r && !n && (h = s.length - 1, l.push(r)), function e(i) {
                    M.each(i, function (i, n) {
                        g(n) ? t.unique && u.has(n) || s.push(n) : n && n.length && "string" !== x(n) && e(n)
                    })
                }(arguments), r && !n && c()), this
            }, remove: function () {
                return M.each(arguments, function (t, e) {
                    for (var i; -1 < (i = M.inArray(e, s, i));) s.splice(i, 1), i <= h && h--
                }), this
            }, has: function (t) {
                return t ? -1 < M.inArray(t, s) : 0 < s.length
            }, empty: function () {
                return s && (s = []), this
            }, disable: function () {
                return a = l = [], s = r = "", this
            }, disabled: function () {
                return !s
            }, lock: function () {
                return a = l = [], r || n || (s = r = ""), this
            }, locked: function () {
                return !!a
            }, fireWith: function (t, e) {
                return a || (e = [t, (e = e || []).slice ? e.slice() : e], l.push(e), n || c()), this
            }, fire: function () {
                return u.fireWith(this, arguments), this
            }, fired: function () {
                return !!o
            }
        };
        return u
    }, M.extend({
        Deferred: function (e) {
            var i = [["notify", "progress", M.Callbacks("memory"), M.Callbacks("memory"), 2], ["resolve", "done", M.Callbacks("once memory"), M.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", M.Callbacks("once memory"), M.Callbacks("once memory"), 1, "rejected"]],
                n = "pending", r = {
                    state: function () {
                        return n
                    }, always: function () {
                        return o.done(arguments).fail(arguments), this
                    }, catch: function (t) {
                        return r.then(null, t)
                    }, pipe: function () {
                        var t = arguments;
                        return M.Deferred(function (e) {
                            M.each(i, function (i, n) {
                                var r = g(t[n[4]]) && t[n[4]];
                                o[n[1]](function () {
                                    var t = r && r.apply(this, arguments);
                                    t && g(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[n[0] + "With"](this, r ? [t] : arguments)
                                })
                            }), t = null
                        }).promise()
                    }, then: function (e, n, r) {
                        var o = 0;

                        function a(e, i, n, r) {
                            return function () {
                                var s = this, l = arguments, h = function () {
                                    var t, h;
                                    if (!(e < o)) {
                                        if ((t = n.apply(s, l)) === i.promise()) throw new TypeError("Thenable self-resolution");
                                        h = t && ("object" == typeof t || "function" == typeof t) && t.then, g(h) ? r ? h.call(t, a(o, i, R, r), a(o, i, B, r)) : (o++, h.call(t, a(o, i, R, r), a(o, i, B, r), a(o, i, R, i.notifyWith))) : (n !== R && (s = void 0, l = [t]), (r || i.resolveWith)(s, l))
                                    }
                                }, c = r ? h : function () {
                                    try {
                                        h()
                                    } catch (h) {
                                        M.Deferred.exceptionHook && M.Deferred.exceptionHook(h, c.stackTrace), o <= e + 1 && (n !== B && (s = void 0, l = [h]), i.rejectWith(s, l))
                                    }
                                };
                                e ? c() : (M.Deferred.getStackHook && (c.stackTrace = M.Deferred.getStackHook()), t.setTimeout(c))
                            }
                        }

                        return M.Deferred(function (t) {
                            i[0][3].add(a(0, t, g(r) ? r : R, t.notifyWith)), i[1][3].add(a(0, t, g(e) ? e : R)), i[2][3].add(a(0, t, g(n) ? n : B))
                        }).promise()
                    }, promise: function (t) {
                        return null != t ? M.extend(t, r) : r
                    }
                }, o = {};
            return M.each(i, function (t, e) {
                var a = e[2], s = e[5];
                r[e[1]] = a.add, s && a.add(function () {
                    n = s
                }, i[3 - t][2].disable, i[3 - t][3].disable, i[0][2].lock, i[0][3].lock), a.add(e[3].fire), o[e[0]] = function () {
                    return o[e[0] + "With"](this === o ? void 0 : this, arguments), this
                }, o[e[0] + "With"] = a.fireWith
            }), r.promise(o), e && e.call(o, o), o
        }, when: function (t) {
            var e = arguments.length, i = e, n = Array(i), r = o.call(arguments), a = M.Deferred(), s = function (t) {
                return function (i) {
                    n[t] = this, r[t] = 1 < arguments.length ? o.call(arguments) : i, --e || a.resolveWith(n, r)
                }
            };
            if (e <= 1 && (j(t, a.done(s(i)).resolve, a.reject, !e), "pending" === a.state() || g(r[i] && r[i].then))) return a.then();
            for (; i--;) j(r[i], s(i), a.reject);
            return a.promise()
        }
    });
    var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    M.Deferred.exceptionHook = function (e, i) {
        t.console && t.console.warn && e && W.test(e.name) && t.console.warn("jQuery.Deferred exception: " + e.message, e.stack, i)
    }, M.readyException = function (e) {
        t.setTimeout(function () {
            throw e
        })
    };
    var H = M.Deferred();

    function Y() {
        n.removeEventListener("DOMContentLoaded", Y), t.removeEventListener("load", Y), M.ready()
    }

    M.fn.ready = function (t) {
        return H.then(t).catch(function (t) {
            M.readyException(t)
        }), this
    }, M.extend({
        isReady: !1, readyWait: 1, ready: function (t) {
            (!0 === t ? --M.readyWait : M.isReady) || (M.isReady = !0) !== t && 0 < --M.readyWait || H.resolveWith(n, [M])
        }
    }), M.ready.then = H.then, "complete" === n.readyState || "loading" !== n.readyState && !n.documentElement.doScroll ? t.setTimeout(M.ready) : (n.addEventListener("DOMContentLoaded", Y), t.addEventListener("load", Y));
    var G = function (t, e, i, n, r, o, a) {
        var s = 0, l = t.length, h = null == i;
        if ("object" === x(i)) for (s in r = !0, i) G(t, e, s, i[s], !0, o, a); else if (void 0 !== n && (r = !0, g(n) || (a = !0), h && (a ? (e.call(t, n), e = null) : (h = e, e = function (t, e, i) {
            return h.call(M(t), i)
        })), e)) for (; s < l; s++) e(t[s], i, a ? n : n.call(t[s], s, e(t[s], i)));
        return r ? t : h ? e.call(t) : l ? e(t[0], i) : o
    }, F = /^-ms-/, X = /-([a-z])/g;

    function U(t, e) {
        return e.toUpperCase()
    }

    function q(t) {
        return t.replace(F, "ms-").replace(X, U)
    }

    var $ = function (t) {
        return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
    };

    function V() {
        this.expando = M.expando + V.uid++
    }

    V.uid = 1, V.prototype = {
        cache: function (t) {
            var e = t[this.expando];
            return e || (e = {}, $(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                value: e,
                configurable: !0
            }))), e
        }, set: function (t, e, i) {
            var n, r = this.cache(t);
            if ("string" == typeof e) r[q(e)] = i; else for (n in e) r[q(n)] = e[n];
            return r
        }, get: function (t, e) {
            return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][q(e)]
        }, access: function (t, e, i) {
            return void 0 === e || e && "string" == typeof e && void 0 === i ? this.get(t, e) : (this.set(t, e, i), void 0 !== i ? i : e)
        }, remove: function (t, e) {
            var i, n = t[this.expando];
            if (void 0 !== n) {
                if (void 0 !== e) {
                    i = (e = Array.isArray(e) ? e.map(q) : (e = q(e)) in n ? [e] : e.match(I) || []).length;
                    for (; i--;) delete n[e[i]]
                }
                (void 0 === e || M.isEmptyObject(n)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
            }
        }, hasData: function (t) {
            var e = t[this.expando];
            return void 0 !== e && !M.isEmptyObject(e)
        }
    };
    var K = new V, Z = new V, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Q = /[A-Z]/g;

    function tt(t, e, i) {
        var n, r;
        if (void 0 === i && 1 === t.nodeType) if (n = "data-" + e.replace(Q, "-$&").toLowerCase(), "string" == typeof (i = t.getAttribute(n))) {
            try {
                i = "true" === (r = i) || "false" !== r && ("null" === r ? null : r === +r + "" ? +r : J.test(r) ? JSON.parse(r) : r)
            } catch (t) {
            }
            Z.set(t, e, i)
        } else i = void 0;
        return i
    }

    M.extend({
        hasData: function (t) {
            return Z.hasData(t) || K.hasData(t)
        }, data: function (t, e, i) {
            return Z.access(t, e, i)
        }, removeData: function (t, e) {
            Z.remove(t, e)
        }, _data: function (t, e, i) {
            return K.access(t, e, i)
        }, _removeData: function (t, e) {
            K.remove(t, e)
        }
    }), M.fn.extend({
        data: function (t, e) {
            var i, n, r, o = this[0], a = o && o.attributes;
            if (void 0 === t) {
                if (this.length && (r = Z.get(o), 1 === o.nodeType && !K.get(o, "hasDataAttrs"))) {
                    for (i = a.length; i--;) a[i] && 0 === (n = a[i].name).indexOf("data-") && (n = q(n.slice(5)), tt(o, n, r[n]));
                    K.set(o, "hasDataAttrs", !0)
                }
                return r
            }
            return "object" == typeof t ? this.each(function () {
                Z.set(this, t)
            }) : G(this, function (e) {
                var i;
                if (o && void 0 === e) return void 0 !== (i = Z.get(o, t)) ? i : void 0 !== (i = tt(o, t)) ? i : void 0;
                this.each(function () {
                    Z.set(this, t, e)
                })
            }, null, e, 1 < arguments.length, null, !0)
        }, removeData: function (t) {
            return this.each(function () {
                Z.remove(this, t)
            })
        }
    }), M.extend({
        queue: function (t, e, i) {
            var n;
            if (t) return e = (e || "fx") + "queue", n = K.get(t, e), i && (!n || Array.isArray(i) ? n = K.access(t, e, M.makeArray(i)) : n.push(i)), n || []
        }, dequeue: function (t, e) {
            e = e || "fx";
            var i = M.queue(t, e), n = i.length, r = i.shift(), o = M._queueHooks(t, e);
            "inprogress" === r && (r = i.shift(), n--), r && ("fx" === e && i.unshift("inprogress"), delete o.stop, r.call(t, function () {
                M.dequeue(t, e)
            }, o)), !n && o && o.empty.fire()
        }, _queueHooks: function (t, e) {
            var i = e + "queueHooks";
            return K.get(t, i) || K.access(t, i, {
                empty: M.Callbacks("once memory").add(function () {
                    K.remove(t, [e + "queue", i])
                })
            })
        }
    }), M.fn.extend({
        queue: function (t, e) {
            var i = 2;
            return "string" != typeof t && (e = t, t = "fx", i--), arguments.length < i ? M.queue(this[0], t) : void 0 === e ? this : this.each(function () {
                var i = M.queue(this, t, e);
                M._queueHooks(this, t), "fx" === t && "inprogress" !== i[0] && M.dequeue(this, t)
            })
        }, dequeue: function (t) {
            return this.each(function () {
                M.dequeue(this, t)
            })
        }, clearQueue: function (t) {
            return this.queue(t || "fx", [])
        }, promise: function (t, e) {
            var i, n = 1, r = M.Deferred(), o = this, a = this.length, s = function () {
                --n || r.resolveWith(o, [o])
            };
            for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; a--;) (i = K.get(o[a], t + "queueHooks")) && i.empty && (n++, i.empty.add(s));
            return s(), r.promise(e)
        }
    });
    var et = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, it = new RegExp("^(?:([+-])=|)(" + et + ")([a-z%]*)$", "i"),
        nt = ["Top", "Right", "Bottom", "Left"], rt = n.documentElement, ot = function (t) {
            return M.contains(t.ownerDocument, t)
        }, at = {composed: !0};
    rt.getRootNode && (ot = function (t) {
        return M.contains(t.ownerDocument, t) || t.getRootNode(at) === t.ownerDocument
    });
    var st = function (t, e) {
        return "none" === (t = e || t).style.display || "" === t.style.display && ot(t) && "none" === M.css(t, "display")
    }, lt = function (t, e, i, n) {
        var r, o, a = {};
        for (o in e) a[o] = t.style[o], t.style[o] = e[o];
        for (o in r = i.apply(t, n || []), e) t.style[o] = a[o];
        return r
    };

    function ht(t, e, i, n) {
        var r, o, a = 20, s = n ? function () {
                return n.cur()
            } : function () {
                return M.css(t, e, "")
            }, l = s(), h = i && i[3] || (M.cssNumber[e] ? "" : "px"),
            c = t.nodeType && (M.cssNumber[e] || "px" !== h && +l) && it.exec(M.css(t, e));
        if (c && c[3] !== h) {
            for (l /= 2, h = h || c[3], c = +l || 1; a--;) M.style(t, e, c + h), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), c /= o;
            c *= 2, M.style(t, e, c + h), i = i || []
        }
        return i && (c = +c || +l || 0, r = i[1] ? c + (i[1] + 1) * i[2] : +i[2], n && (n.unit = h, n.start = c, n.end = r)), r
    }

    var ct = {};

    function ut(t, e) {
        for (var i, n, r, o, a, s, l, h = [], c = 0, u = t.length; c < u; c++) (n = t[c]).style && (i = n.style.display, e ? ("none" === i && (h[c] = K.get(n, "display") || null, h[c] || (n.style.display = "")), "" === n.style.display && st(n) && (h[c] = (l = a = o = void 0, a = (r = n).ownerDocument, s = r.nodeName, (l = ct[s]) || (o = a.body.appendChild(a.createElement(s)), l = M.css(o, "display"), o.parentNode.removeChild(o), "none" === l && (l = "block"), ct[s] = l)))) : "none" !== i && (h[c] = "none", K.set(n, "display", i)));
        for (c = 0; c < u; c++) null != h[c] && (t[c].style.display = h[c]);
        return t
    }

    M.fn.extend({
        show: function () {
            return ut(this, !0)
        }, hide: function () {
            return ut(this)
        }, toggle: function (t) {
            return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function () {
                st(this) ? M(this).show() : M(this).hide()
            })
        }
    });
    var dt = /^(?:checkbox|radio)$/i, ft = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, pt = /^$|^module$|\/(?:java|ecma)script/i,
        gt = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

    function mt(t, e) {
        var i;
        return i = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && C(t, e) ? M.merge([t], i) : i
    }

    function vt(t, e) {
        for (var i = 0, n = t.length; i < n; i++) K.set(t[i], "globalEval", !e || K.get(e[i], "globalEval"))
    }

    gt.optgroup = gt.option, gt.tbody = gt.tfoot = gt.colgroup = gt.caption = gt.thead, gt.th = gt.td;
    var yt, xt, bt = /<|&#?\w+;/;

    function Mt(t, e, i, n, r) {
        for (var o, a, s, l, h, c, u = e.createDocumentFragment(), d = [], f = 0, p = t.length; f < p; f++) if ((o = t[f]) || 0 === o) if ("object" === x(o)) M.merge(d, o.nodeType ? [o] : o); else if (bt.test(o)) {
            for (a = a || u.appendChild(e.createElement("div")), s = (ft.exec(o) || ["", ""])[1].toLowerCase(), l = gt[s] || gt._default, a.innerHTML = l[1] + M.htmlPrefilter(o) + l[2], c = l[0]; c--;) a = a.lastChild;
            M.merge(d, a.childNodes), (a = u.firstChild).textContent = ""
        } else d.push(e.createTextNode(o));
        for (u.textContent = "", f = 0; o = d[f++];) if (n && -1 < M.inArray(o, n)) r && r.push(o); else if (h = ot(o), a = mt(u.appendChild(o), "script"), h && vt(a), i) for (c = 0; o = a[c++];) pt.test(o.type || "") && i.push(o);
        return u
    }

    yt = n.createDocumentFragment().appendChild(n.createElement("div")), (xt = n.createElement("input")).setAttribute("type", "radio"), xt.setAttribute("checked", "checked"), xt.setAttribute("name", "t"), yt.appendChild(xt), p.checkClone = yt.cloneNode(!0).cloneNode(!0).lastChild.checked, yt.innerHTML = "<textarea>x</textarea>", p.noCloneChecked = !!yt.cloneNode(!0).lastChild.defaultValue;
    var At = /^key/, wt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, kt = /^([^.]*)(?:\.(.+)|)/;

    function St() {
        return !0
    }

    function Tt() {
        return !1
    }

    function Et(t, e) {
        return t === function () {
            try {
                return n.activeElement
            } catch (t) {
            }
        }() == ("focus" === e)
    }

    function Ct(t, e, i, n, r, o) {
        var a, s;
        if ("object" == typeof e) {
            for (s in "string" != typeof i && (n = n || i, i = void 0), e) Ct(t, s, i, n, e[s], o);
            return t
        }
        if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), !1 === r) r = Tt; else if (!r) return t;
        return 1 === o && (a = r, (r = function (t) {
            return M().off(t), a.apply(this, arguments)
        }).guid = a.guid || (a.guid = M.guid++)), t.each(function () {
            M.event.add(this, e, r, n, i)
        })
    }

    function Dt(t, e, i) {
        i ? (K.set(t, e, !1), M.event.add(t, e, {
            namespace: !1, handler: function (t) {
                var n, r, a = K.get(this, e);
                if (1 & t.isTrigger && this[e]) {
                    if (a.length) (M.event.special[e] || {}).delegateType && t.stopPropagation(); else if (a = o.call(arguments), K.set(this, e, a), n = i(this, e), this[e](), a !== (r = K.get(this, e)) || n ? K.set(this, e, !1) : r = {}, a !== r) return t.stopImmediatePropagation(), t.preventDefault(), r.value
                } else a.length && (K.set(this, e, {value: M.event.trigger(M.extend(a[0], M.Event.prototype), a.slice(1), this)}), t.stopImmediatePropagation())
            }
        })) : void 0 === K.get(t, e) && M.event.add(t, e, St)
    }

    M.event = {
        global: {}, add: function (t, e, i, n, r) {
            var o, a, s, l, h, c, u, d, f, p, g, m = K.get(t);
            if (m) for (i.handler && (i = (o = i).handler, r = o.selector), r && M.find.matchesSelector(rt, r), i.guid || (i.guid = M.guid++), (l = m.events) || (l = m.events = {}), (a = m.handle) || (a = m.handle = function (e) {
                return void 0 !== M && M.event.triggered !== e.type ? M.event.dispatch.apply(t, arguments) : void 0
            }), h = (e = (e || "").match(I) || [""]).length; h--;) f = g = (s = kt.exec(e[h]) || [])[1], p = (s[2] || "").split(".").sort(), f && (u = M.event.special[f] || {}, f = (r ? u.delegateType : u.bindType) || f, u = M.event.special[f] || {}, c = M.extend({
                type: f,
                origType: g,
                data: n,
                handler: i,
                guid: i.guid,
                selector: r,
                needsContext: r && M.expr.match.needsContext.test(r),
                namespace: p.join(".")
            }, o), (d = l[f]) || ((d = l[f] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t, n, p, a) || t.addEventListener && t.addEventListener(f, a)), u.add && (u.add.call(t, c), c.handler.guid || (c.handler.guid = i.guid)), r ? d.splice(d.delegateCount++, 0, c) : d.push(c), M.event.global[f] = !0)
        }, remove: function (t, e, i, n, r) {
            var o, a, s, l, h, c, u, d, f, p, g, m = K.hasData(t) && K.get(t);
            if (m && (l = m.events)) {
                for (h = (e = (e || "").match(I) || [""]).length; h--;) if (f = g = (s = kt.exec(e[h]) || [])[1], p = (s[2] || "").split(".").sort(), f) {
                    for (u = M.event.special[f] || {}, d = l[f = (n ? u.delegateType : u.bindType) || f] || [], s = s[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) c = d[o], !r && g !== c.origType || i && i.guid !== c.guid || s && !s.test(c.namespace) || n && n !== c.selector && ("**" !== n || !c.selector) || (d.splice(o, 1), c.selector && d.delegateCount--, u.remove && u.remove.call(t, c));
                    a && !d.length && (u.teardown && !1 !== u.teardown.call(t, p, m.handle) || M.removeEvent(t, f, m.handle), delete l[f])
                } else for (f in l) M.event.remove(t, f + e[h], i, n, !0);
                M.isEmptyObject(l) && K.remove(t, "handle events")
            }
        }, dispatch: function (t) {
            var e, i, n, r, o, a, s = M.event.fix(t), l = new Array(arguments.length),
                h = (K.get(this, "events") || {})[s.type] || [], c = M.event.special[s.type] || {};
            for (l[0] = s, e = 1; e < arguments.length; e++) l[e] = arguments[e];
            if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) {
                for (a = M.event.handlers.call(this, s, h), e = 0; (r = a[e++]) && !s.isPropagationStopped();) for (s.currentTarget = r.elem, i = 0; (o = r.handlers[i++]) && !s.isImmediatePropagationStopped();) s.rnamespace && !1 !== o.namespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (n = ((M.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, l)) && !1 === (s.result = n) && (s.preventDefault(), s.stopPropagation()));
                return c.postDispatch && c.postDispatch.call(this, s), s.result
            }
        }, handlers: function (t, e) {
            var i, n, r, o, a, s = [], l = e.delegateCount, h = t.target;
            if (l && h.nodeType && !("click" === t.type && 1 <= t.button)) for (; h !== this; h = h.parentNode || this) if (1 === h.nodeType && ("click" !== t.type || !0 !== h.disabled)) {
                for (o = [], a = {}, i = 0; i < l; i++) void 0 === a[r = (n = e[i]).selector + " "] && (a[r] = n.needsContext ? -1 < M(r, this).index(h) : M.find(r, this, null, [h]).length), a[r] && o.push(n);
                o.length && s.push({elem: h, handlers: o})
            }
            return h = this, l < e.length && s.push({elem: h, handlers: e.slice(l)}), s
        }, addProp: function (t, e) {
            Object.defineProperty(M.Event.prototype, t, {
                enumerable: !0, configurable: !0, get: g(e) ? function () {
                    if (this.originalEvent) return e(this.originalEvent)
                } : function () {
                    if (this.originalEvent) return this.originalEvent[t]
                }, set: function (e) {
                    Object.defineProperty(this, t, {enumerable: !0, configurable: !0, writable: !0, value: e})
                }
            })
        }, fix: function (t) {
            return t[M.expando] ? t : new M.Event(t)
        }, special: {
            load: {noBubble: !0}, click: {
                setup: function (t) {
                    var e = this || t;
                    return dt.test(e.type) && e.click && C(e, "input") && Dt(e, "click", St), !1
                }, trigger: function (t) {
                    var e = this || t;
                    return dt.test(e.type) && e.click && C(e, "input") && Dt(e, "click"), !0
                }, _default: function (t) {
                    var e = t.target;
                    return dt.test(e.type) && e.click && C(e, "input") && K.get(e, "click") || C(e, "a")
                }
            }, beforeunload: {
                postDispatch: function (t) {
                    void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                }
            }
        }
    }, M.removeEvent = function (t, e, i) {
        t.removeEventListener && t.removeEventListener(e, i)
    }, M.Event = function (t, e) {
        if (!(this instanceof M.Event)) return new M.Event(t, e);
        t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? St : Tt, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && M.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[M.expando] = !0
    }, M.Event.prototype = {
        constructor: M.Event,
        isDefaultPrevented: Tt,
        isPropagationStopped: Tt,
        isImmediatePropagationStopped: Tt,
        isSimulated: !1,
        preventDefault: function () {
            var t = this.originalEvent;
            this.isDefaultPrevented = St, t && !this.isSimulated && t.preventDefault()
        },
        stopPropagation: function () {
            var t = this.originalEvent;
            this.isPropagationStopped = St, t && !this.isSimulated && t.stopPropagation()
        },
        stopImmediatePropagation: function () {
            var t = this.originalEvent;
            this.isImmediatePropagationStopped = St, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
        }
    }, M.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function (t) {
            var e = t.button;
            return null == t.which && At.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && wt.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
        }
    }, M.event.addProp), M.each({focus: "focusin", blur: "focusout"}, function (t, e) {
        M.event.special[t] = {
            setup: function () {
                return Dt(this, t, Et), !1
            }, trigger: function () {
                return Dt(this, t), !0
            }, delegateType: e
        }
    }), M.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (t, e) {
        M.event.special[t] = {
            delegateType: e, bindType: e, handle: function (t) {
                var i, n = t.relatedTarget, r = t.handleObj;
                return n && (n === this || M.contains(this, n)) || (t.type = r.origType, i = r.handler.apply(this, arguments), t.type = e), i
            }
        }
    }), M.fn.extend({
        on: function (t, e, i, n) {
            return Ct(this, t, e, i, n)
        }, one: function (t, e, i, n) {
            return Ct(this, t, e, i, n, 1)
        }, off: function (t, e, i) {
            var n, r;
            if (t && t.preventDefault && t.handleObj) return n = t.handleObj, M(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
            if ("object" == typeof t) {
                for (r in t) this.off(r, e, t[r]);
                return this
            }
            return !1 !== e && "function" != typeof e || (i = e, e = void 0), !1 === i && (i = Tt), this.each(function () {
                M.event.remove(this, t, i, e)
            })
        }
    });
    var Pt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        _t = /<script|<style|<link/i, Ot = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Lt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function Nt(t, e) {
        return C(t, "table") && C(11 !== e.nodeType ? e : e.firstChild, "tr") && M(t).children("tbody")[0] || t
    }

    function zt(t) {
        return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
    }

    function It(t) {
        return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
    }

    function Rt(t, e) {
        var i, n, r, o, a, s, l, h;
        if (1 === e.nodeType) {
            if (K.hasData(t) && (o = K.access(t), a = K.set(e, o), h = o.events)) for (r in delete a.handle, a.events = {}, h) for (i = 0, n = h[r].length; i < n; i++) M.event.add(e, r, h[r][i]);
            Z.hasData(t) && (s = Z.access(t), l = M.extend({}, s), Z.set(e, l))
        }
    }

    function Bt(t, e, i, n) {
        e = a.apply([], e);
        var r, o, s, l, h, c, u = 0, d = t.length, f = d - 1, m = e[0], v = g(m);
        if (v || 1 < d && "string" == typeof m && !p.checkClone && Ot.test(m)) return t.each(function (r) {
            var o = t.eq(r);
            v && (e[0] = m.call(this, r, o.html())), Bt(o, e, i, n)
        });
        if (d && (o = (r = Mt(e, t[0].ownerDocument, !1, t, n)).firstChild, 1 === r.childNodes.length && (r = o), o || n)) {
            for (l = (s = M.map(mt(r, "script"), zt)).length; u < d; u++) h = r, u !== f && (h = M.clone(h, !0, !0), l && M.merge(s, mt(h, "script"))), i.call(t[u], h, u);
            if (l) for (c = s[s.length - 1].ownerDocument, M.map(s, It), u = 0; u < l; u++) h = s[u], pt.test(h.type || "") && !K.access(h, "globalEval") && M.contains(c, h) && (h.src && "module" !== (h.type || "").toLowerCase() ? M._evalUrl && !h.noModule && M._evalUrl(h.src, {nonce: h.nonce || h.getAttribute("nonce")}) : y(h.textContent.replace(Lt, ""), h, c))
        }
        return t
    }

    function jt(t, e, i) {
        for (var n, r = e ? M.filter(e, t) : t, o = 0; null != (n = r[o]); o++) i || 1 !== n.nodeType || M.cleanData(mt(n)), n.parentNode && (i && ot(n) && vt(mt(n, "script")), n.parentNode.removeChild(n));
        return t
    }

    M.extend({
        htmlPrefilter: function (t) {
            return t.replace(Pt, "<$1></$2>")
        }, clone: function (t, e, i) {
            var n, r, o, a, s, l, h, c = t.cloneNode(!0), u = ot(t);
            if (!(p.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || M.isXMLDoc(t))) for (a = mt(c), n = 0, r = (o = mt(t)).length; n < r; n++) s = o[n], "input" === (h = (l = a[n]).nodeName.toLowerCase()) && dt.test(s.type) ? l.checked = s.checked : "input" !== h && "textarea" !== h || (l.defaultValue = s.defaultValue);
            if (e) if (i) for (o = o || mt(t), a = a || mt(c), n = 0, r = o.length; n < r; n++) Rt(o[n], a[n]); else Rt(t, c);
            return 0 < (a = mt(c, "script")).length && vt(a, !u && mt(t, "script")), c
        }, cleanData: function (t) {
            for (var e, i, n, r = M.event.special, o = 0; void 0 !== (i = t[o]); o++) if ($(i)) {
                if (e = i[K.expando]) {
                    if (e.events) for (n in e.events) r[n] ? M.event.remove(i, n) : M.removeEvent(i, n, e.handle);
                    i[K.expando] = void 0
                }
                i[Z.expando] && (i[Z.expando] = void 0)
            }
        }
    }), M.fn.extend({
        detach: function (t) {
            return jt(this, t, !0)
        }, remove: function (t) {
            return jt(this, t)
        }, text: function (t) {
            return G(this, function (t) {
                return void 0 === t ? M.text(this) : this.empty().each(function () {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                })
            }, null, t, arguments.length)
        }, append: function () {
            return Bt(this, arguments, function (t) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Nt(this, t).appendChild(t)
            })
        }, prepend: function () {
            return Bt(this, arguments, function (t) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var e = Nt(this, t);
                    e.insertBefore(t, e.firstChild)
                }
            })
        }, before: function () {
            return Bt(this, arguments, function (t) {
                this.parentNode && this.parentNode.insertBefore(t, this)
            })
        }, after: function () {
            return Bt(this, arguments, function (t) {
                this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
            })
        }, empty: function () {
            for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (M.cleanData(mt(t, !1)), t.textContent = "");
            return this
        }, clone: function (t, e) {
            return t = null != t && t, e = null == e ? t : e, this.map(function () {
                return M.clone(this, t, e)
            })
        }, html: function (t) {
            return G(this, function (t) {
                var e = this[0] || {}, i = 0, n = this.length;
                if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                if ("string" == typeof t && !_t.test(t) && !gt[(ft.exec(t) || ["", ""])[1].toLowerCase()]) {
                    t = M.htmlPrefilter(t);
                    try {
                        for (; i < n; i++) 1 === (e = this[i] || {}).nodeType && (M.cleanData(mt(e, !1)), e.innerHTML = t);
                        e = 0
                    } catch (t) {
                    }
                }
                e && this.empty().append(t)
            }, null, t, arguments.length)
        }, replaceWith: function () {
            var t = [];
            return Bt(this, arguments, function (e) {
                var i = this.parentNode;
                M.inArray(this, t) < 0 && (M.cleanData(mt(this)), i && i.replaceChild(e, this))
            }, t)
        }
    }), M.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (t, e) {
        M.fn[t] = function (t) {
            for (var i, n = [], r = M(t), o = r.length - 1, a = 0; a <= o; a++) i = a === o ? this : this.clone(!0), M(r[a])[e](i), s.apply(n, i.get());
            return this.pushStack(n)
        }
    });
    var Wt = new RegExp("^(" + et + ")(?!px)[a-z%]+$", "i"), Ht = function (e) {
        var i = e.ownerDocument.defaultView;
        return i && i.opener || (i = t), i.getComputedStyle(e)
    }, Yt = new RegExp(nt.join("|"), "i");

    function Gt(t, e, i) {
        var n, r, o, a, s = t.style;
        return (i = i || Ht(t)) && ("" !== (a = i.getPropertyValue(e) || i[e]) || ot(t) || (a = M.style(t, e)), !p.pixelBoxStyles() && Wt.test(a) && Yt.test(e) && (n = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = n, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
    }

    function Ft(t, e) {
        return {
            get: function () {
                if (!t()) return (this.get = e).apply(this, arguments);
                delete this.get
            }
        }
    }

    !function () {
        function e() {
            if (c) {
                h.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", rt.appendChild(h).appendChild(c);
                var e = t.getComputedStyle(c);
                r = "1%" !== e.top, l = 12 === i(e.marginLeft), c.style.right = "60%", s = 36 === i(e.right), o = 36 === i(e.width), c.style.position = "absolute", a = 12 === i(c.offsetWidth / 3), rt.removeChild(h), c = null
            }
        }

        function i(t) {
            return Math.round(parseFloat(t))
        }

        var r, o, a, s, l, h = n.createElement("div"), c = n.createElement("div");
        c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", p.clearCloneStyle = "content-box" === c.style.backgroundClip, M.extend(p, {
            boxSizingReliable: function () {
                return e(), o
            }, pixelBoxStyles: function () {
                return e(), s
            }, pixelPosition: function () {
                return e(), r
            }, reliableMarginLeft: function () {
                return e(), l
            }, scrollboxSize: function () {
                return e(), a
            }
        }))
    }();
    var Xt = ["Webkit", "Moz", "ms"], Ut = n.createElement("div").style, qt = {};

    function $t(t) {
        return M.cssProps[t] || qt[t] || (t in Ut ? t : qt[t] = function (t) {
            for (var e = t[0].toUpperCase() + t.slice(1), i = Xt.length; i--;) if ((t = Xt[i] + e) in Ut) return t
        }(t) || t)
    }

    var Vt = /^(none|table(?!-c[ea]).+)/, Kt = /^--/,
        Zt = {position: "absolute", visibility: "hidden", display: "block"},
        Jt = {letterSpacing: "0", fontWeight: "400"};

    function Qt(t, e, i) {
        var n = it.exec(e);
        return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : e
    }

    function te(t, e, i, n, r, o) {
        var a = "width" === e ? 1 : 0, s = 0, l = 0;
        if (i === (n ? "border" : "content")) return 0;
        for (; a < 4; a += 2) "margin" === i && (l += M.css(t, i + nt[a], !0, r)), n ? ("content" === i && (l -= M.css(t, "padding" + nt[a], !0, r)), "margin" !== i && (l -= M.css(t, "border" + nt[a] + "Width", !0, r))) : (l += M.css(t, "padding" + nt[a], !0, r), "padding" !== i ? l += M.css(t, "border" + nt[a] + "Width", !0, r) : s += M.css(t, "border" + nt[a] + "Width", !0, r));
        return !n && 0 <= o && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o - l - s - .5)) || 0), l
    }

    function ee(t, e, i) {
        var n = Ht(t), r = (!p.boxSizingReliable() || i) && "border-box" === M.css(t, "boxSizing", !1, n), o = r,
            a = Gt(t, e, n), s = "offset" + e[0].toUpperCase() + e.slice(1);
        if (Wt.test(a)) {
            if (!i) return a;
            a = "auto"
        }
        return (!p.boxSizingReliable() && r || "auto" === a || !parseFloat(a) && "inline" === M.css(t, "display", !1, n)) && t.getClientRects().length && (r = "border-box" === M.css(t, "boxSizing", !1, n), (o = s in t) && (a = t[s])), (a = parseFloat(a) || 0) + te(t, e, i || (r ? "border" : "content"), o, n, a) + "px"
    }

    function ie(t, e, i, n, r) {
        return new ie.prototype.init(t, e, i, n, r)
    }

    M.extend({
        cssHooks: {
            opacity: {
                get: function (t, e) {
                    if (e) {
                        var i = Gt(t, "opacity");
                        return "" === i ? "1" : i
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function (t, e, i, n) {
            if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                var r, o, a, s = q(e), l = Kt.test(e), h = t.style;
                if (l || (e = $t(s)), a = M.cssHooks[e] || M.cssHooks[s], void 0 === i) return a && "get" in a && void 0 !== (r = a.get(t, !1, n)) ? r : h[e];
                "string" == (o = typeof i) && (r = it.exec(i)) && r[1] && (i = ht(t, e, r), o = "number"), null != i && i == i && ("number" !== o || l || (i += r && r[3] || (M.cssNumber[s] ? "" : "px")), p.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (h[e] = "inherit"), a && "set" in a && void 0 === (i = a.set(t, i, n)) || (l ? h.setProperty(e, i) : h[e] = i))
            }
        },
        css: function (t, e, i, n) {
            var r, o, a, s = q(e);
            return Kt.test(e) || (e = $t(s)), (a = M.cssHooks[e] || M.cssHooks[s]) && "get" in a && (r = a.get(t, !0, i)), void 0 === r && (r = Gt(t, e, n)), "normal" === r && e in Jt && (r = Jt[e]), "" === i || i ? (o = parseFloat(r), !0 === i || isFinite(o) ? o || 0 : r) : r
        }
    }), M.each(["height", "width"], function (t, e) {
        M.cssHooks[e] = {
            get: function (t, i, n) {
                if (i) return !Vt.test(M.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ee(t, e, n) : lt(t, Zt, function () {
                    return ee(t, e, n)
                })
            }, set: function (t, i, n) {
                var r, o = Ht(t), a = !p.scrollboxSize() && "absolute" === o.position,
                    s = (a || n) && "border-box" === M.css(t, "boxSizing", !1, o), l = n ? te(t, e, n, s, o) : 0;
                return s && a && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(o[e]) - te(t, e, "border", !1, o) - .5)), l && (r = it.exec(i)) && "px" !== (r[3] || "px") && (t.style[e] = i, i = M.css(t, e)), Qt(0, i, l)
            }
        }
    }), M.cssHooks.marginLeft = Ft(p.reliableMarginLeft, function (t, e) {
        if (e) return (parseFloat(Gt(t, "marginLeft")) || t.getBoundingClientRect().left - lt(t, {marginLeft: 0}, function () {
            return t.getBoundingClientRect().left
        })) + "px"
    }), M.each({margin: "", padding: "", border: "Width"}, function (t, e) {
        M.cssHooks[t + e] = {
            expand: function (i) {
                for (var n = 0, r = {}, o = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++) r[t + nt[n] + e] = o[n] || o[n - 2] || o[0];
                return r
            }
        }, "margin" !== t && (M.cssHooks[t + e].set = Qt)
    }), M.fn.extend({
        css: function (t, e) {
            return G(this, function (t, e, i) {
                var n, r, o = {}, a = 0;
                if (Array.isArray(e)) {
                    for (n = Ht(t), r = e.length; a < r; a++) o[e[a]] = M.css(t, e[a], !1, n);
                    return o
                }
                return void 0 !== i ? M.style(t, e, i) : M.css(t, e)
            }, t, e, 1 < arguments.length)
        }
    }), ((M.Tween = ie).prototype = {
        constructor: ie, init: function (t, e, i, n, r, o) {
            this.elem = t, this.prop = i, this.easing = r || M.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = o || (M.cssNumber[i] ? "" : "px")
        }, cur: function () {
            var t = ie.propHooks[this.prop];
            return t && t.get ? t.get(this) : ie.propHooks._default.get(this)
        }, run: function (t) {
            var e, i = ie.propHooks[this.prop];
            return this.options.duration ? this.pos = e = M.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : ie.propHooks._default.set(this), this
        }
    }).init.prototype = ie.prototype, (ie.propHooks = {
        _default: {
            get: function (t) {
                var e;
                return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = M.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
            }, set: function (t) {
                M.fx.step[t.prop] ? M.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !M.cssHooks[t.prop] && null == t.elem.style[$t(t.prop)] ? t.elem[t.prop] = t.now : M.style(t.elem, t.prop, t.now + t.unit)
            }
        }
    }).scrollTop = ie.propHooks.scrollLeft = {
        set: function (t) {
            t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
        }
    }, M.easing = {
        linear: function (t) {
            return t
        }, swing: function (t) {
            return .5 - Math.cos(t * Math.PI) / 2
        }, _default: "swing"
    }, M.fx = ie.prototype.init, M.fx.step = {};
    var ne, re, oe, ae, se = /^(?:toggle|show|hide)$/, le = /queueHooks$/;

    function he() {
        re && (!1 === n.hidden && t.requestAnimationFrame ? t.requestAnimationFrame(he) : t.setTimeout(he, M.fx.interval), M.fx.tick())
    }

    function ce() {
        return t.setTimeout(function () {
            ne = void 0
        }), ne = Date.now()
    }

    function ue(t, e) {
        var i, n = 0, r = {height: t};
        for (e = e ? 1 : 0; n < 4; n += 2 - e) r["margin" + (i = nt[n])] = r["padding" + i] = t;
        return e && (r.opacity = r.width = t), r
    }

    function de(t, e, i) {
        for (var n, r = (fe.tweeners[e] || []).concat(fe.tweeners["*"]), o = 0, a = r.length; o < a; o++) if (n = r[o].call(i, e, t)) return n
    }

    function fe(t, e, i) {
        var n, r, o = 0, a = fe.prefilters.length, s = M.Deferred().always(function () {
            delete l.elem
        }), l = function () {
            if (r) return !1;
            for (var e = ne || ce(), i = Math.max(0, h.startTime + h.duration - e), n = 1 - (i / h.duration || 0), o = 0, a = h.tweens.length; o < a; o++) h.tweens[o].run(n);
            return s.notifyWith(t, [h, n, i]), n < 1 && a ? i : (a || s.notifyWith(t, [h, 1, 0]), s.resolveWith(t, [h]), !1)
        }, h = s.promise({
            elem: t,
            props: M.extend({}, e),
            opts: M.extend(!0, {specialEasing: {}, easing: M.easing._default}, i),
            originalProperties: e,
            originalOptions: i,
            startTime: ne || ce(),
            duration: i.duration,
            tweens: [],
            createTween: function (e, i) {
                var n = M.Tween(t, h.opts, e, i, h.opts.specialEasing[e] || h.opts.easing);
                return h.tweens.push(n), n
            },
            stop: function (e) {
                var i = 0, n = e ? h.tweens.length : 0;
                if (r) return this;
                for (r = !0; i < n; i++) h.tweens[i].run(1);
                return e ? (s.notifyWith(t, [h, 1, 0]), s.resolveWith(t, [h, e])) : s.rejectWith(t, [h, e]), this
            }
        }), c = h.props;
        for (function (t, e) {
            var i, n, r, o, a;
            for (i in t) if (r = e[n = q(i)], o = t[i], Array.isArray(o) && (r = o[1], o = t[i] = o[0]), i !== n && (t[n] = o, delete t[i]), (a = M.cssHooks[n]) && "expand" in a) for (i in o = a.expand(o), delete t[n], o) i in t || (t[i] = o[i], e[i] = r); else e[n] = r
        }(c, h.opts.specialEasing); o < a; o++) if (n = fe.prefilters[o].call(h, t, c, h.opts)) return g(n.stop) && (M._queueHooks(h.elem, h.opts.queue).stop = n.stop.bind(n)), n;
        return M.map(c, de, h), g(h.opts.start) && h.opts.start.call(t, h), h.progress(h.opts.progress).done(h.opts.done, h.opts.complete).fail(h.opts.fail).always(h.opts.always), M.fx.timer(M.extend(l, {
            elem: t,
            anim: h,
            queue: h.opts.queue
        })), h
    }

    M.Animation = M.extend(fe, {
        tweeners: {
            "*": [function (t, e) {
                var i = this.createTween(t, e);
                return ht(i.elem, t, it.exec(e), i), i
            }]
        }, tweener: function (t, e) {
            g(t) ? (e = t, t = ["*"]) : t = t.match(I);
            for (var i, n = 0, r = t.length; n < r; n++) i = t[n], fe.tweeners[i] = fe.tweeners[i] || [], fe.tweeners[i].unshift(e)
        }, prefilters: [function (t, e, i) {
            var n, r, o, a, s, l, h, c, u = "width" in e || "height" in e, d = this, f = {}, p = t.style,
                g = t.nodeType && st(t), m = K.get(t, "fxshow");
            for (n in i.queue || (null == (a = M._queueHooks(t, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
                a.unqueued || s()
            }), a.unqueued++, d.always(function () {
                d.always(function () {
                    a.unqueued--, M.queue(t, "fx").length || a.empty.fire()
                })
            })), e) if (r = e[n], se.test(r)) {
                if (delete e[n], o = o || "toggle" === r, r === (g ? "hide" : "show")) {
                    if ("show" !== r || !m || void 0 === m[n]) continue;
                    g = !0
                }
                f[n] = m && m[n] || M.style(t, n)
            }
            if ((l = !M.isEmptyObject(e)) || !M.isEmptyObject(f)) for (n in u && 1 === t.nodeType && (i.overflow = [p.overflow, p.overflowX, p.overflowY], null == (h = m && m.display) && (h = K.get(t, "display")), "none" === (c = M.css(t, "display")) && (h ? c = h : (ut([t], !0), h = t.style.display || h, c = M.css(t, "display"), ut([t]))), ("inline" === c || "inline-block" === c && null != h) && "none" === M.css(t, "float") && (l || (d.done(function () {
                p.display = h
            }), null == h && (c = p.display, h = "none" === c ? "" : c)), p.display = "inline-block")), i.overflow && (p.overflow = "hidden", d.always(function () {
                p.overflow = i.overflow[0], p.overflowX = i.overflow[1], p.overflowY = i.overflow[2]
            })), l = !1, f) l || (m ? "hidden" in m && (g = m.hidden) : m = K.access(t, "fxshow", {display: h}), o && (m.hidden = !g), g && ut([t], !0), d.done(function () {
                for (n in g || ut([t]), K.remove(t, "fxshow"), f) M.style(t, n, f[n])
            })), l = de(g ? m[n] : 0, n, d), n in m || (m[n] = l.start, g && (l.end = l.start, l.start = 0))
        }], prefilter: function (t, e) {
            e ? fe.prefilters.unshift(t) : fe.prefilters.push(t)
        }
    }), M.speed = function (t, e, i) {
        var n = t && "object" == typeof t ? M.extend({}, t) : {
            complete: i || !i && e || g(t) && t,
            duration: t,
            easing: i && e || e && !g(e) && e
        };
        return M.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in M.fx.speeds ? n.duration = M.fx.speeds[n.duration] : n.duration = M.fx.speeds._default), null != n.queue && !0 !== n.queue || (n.queue = "fx"), n.old = n.complete, n.complete = function () {
            g(n.old) && n.old.call(this), n.queue && M.dequeue(this, n.queue)
        }, n
    }, M.fn.extend({
        fadeTo: function (t, e, i, n) {
            return this.filter(st).css("opacity", 0).show().end().animate({opacity: e}, t, i, n)
        }, animate: function (t, e, i, n) {
            var r = M.isEmptyObject(t), o = M.speed(e, i, n), a = function () {
                var e = fe(this, M.extend({}, t), o);
                (r || K.get(this, "finish")) && e.stop(!0)
            };
            return a.finish = a, r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
        }, stop: function (t, e, i) {
            var n = function (t) {
                var e = t.stop;
                delete t.stop, e(i)
            };
            return "string" != typeof t && (i = e, e = t, t = void 0), e && !1 !== t && this.queue(t || "fx", []), this.each(function () {
                var e = !0, r = null != t && t + "queueHooks", o = M.timers, a = K.get(this);
                if (r) a[r] && a[r].stop && n(a[r]); else for (r in a) a[r] && a[r].stop && le.test(r) && n(a[r]);
                for (r = o.length; r--;) o[r].elem !== this || null != t && o[r].queue !== t || (o[r].anim.stop(i), e = !1, o.splice(r, 1));
                !e && i || M.dequeue(this, t)
            })
        }, finish: function (t) {
            return !1 !== t && (t = t || "fx"), this.each(function () {
                var e, i = K.get(this), n = i[t + "queue"], r = i[t + "queueHooks"], o = M.timers, a = n ? n.length : 0;
                for (i.finish = !0, M.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
                for (e = 0; e < a; e++) n[e] && n[e].finish && n[e].finish.call(this);
                delete i.finish
            })
        }
    }), M.each(["toggle", "show", "hide"], function (t, e) {
        var i = M.fn[e];
        M.fn[e] = function (t, n, r) {
            return null == t || "boolean" == typeof t ? i.apply(this, arguments) : this.animate(ue(e, !0), t, n, r)
        }
    }), M.each({
        slideDown: ue("show"),
        slideUp: ue("hide"),
        slideToggle: ue("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (t, e) {
        M.fn[t] = function (t, i, n) {
            return this.animate(e, t, i, n)
        }
    }), M.timers = [], M.fx.tick = function () {
        var t, e = 0, i = M.timers;
        for (ne = Date.now(); e < i.length; e++) (t = i[e])() || i[e] !== t || i.splice(e--, 1);
        i.length || M.fx.stop(), ne = void 0
    }, M.fx.timer = function (t) {
        M.timers.push(t), M.fx.start()
    }, M.fx.interval = 13, M.fx.start = function () {
        re || (re = !0, he())
    }, M.fx.stop = function () {
        re = null
    }, M.fx.speeds = {slow: 600, fast: 200, _default: 400}, M.fn.delay = function (e, i) {
        return e = M.fx && M.fx.speeds[e] || e, i = i || "fx", this.queue(i, function (i, n) {
            var r = t.setTimeout(i, e);
            n.stop = function () {
                t.clearTimeout(r)
            }
        })
    }, oe = n.createElement("input"), ae = n.createElement("select").appendChild(n.createElement("option")), oe.type = "checkbox", p.checkOn = "" !== oe.value, p.optSelected = ae.selected, (oe = n.createElement("input")).value = "t", oe.type = "radio", p.radioValue = "t" === oe.value;
    var pe, ge = M.expr.attrHandle;
    M.fn.extend({
        attr: function (t, e) {
            return G(this, M.attr, t, e, 1 < arguments.length)
        }, removeAttr: function (t) {
            return this.each(function () {
                M.removeAttr(this, t)
            })
        }
    }), M.extend({
        attr: function (t, e, i) {
            var n, r, o = t.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return void 0 === t.getAttribute ? M.prop(t, e, i) : (1 === o && M.isXMLDoc(t) || (r = M.attrHooks[e.toLowerCase()] || (M.expr.match.bool.test(e) ? pe : void 0)), void 0 !== i ? null === i ? void M.removeAttr(t, e) : r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : r && "get" in r && null !== (n = r.get(t, e)) ? n : null == (n = M.find.attr(t, e)) ? void 0 : n)
        }, attrHooks: {
            type: {
                set: function (t, e) {
                    if (!p.radioValue && "radio" === e && C(t, "input")) {
                        var i = t.value;
                        return t.setAttribute("type", e), i && (t.value = i), e
                    }
                }
            }
        }, removeAttr: function (t, e) {
            var i, n = 0, r = e && e.match(I);
            if (r && 1 === t.nodeType) for (; i = r[n++];) t.removeAttribute(i)
        }
    }), pe = {
        set: function (t, e, i) {
            return !1 === e ? M.removeAttr(t, i) : t.setAttribute(i, i), i
        }
    }, M.each(M.expr.match.bool.source.match(/\w+/g), function (t, e) {
        var i = ge[e] || M.find.attr;
        ge[e] = function (t, e, n) {
            var r, o, a = e.toLowerCase();
            return n || (o = ge[a], ge[a] = r, r = null != i(t, e, n) ? a : null, ge[a] = o), r
        }
    });
    var me = /^(?:input|select|textarea|button)$/i, ve = /^(?:a|area)$/i;

    function ye(t) {
        return (t.match(I) || []).join(" ")
    }

    function xe(t) {
        return t.getAttribute && t.getAttribute("class") || ""
    }

    function be(t) {
        return Array.isArray(t) ? t : "string" == typeof t && t.match(I) || []
    }

    M.fn.extend({
        prop: function (t, e) {
            return G(this, M.prop, t, e, 1 < arguments.length)
        }, removeProp: function (t) {
            return this.each(function () {
                delete this[M.propFix[t] || t]
            })
        }
    }), M.extend({
        prop: function (t, e, i) {
            var n, r, o = t.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return 1 === o && M.isXMLDoc(t) || (e = M.propFix[e] || e, r = M.propHooks[e]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : t[e] = i : r && "get" in r && null !== (n = r.get(t, e)) ? n : t[e]
        }, propHooks: {
            tabIndex: {
                get: function (t) {
                    var e = M.find.attr(t, "tabindex");
                    return e ? parseInt(e, 10) : me.test(t.nodeName) || ve.test(t.nodeName) && t.href ? 0 : -1
                }
            }
        }, propFix: {for: "htmlFor", class: "className"}
    }), p.optSelected || (M.propHooks.selected = {
        get: function (t) {
            var e = t.parentNode;
            return e && e.parentNode && e.parentNode.selectedIndex, null
        }, set: function (t) {
            var e = t.parentNode;
            e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
        }
    }), M.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        M.propFix[this.toLowerCase()] = this
    }), M.fn.extend({
        addClass: function (t) {
            var e, i, n, r, o, a, s, l = 0;
            if (g(t)) return this.each(function (e) {
                M(this).addClass(t.call(this, e, xe(this)))
            });
            if ((e = be(t)).length) for (; i = this[l++];) if (r = xe(i), n = 1 === i.nodeType && " " + ye(r) + " ") {
                for (a = 0; o = e[a++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
                r !== (s = ye(n)) && i.setAttribute("class", s)
            }
            return this
        }, removeClass: function (t) {
            var e, i, n, r, o, a, s, l = 0;
            if (g(t)) return this.each(function (e) {
                M(this).removeClass(t.call(this, e, xe(this)))
            });
            if (!arguments.length) return this.attr("class", "");
            if ((e = be(t)).length) for (; i = this[l++];) if (r = xe(i), n = 1 === i.nodeType && " " + ye(r) + " ") {
                for (a = 0; o = e[a++];) for (; -1 < n.indexOf(" " + o + " ");) n = n.replace(" " + o + " ", " ");
                r !== (s = ye(n)) && i.setAttribute("class", s)
            }
            return this
        }, toggleClass: function (t, e) {
            var i = typeof t, n = "string" === i || Array.isArray(t);
            return "boolean" == typeof e && n ? e ? this.addClass(t) : this.removeClass(t) : g(t) ? this.each(function (i) {
                M(this).toggleClass(t.call(this, i, xe(this), e), e)
            }) : this.each(function () {
                var e, r, o, a;
                if (n) for (r = 0, o = M(this), a = be(t); e = a[r++];) o.hasClass(e) ? o.removeClass(e) : o.addClass(e); else void 0 !== t && "boolean" !== i || ((e = xe(this)) && K.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : K.get(this, "__className__") || ""))
            })
        }, hasClass: function (t) {
            var e, i, n = 0;
            for (e = " " + t + " "; i = this[n++];) if (1 === i.nodeType && -1 < (" " + ye(xe(i)) + " ").indexOf(e)) return !0;
            return !1
        }
    });
    var Me = /\r/g;
    M.fn.extend({
        val: function (t) {
            var e, i, n, r = this[0];
            return arguments.length ? (n = g(t), this.each(function (i) {
                var r;
                1 === this.nodeType && (null == (r = n ? t.call(this, i, M(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = M.map(r, function (t) {
                    return null == t ? "" : t + ""
                })), (e = M.valHooks[this.type] || M.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
            })) : r ? (e = M.valHooks[r.type] || M.valHooks[r.nodeName.toLowerCase()]) && "get" in e && void 0 !== (i = e.get(r, "value")) ? i : "string" == typeof (i = r.value) ? i.replace(Me, "") : null == i ? "" : i : void 0
        }
    }), M.extend({
        valHooks: {
            option: {
                get: function (t) {
                    var e = M.find.attr(t, "value");
                    return null != e ? e : ye(M.text(t))
                }
            }, select: {
                get: function (t) {
                    var e, i, n, r = t.options, o = t.selectedIndex, a = "select-one" === t.type, s = a ? null : [],
                        l = a ? o + 1 : r.length;
                    for (n = o < 0 ? l : a ? o : 0; n < l; n++) if (((i = r[n]).selected || n === o) && !i.disabled && (!i.parentNode.disabled || !C(i.parentNode, "optgroup"))) {
                        if (e = M(i).val(), a) return e;
                        s.push(e)
                    }
                    return s
                }, set: function (t, e) {
                    for (var i, n, r = t.options, o = M.makeArray(e), a = r.length; a--;) ((n = r[a]).selected = -1 < M.inArray(M.valHooks.option.get(n), o)) && (i = !0);
                    return i || (t.selectedIndex = -1), o
                }
            }
        }
    }), M.each(["radio", "checkbox"], function () {
        M.valHooks[this] = {
            set: function (t, e) {
                if (Array.isArray(e)) return t.checked = -1 < M.inArray(M(t).val(), e)
            }
        }, p.checkOn || (M.valHooks[this].get = function (t) {
            return null === t.getAttribute("value") ? "on" : t.value
        })
    }), p.focusin = "onfocusin" in t;
    var Ae = /^(?:focusinfocus|focusoutblur)$/, we = function (t) {
        t.stopPropagation()
    };
    M.extend(M.event, {
        trigger: function (e, i, r, o) {
            var a, s, l, h, c, d, f, p, v = [r || n], y = u.call(e, "type") ? e.type : e,
                x = u.call(e, "namespace") ? e.namespace.split(".") : [];
            if (s = p = l = r = r || n, 3 !== r.nodeType && 8 !== r.nodeType && !Ae.test(y + M.event.triggered) && (-1 < y.indexOf(".") && (y = (x = y.split(".")).shift(), x.sort()), c = y.indexOf(":") < 0 && "on" + y, (e = e[M.expando] ? e : new M.Event(y, "object" == typeof e && e)).isTrigger = o ? 2 : 3, e.namespace = x.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = r), i = null == i ? [e] : M.makeArray(i, [e]), f = M.event.special[y] || {}, o || !f.trigger || !1 !== f.trigger.apply(r, i))) {
                if (!o && !f.noBubble && !m(r)) {
                    for (h = f.delegateType || y, Ae.test(h + y) || (s = s.parentNode); s; s = s.parentNode) v.push(s), l = s;
                    l === (r.ownerDocument || n) && v.push(l.defaultView || l.parentWindow || t)
                }
                for (a = 0; (s = v[a++]) && !e.isPropagationStopped();) p = s, e.type = 1 < a ? h : f.bindType || y, (d = (K.get(s, "events") || {})[e.type] && K.get(s, "handle")) && d.apply(s, i), (d = c && s[c]) && d.apply && $(s) && (e.result = d.apply(s, i), !1 === e.result && e.preventDefault());
                return e.type = y, o || e.isDefaultPrevented() || f._default && !1 !== f._default.apply(v.pop(), i) || !$(r) || c && g(r[y]) && !m(r) && ((l = r[c]) && (r[c] = null), M.event.triggered = y, e.isPropagationStopped() && p.addEventListener(y, we), r[y](), e.isPropagationStopped() && p.removeEventListener(y, we), M.event.triggered = void 0, l && (r[c] = l)), e.result
            }
        }, simulate: function (t, e, i) {
            var n = M.extend(new M.Event, i, {type: t, isSimulated: !0});
            M.event.trigger(n, null, e)
        }
    }), M.fn.extend({
        trigger: function (t, e) {
            return this.each(function () {
                M.event.trigger(t, e, this)
            })
        }, triggerHandler: function (t, e) {
            var i = this[0];
            if (i) return M.event.trigger(t, e, i, !0)
        }
    }), p.focusin || M.each({focus: "focusin", blur: "focusout"}, function (t, e) {
        var i = function (t) {
            M.event.simulate(e, t.target, M.event.fix(t))
        };
        M.event.special[e] = {
            setup: function () {
                var n = this.ownerDocument || this, r = K.access(n, e);
                r || n.addEventListener(t, i, !0), K.access(n, e, (r || 0) + 1)
            }, teardown: function () {
                var n = this.ownerDocument || this, r = K.access(n, e) - 1;
                r ? K.access(n, e, r) : (n.removeEventListener(t, i, !0), K.remove(n, e))
            }
        }
    });
    var ke = t.location, Se = Date.now(), Te = /\?/;
    M.parseXML = function (e) {
        var i;
        if (!e || "string" != typeof e) return null;
        try {
            i = (new t.DOMParser).parseFromString(e, "text/xml")
        } catch (e) {
            i = void 0
        }
        return i && !i.getElementsByTagName("parsererror").length || M.error("Invalid XML: " + e), i
    };
    var Ee = /\[\]$/, Ce = /\r?\n/g, De = /^(?:submit|button|image|reset|file)$/i,
        Pe = /^(?:input|select|textarea|keygen)/i;

    function _e(t, e, i, n) {
        var r;
        if (Array.isArray(e)) M.each(e, function (e, r) {
            i || Ee.test(t) ? n(t, r) : _e(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, i, n)
        }); else if (i || "object" !== x(e)) n(t, e); else for (r in e) _e(t + "[" + r + "]", e[r], i, n)
    }

    M.param = function (t, e) {
        var i, n = [], r = function (t, e) {
            var i = g(e) ? e() : e;
            n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == i ? "" : i)
        };
        if (null == t) return "";
        if (Array.isArray(t) || t.jquery && !M.isPlainObject(t)) M.each(t, function () {
            r(this.name, this.value)
        }); else for (i in t) _e(i, t[i], e, r);
        return n.join("&")
    }, M.fn.extend({
        serialize: function () {
            return M.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                var t = M.prop(this, "elements");
                return t ? M.makeArray(t) : this
            }).filter(function () {
                var t = this.type;
                return this.name && !M(this).is(":disabled") && Pe.test(this.nodeName) && !De.test(t) && (this.checked || !dt.test(t))
            }).map(function (t, e) {
                var i = M(this).val();
                return null == i ? null : Array.isArray(i) ? M.map(i, function (t) {
                    return {name: e.name, value: t.replace(Ce, "\r\n")}
                }) : {name: e.name, value: i.replace(Ce, "\r\n")}
            }).get()
        }
    });
    var Oe = /%20/g, Le = /#.*$/, Ne = /([?&])_=[^&]*/, ze = /^(.*?):[ \t]*([^\r\n]*)$/gm, Ie = /^(?:GET|HEAD)$/,
        Re = /^\/\//, Be = {}, je = {}, We = "*/".concat("*"), He = n.createElement("a");

    function Ye(t) {
        return function (e, i) {
            "string" != typeof e && (i = e, e = "*");
            var n, r = 0, o = e.toLowerCase().match(I) || [];
            if (g(i)) for (; n = o[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (t[n] = t[n] || []).unshift(i)) : (t[n] = t[n] || []).push(i)
        }
    }

    function Ge(t, e, i, n) {
        var r = {}, o = t === je;

        function a(s) {
            var l;
            return r[s] = !0, M.each(t[s] || [], function (t, s) {
                var h = s(e, i, n);
                return "string" != typeof h || o || r[h] ? o ? !(l = h) : void 0 : (e.dataTypes.unshift(h), a(h), !1)
            }), l
        }

        return a(e.dataTypes[0]) || !r["*"] && a("*")
    }

    function Fe(t, e) {
        var i, n, r = M.ajaxSettings.flatOptions || {};
        for (i in e) void 0 !== e[i] && ((r[i] ? t : n || (n = {}))[i] = e[i]);
        return n && M.extend(!0, t, n), t
    }

    He.href = ke.href, M.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ke.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(ke.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": We,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
            responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
            converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": M.parseXML},
            flatOptions: {url: !0, context: !0}
        },
        ajaxSetup: function (t, e) {
            return e ? Fe(Fe(t, M.ajaxSettings), e) : Fe(M.ajaxSettings, t)
        },
        ajaxPrefilter: Ye(Be),
        ajaxTransport: Ye(je),
        ajax: function (e, i) {
            "object" == typeof e && (i = e, e = void 0), i = i || {};
            var r, o, a, s, l, h, c, u, d, f, p = M.ajaxSetup({}, i), g = p.context || p,
                m = p.context && (g.nodeType || g.jquery) ? M(g) : M.event, v = M.Deferred(),
                y = M.Callbacks("once memory"), x = p.statusCode || {}, b = {}, A = {}, w = "canceled", k = {
                    readyState: 0, getResponseHeader: function (t) {
                        var e;
                        if (c) {
                            if (!s) for (s = {}; e = ze.exec(a);) s[e[1].toLowerCase() + " "] = (s[e[1].toLowerCase() + " "] || []).concat(e[2]);
                            e = s[t.toLowerCase() + " "]
                        }
                        return null == e ? null : e.join(", ")
                    }, getAllResponseHeaders: function () {
                        return c ? a : null
                    }, setRequestHeader: function (t, e) {
                        return null == c && (t = A[t.toLowerCase()] = A[t.toLowerCase()] || t, b[t] = e), this
                    }, overrideMimeType: function (t) {
                        return null == c && (p.mimeType = t), this
                    }, statusCode: function (t) {
                        var e;
                        if (t) if (c) k.always(t[k.status]); else for (e in t) x[e] = [x[e], t[e]];
                        return this
                    }, abort: function (t) {
                        var e = t || w;
                        return r && r.abort(e), S(0, e), this
                    }
                };
            if (v.promise(k), p.url = ((e || p.url || ke.href) + "").replace(Re, ke.protocol + "//"), p.type = i.method || i.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(I) || [""], null == p.crossDomain) {
                h = n.createElement("a");
                try {
                    h.href = p.url, h.href = h.href, p.crossDomain = He.protocol + "//" + He.host != h.protocol + "//" + h.host
                } catch (e) {
                    p.crossDomain = !0
                }
            }
            if (p.data && p.processData && "string" != typeof p.data && (p.data = M.param(p.data, p.traditional)), Ge(Be, p, i, k), c) return k;
            for (d in (u = M.event && p.global) && 0 == M.active++ && M.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Ie.test(p.type), o = p.url.replace(Le, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Oe, "+")) : (f = p.url.slice(o.length), p.data && (p.processData || "string" == typeof p.data) && (o += (Te.test(o) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (o = o.replace(Ne, "$1"), f = (Te.test(o) ? "&" : "?") + "_=" + Se++ + f), p.url = o + f), p.ifModified && (M.lastModified[o] && k.setRequestHeader("If-Modified-Since", M.lastModified[o]), M.etag[o] && k.setRequestHeader("If-None-Match", M.etag[o])), (p.data && p.hasContent && !1 !== p.contentType || i.contentType) && k.setRequestHeader("Content-Type", p.contentType), k.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + We + "; q=0.01" : "") : p.accepts["*"]), p.headers) k.setRequestHeader(d, p.headers[d]);
            if (p.beforeSend && (!1 === p.beforeSend.call(g, k, p) || c)) return k.abort();
            if (w = "abort", y.add(p.complete), k.done(p.success), k.fail(p.error), r = Ge(je, p, i, k)) {
                if (k.readyState = 1, u && m.trigger("ajaxSend", [k, p]), c) return k;
                p.async && 0 < p.timeout && (l = t.setTimeout(function () {
                    k.abort("timeout")
                }, p.timeout));
                try {
                    c = !1, r.send(b, S)
                } catch (e) {
                    if (c) throw e;
                    S(-1, e)
                }
            } else S(-1, "No Transport");

            function S(e, i, n, s) {
                var h, d, f, b, A, w = i;
                c || (c = !0, l && t.clearTimeout(l), r = void 0, a = s || "", k.readyState = 0 < e ? 4 : 0, h = 200 <= e && e < 300 || 304 === e, n && (b = function (t, e, i) {
                    for (var n, r, o, a, s = t.contents, l = t.dataTypes; "*" === l[0];) l.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
                    if (n) for (r in s) if (s[r] && s[r].test(n)) {
                        l.unshift(r);
                        break
                    }
                    if (l[0] in i) o = l[0]; else {
                        for (r in i) {
                            if (!l[0] || t.converters[r + " " + l[0]]) {
                                o = r;
                                break
                            }
                            a || (a = r)
                        }
                        o = o || a
                    }
                    if (o) return o !== l[0] && l.unshift(o), i[o]
                }(p, k, n)), b = function (t, e, i, n) {
                    var r, o, a, s, l, h = {}, c = t.dataTypes.slice();
                    if (c[1]) for (a in t.converters) h[a.toLowerCase()] = t.converters[a];
                    for (o = c.shift(); o;) if (t.responseFields[o] && (i[t.responseFields[o]] = e), !l && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = o, o = c.shift()) if ("*" === o) o = l; else if ("*" !== l && l !== o) {
                        if (!(a = h[l + " " + o] || h["* " + o])) for (r in h) if ((s = r.split(" "))[1] === o && (a = h[l + " " + s[0]] || h["* " + s[0]])) {
                            !0 === a ? a = h[r] : !0 !== h[r] && (o = s[0], c.unshift(s[1]));
                            break
                        }
                        if (!0 !== a) if (a && t.throws) e = a(e); else try {
                            e = a(e)
                        } catch (t) {
                            return {state: "parsererror", error: a ? t : "No conversion from " + l + " to " + o}
                        }
                    }
                    return {state: "success", data: e}
                }(p, b, k, h), h ? (p.ifModified && ((A = k.getResponseHeader("Last-Modified")) && (M.lastModified[o] = A), (A = k.getResponseHeader("etag")) && (M.etag[o] = A)), 204 === e || "HEAD" === p.type ? w = "nocontent" : 304 === e ? w = "notmodified" : (w = b.state, d = b.data, h = !(f = b.error))) : (f = w, !e && w || (w = "error", e < 0 && (e = 0))), k.status = e, k.statusText = (i || w) + "", h ? v.resolveWith(g, [d, w, k]) : v.rejectWith(g, [k, w, f]), k.statusCode(x), x = void 0, u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [k, p, h ? d : f]), y.fireWith(g, [k, w]), u && (m.trigger("ajaxComplete", [k, p]), --M.active || M.event.trigger("ajaxStop")))
            }

            return k
        },
        getJSON: function (t, e, i) {
            return M.get(t, e, i, "json")
        },
        getScript: function (t, e) {
            return M.get(t, void 0, e, "script")
        }
    }), M.each(["get", "post"], function (t, e) {
        M[e] = function (t, i, n, r) {
            return g(i) && (r = r || n, n = i, i = void 0), M.ajax(M.extend({
                url: t,
                type: e,
                dataType: r,
                data: i,
                success: n
            }, M.isPlainObject(t) && t))
        }
    }), M._evalUrl = function (t, e) {
        return M.ajax({
            url: t,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function () {
                }
            },
            dataFilter: function (t) {
                M.globalEval(t, e)
            }
        })
    }, M.fn.extend({
        wrapAll: function (t) {
            var e;
            return this[0] && (g(t) && (t = t.call(this[0])), e = M(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function () {
                for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                return t
            }).append(this)), this
        }, wrapInner: function (t) {
            return g(t) ? this.each(function (e) {
                M(this).wrapInner(t.call(this, e))
            }) : this.each(function () {
                var e = M(this), i = e.contents();
                i.length ? i.wrapAll(t) : e.append(t)
            })
        }, wrap: function (t) {
            var e = g(t);
            return this.each(function (i) {
                M(this).wrapAll(e ? t.call(this, i) : t)
            })
        }, unwrap: function (t) {
            return this.parent(t).not("body").each(function () {
                M(this).replaceWith(this.childNodes)
            }), this
        }
    }), M.expr.pseudos.hidden = function (t) {
        return !M.expr.pseudos.visible(t)
    }, M.expr.pseudos.visible = function (t) {
        return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
    }, M.ajaxSettings.xhr = function () {
        try {
            return new t.XMLHttpRequest
        } catch (e) {
        }
    };
    var Xe = {0: 200, 1223: 204}, Ue = M.ajaxSettings.xhr();
    p.cors = !!Ue && "withCredentials" in Ue, p.ajax = Ue = !!Ue, M.ajaxTransport(function (e) {
        var i, n;
        if (p.cors || Ue && !e.crossDomain) return {
            send: function (r, o) {
                var a, s = e.xhr();
                if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (a in e.xhrFields) s[a] = e.xhrFields[a];
                for (a in e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) s.setRequestHeader(a, r[a]);
                i = function (t) {
                    return function () {
                        i && (i = n = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Xe[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {binary: s.response} : {text: s.responseText}, s.getAllResponseHeaders()))
                    }
                }, s.onload = i(), n = s.onerror = s.ontimeout = i("error"), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function () {
                    4 === s.readyState && t.setTimeout(function () {
                        i && n()
                    })
                }, i = i("abort");
                try {
                    s.send(e.hasContent && e.data || null)
                } catch (r) {
                    if (i) throw r
                }
            }, abort: function () {
                i && i()
            }
        }
    }), M.ajaxPrefilter(function (t) {
        t.crossDomain && (t.contents.script = !1)
    }), M.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /\b(?:java|ecma)script\b/},
        converters: {
            "text script": function (t) {
                return M.globalEval(t), t
            }
        }
    }), M.ajaxPrefilter("script", function (t) {
        void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
    }), M.ajaxTransport("script", function (t) {
        var e, i;
        if (t.crossDomain || t.scriptAttrs) return {
            send: function (r, o) {
                e = M("<script>").attr(t.scriptAttrs || {}).prop({
                    charset: t.scriptCharset,
                    src: t.url
                }).on("load error", i = function (t) {
                    e.remove(), i = null, t && o("error" === t.type ? 404 : 200, t.type)
                }), n.head.appendChild(e[0])
            }, abort: function () {
                i && i()
            }
        }
    });
    var qe, $e = [], Ve = /(=)\?(?=&|$)|\?\?/;
    M.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            var t = $e.pop() || M.expando + "_" + Se++;
            return this[t] = !0, t
        }
    }), M.ajaxPrefilter("json jsonp", function (e, i, n) {
        var r, o, a,
            s = !1 !== e.jsonp && (Ve.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ve.test(e.data) && "data");
        if (s || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = g(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(Ve, "$1" + r) : !1 !== e.jsonp && (e.url += (Te.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
            return a || M.error(r + " was not called"), a[0]
        }, e.dataTypes[0] = "json", o = t[r], t[r] = function () {
            a = arguments
        }, n.always(function () {
            void 0 === o ? M(t).removeProp(r) : t[r] = o, e[r] && (e.jsonpCallback = i.jsonpCallback, $e.push(r)), a && g(o) && o(a[0]), a = o = void 0
        }), "script"
    }), p.createHTMLDocument = ((qe = n.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === qe.childNodes.length), M.parseHTML = function (t, e, i) {
        return "string" != typeof t ? [] : ("boolean" == typeof e && (i = e, e = !1), e || (p.createHTMLDocument ? ((r = (e = n.implementation.createHTMLDocument("")).createElement("base")).href = n.location.href, e.head.appendChild(r)) : e = n), a = !i && [], (o = D.exec(t)) ? [e.createElement(o[1])] : (o = Mt([t], e, a), a && a.length && M(a).remove(), M.merge([], o.childNodes)));
        var r, o, a
    }, M.fn.load = function (t, e, i) {
        var n, r, o, a = this, s = t.indexOf(" ");
        return -1 < s && (n = ye(t.slice(s)), t = t.slice(0, s)), g(e) ? (i = e, e = void 0) : e && "object" == typeof e && (r = "POST"), 0 < a.length && M.ajax({
            url: t,
            type: r || "GET",
            dataType: "html",
            data: e
        }).done(function (t) {
            o = arguments, a.html(n ? M("<div>").append(M.parseHTML(t)).find(n) : t)
        }).always(i && function (t, e) {
            a.each(function () {
                i.apply(this, o || [t.responseText, e, t])
            })
        }), this
    }, M.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (t, e) {
        M.fn[e] = function (t) {
            return this.on(e, t)
        }
    }), M.expr.pseudos.animated = function (t) {
        return M.grep(M.timers, function (e) {
            return t === e.elem
        }).length
    }, M.offset = {
        setOffset: function (t, e, i) {
            var n, r, o, a, s, l, h = M.css(t, "position"), c = M(t), u = {};
            "static" === h && (t.style.position = "relative"), s = c.offset(), o = M.css(t, "top"), l = M.css(t, "left"), ("absolute" === h || "fixed" === h) && -1 < (o + l).indexOf("auto") ? (a = (n = c.position()).top, r = n.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), g(e) && (e = e.call(t, i, M.extend({}, s))), null != e.top && (u.top = e.top - s.top + a), null != e.left && (u.left = e.left - s.left + r), "using" in e ? e.using.call(t, u) : c.css(u)
        }
    }, M.fn.extend({
        offset: function (t) {
            if (arguments.length) return void 0 === t ? this : this.each(function (e) {
                M.offset.setOffset(this, t, e)
            });
            var e, i, n = this[0];
            return n ? n.getClientRects().length ? (e = n.getBoundingClientRect(), i = n.ownerDocument.defaultView, {
                top: e.top + i.pageYOffset,
                left: e.left + i.pageXOffset
            }) : {top: 0, left: 0} : void 0
        }, position: function () {
            if (this[0]) {
                var t, e, i, n = this[0], r = {top: 0, left: 0};
                if ("fixed" === M.css(n, "position")) e = n.getBoundingClientRect(); else {
                    for (e = this.offset(), i = n.ownerDocument, t = n.offsetParent || i.documentElement; t && (t === i.body || t === i.documentElement) && "static" === M.css(t, "position");) t = t.parentNode;
                    t && t !== n && 1 === t.nodeType && ((r = M(t).offset()).top += M.css(t, "borderTopWidth", !0), r.left += M.css(t, "borderLeftWidth", !0))
                }
                return {
                    top: e.top - r.top - M.css(n, "marginTop", !0),
                    left: e.left - r.left - M.css(n, "marginLeft", !0)
                }
            }
        }, offsetParent: function () {
            return this.map(function () {
                for (var t = this.offsetParent; t && "static" === M.css(t, "position");) t = t.offsetParent;
                return t || rt
            })
        }
    }), M.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (t, e) {
        var i = "pageYOffset" === e;
        M.fn[t] = function (n) {
            return G(this, function (t, n, r) {
                var o;
                if (m(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === r) return o ? o[e] : t[n];
                o ? o.scrollTo(i ? o.pageXOffset : r, i ? r : o.pageYOffset) : t[n] = r
            }, t, n, arguments.length)
        }
    }), M.each(["top", "left"], function (t, e) {
        M.cssHooks[e] = Ft(p.pixelPosition, function (t, i) {
            if (i) return i = Gt(t, e), Wt.test(i) ? M(t).position()[e] + "px" : i
        })
    }), M.each({Height: "height", Width: "width"}, function (t, e) {
        M.each({padding: "inner" + t, content: e, "": "outer" + t}, function (i, n) {
            M.fn[n] = function (r, o) {
                var a = arguments.length && (i || "boolean" != typeof r),
                    s = i || (!0 === r || !0 === o ? "margin" : "border");
                return G(this, function (e, i, r) {
                    var o;
                    return m(e) ? 0 === n.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === r ? M.css(e, i, s) : M.style(e, i, r, s)
                }, e, a ? r : void 0, a)
            }
        })
    }), M.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (t, e) {
        M.fn[e] = function (t, i) {
            return 0 < arguments.length ? this.on(e, null, t, i) : this.trigger(e)
        }
    }), M.fn.extend({
        hover: function (t, e) {
            return this.mouseenter(t).mouseleave(e || t)
        }
    }), M.fn.extend({
        bind: function (t, e, i) {
            return this.on(t, null, e, i)
        }, unbind: function (t, e) {
            return this.off(t, null, e)
        }, delegate: function (t, e, i, n) {
            return this.on(e, t, i, n)
        }, undelegate: function (t, e, i) {
            return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
        }
    }), M.proxy = function (t, e) {
        var i, n, r;
        if ("string" == typeof e && (i = t[e], e = t, t = i), g(t)) return n = o.call(arguments, 2), (r = function () {
            return t.apply(e || this, n.concat(o.call(arguments)))
        }).guid = t.guid = t.guid || M.guid++, r
    }, M.holdReady = function (t) {
        t ? M.readyWait++ : M.ready(!0)
    }, M.isArray = Array.isArray, M.parseJSON = JSON.parse, M.nodeName = C, M.isFunction = g, M.isWindow = m, M.camelCase = q, M.type = x, M.now = Date.now, M.isNumeric = function (t) {
        var e = M.type(t);
        return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
    }, "function" == typeof define && define.amd && define("jquery", [], function () {
        return M
    });
    var Ke = t.jQuery, Ze = t.$;
    return M.noConflict = function (e) {
        return t.$ === M && (t.$ = Ze), e && t.jQuery === M && (t.jQuery = Ke), M
    }, e || (t.jQuery = t.$ = M), M
}), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");
!function (t) {
    "use strict";
    var e = jQuery.fn.jquery.split(" ")[0].split(".");
    if (e[0] < 2 && e[1] < 9 || 1 == e[0] && 9 == e[1] && e[2] < 1 || e[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
}(), function (t) {
    "use strict";
    t.fn.emulateTransitionEnd = function (e) {
        var i = !1, n = this;
        t(this).one("bsTransitionEnd", function () {
            i = !0
        });
        return setTimeout(function () {
            i || t(n).trigger(t.support.transition.end)
        }, e), this
    }, t(function () {
        t.support.transition = function () {
            var t = document.createElement("bootstrap"), e = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            };
            for (var i in e) if (void 0 !== t.style[i]) return {end: e[i]};
            return !1
        }(), t.support.transition && (t.event.special.bsTransitionEnd = {
            bindType: t.support.transition.end,
            delegateType: t.support.transition.end,
            handle: function (e) {
                if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
            }
        })
    })
}(jQuery), function (t) {
    "use strict";
    var e = '[data-dismiss="alert"]', i = function (i) {
        t(i).on("click", e, this.close)
    };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 150, i.prototype.close = function (e) {
        function n() {
            a.detach().trigger("closed.bs.alert").remove()
        }

        var r = t(this), o = r.attr("data-target");
        o || (o = (o = r.attr("href")) && o.replace(/.*(?=#[^\s]*$)/, ""));
        var a = t("#" === o ? [] : o);
        e && e.preventDefault(), a.length || (a = r.closest(".alert")), a.trigger(e = t.Event("close.bs.alert")), e.isDefaultPrevented() || (a.removeClass("in"), t.support.transition && a.hasClass("fade") ? a.one("bsTransitionEnd", n).emulateTransitionEnd(i.TRANSITION_DURATION) : n())
    };
    var n = t.fn.alert;
    t.fn.alert = function (e) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.alert");
            r || n.data("bs.alert", r = new i(this)), "string" == typeof e && r[e].call(n)
        })
    }, t.fn.alert.Constructor = i, t.fn.alert.noConflict = function () {
        return t.fn.alert = n, this
    }, t(document).on("click.bs.alert.data-api", e, i.prototype.close)
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.button"), o = "object" == typeof e && e;
            r || n.data("bs.button", r = new i(this, o)), "toggle" == e ? r.toggle() : e && r.setState(e)
        })
    }

    var i = function (e, n) {
        this.$element = t(e), this.options = t.extend({}, i.DEFAULTS, n), this.isLoading = !1
    };
    i.VERSION = "3.3.7", i.DEFAULTS = {loadingText: "loading..."}, i.prototype.setState = function (e) {
        var i = "disabled", n = this.$element, r = n.is("input") ? "val" : "html", o = n.data();
        e += "Text", null == o.resetText && n.data("resetText", n[r]()), setTimeout(t.proxy(function () {
            n[r](null == o[e] ? this.options[e] : o[e]), "loadingText" == e ? (this.isLoading = !0, n.addClass(i).attr(i, i).prop(i, !0)) : this.isLoading && (this.isLoading = !1, n.removeClass(i).removeAttr(i).prop(i, !1))
        }, this), 0)
    }, i.prototype.toggle = function () {
        var t = !0, e = this.$element.closest('[data-toggle="buttons"]');
        if (e.length) {
            var i = this.$element.find("input");
            "radio" == i.prop("type") ? (i.prop("checked") && (t = !1), e.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == i.prop("type") && (i.prop("checked") !== this.$element.hasClass("active") && (t = !1), this.$element.toggleClass("active")), i.prop("checked", this.$element.hasClass("active")), t && i.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var n = t.fn.button;
    t.fn.button = e, t.fn.button.Constructor = i, t.fn.button.noConflict = function () {
        return t.fn.button = n, this
    }, t(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (i) {
        var n = t(i.target).closest(".btn");
        e.call(n, "toggle"), t(i.target).is('input[type="radio"], input[type="checkbox"]') || (i.preventDefault(), n.is("input,button") ? n.trigger("focus") : n.find("input:visible,button:visible").first().trigger("focus"))
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        t(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type))
    })
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.carousel"),
                o = t.extend({}, i.DEFAULTS, n.data(), "object" == typeof e && e),
                a = "string" == typeof e ? e : o.slide;
            r || n.data("bs.carousel", r = new i(this, o)), "number" == typeof e ? r.to(e) : a ? r[a]() : o.interval && r.pause().cycle()
        })
    }

    var i = function (e, i) {
        this.$element = t(e), this.$indicators = this.$element.find(".carousel-indicators"), this.options = i, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", t.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", t.proxy(this.pause, this)).on("mouseleave.bs.carousel", t.proxy(this.cycle, this))
    };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 600, i.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, i.prototype.keydown = function (t) {
        if (!/input|textarea/i.test(t.target.tagName)) {
            switch (t.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            t.preventDefault()
        }
    }, i.prototype.cycle = function (e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(t.proxy(this.next, this), this.options.interval)), this
    }, i.prototype.getItemIndex = function (t) {
        return this.$items = t.parent().children(".item"), this.$items.index(t || this.$active)
    }, i.prototype.getItemForDirection = function (t, e) {
        var i = this.getItemIndex(e);
        if (("prev" == t && 0 === i || "next" == t && i == this.$items.length - 1) && !this.options.wrap) return e;
        var n = (i + ("prev" == t ? -1 : 1)) % this.$items.length;
        return this.$items.eq(n)
    }, i.prototype.to = function (t) {
        var e = this, i = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(t > this.$items.length - 1 || t < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function () {
            e.to(t)
        }) : i == t ? this.pause().cycle() : this.slide(t > i ? "next" : "prev", this.$items.eq(t))
    }, i.prototype.pause = function (e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && t.support.transition && (this.$element.trigger(t.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
    }, i.prototype.next = function () {
        if (!this.sliding) return this.slide("next")
    }, i.prototype.prev = function () {
        if (!this.sliding) return this.slide("prev")
    }, i.prototype.slide = function (e, n) {
        var r = this.$element.find(".item.active"), o = n || this.getItemForDirection(e, r), a = this.interval,
            s = "next" == e ? "left" : "right", l = this;
        if (o.hasClass("active")) return this.sliding = !1;
        var h = o[0], c = t.Event("slide.bs.carousel", {relatedTarget: h, direction: s});
        if (this.$element.trigger(c), !c.isDefaultPrevented()) {
            if (this.sliding = !0, a && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var u = t(this.$indicators.children()[this.getItemIndex(o)]);
                u && u.addClass("active")
            }
            var d = t.Event("slid.bs.carousel", {relatedTarget: h, direction: s});
            return t.support.transition && this.$element.hasClass("slide") ? (o.addClass(e), o[0].offsetWidth, r.addClass(s), o.addClass(s), r.one("bsTransitionEnd", function () {
                o.removeClass([e, s].join(" ")).addClass("active"), r.removeClass(["active", s].join(" ")), l.sliding = !1, setTimeout(function () {
                    l.$element.trigger(d)
                }, 0)
            }).emulateTransitionEnd(i.TRANSITION_DURATION)) : (r.removeClass("active"), o.addClass("active"), this.sliding = !1, this.$element.trigger(d)), a && this.cycle(), this
        }
    };
    var n = t.fn.carousel;
    t.fn.carousel = e, t.fn.carousel.Constructor = i, t.fn.carousel.noConflict = function () {
        return t.fn.carousel = n, this
    };
    var r = function (i) {
        var n, r = t(this), o = t(r.attr("data-target") || (n = r.attr("href")) && n.replace(/.*(?=#[^\s]+$)/, ""));
        if (o.hasClass("carousel")) {
            var a = t.extend({}, o.data(), r.data()), s = r.attr("data-slide-to");
            s && (a.interval = !1), e.call(o, a), s && o.data("bs.carousel").to(s), i.preventDefault()
        }
    };
    t(document).on("click.bs.carousel.data-api", "[data-slide]", r).on("click.bs.carousel.data-api", "[data-slide-to]", r), t(window).on("load", function () {
        t('[data-ride="carousel"]').each(function () {
            var i = t(this);
            e.call(i, i.data())
        })
    })
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        var i, n = e.attr("data-target") || (i = e.attr("href")) && i.replace(/.*(?=#[^\s]+$)/, "");
        return t(n)
    }

    function i(e) {
        return this.each(function () {
            var i = t(this), r = i.data("bs.collapse"),
                o = t.extend({}, n.DEFAULTS, i.data(), "object" == typeof e && e);
            !r && o.toggle && /show|hide/.test(e) && (o.toggle = !1), r || i.data("bs.collapse", r = new n(this, o)), "string" == typeof e && r[e]()
        })
    }

    var n = function (e, i) {
        this.$element = t(e), this.options = t.extend({}, n.DEFAULTS, i), this.$trigger = t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
    };
    n.VERSION = "3.3.7", n.TRANSITION_DURATION = 350, n.DEFAULTS = {toggle: !0}, n.prototype.dimension = function () {
        return this.$element.hasClass("width") ? "width" : "height"
    }, n.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var e, r = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(r && r.length && (e = r.data("bs.collapse"), e && e.transitioning))) {
                var o = t.Event("show.bs.collapse");
                if (this.$element.trigger(o), !o.isDefaultPrevented()) {
                    r && r.length && (i.call(r, "hide"), e || r.data("bs.collapse", null));
                    var a = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[a](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var s = function () {
                        this.$element.removeClass("collapsing").addClass("collapse in")[a](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                    };
                    if (!t.support.transition) return s.call(this);
                    var l = t.camelCase(["scroll", a].join("-"));
                    this.$element.one("bsTransitionEnd", t.proxy(s, this)).emulateTransitionEnd(n.TRANSITION_DURATION)[a](this.$element[0][l])
                }
            }
        }
    }, n.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var e = t.Event("hide.bs.collapse");
            if (this.$element.trigger(e), !e.isDefaultPrevented()) {
                var i = this.dimension();
                this.$element[i](this.$element[i]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var r = function () {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return t.support.transition ? void this.$element[i](0).one("bsTransitionEnd", t.proxy(r, this)).emulateTransitionEnd(n.TRANSITION_DURATION) : r.call(this)
            }
        }
    }, n.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, n.prototype.getParent = function () {
        return t(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(t.proxy(function (i, n) {
            var r = t(n);
            this.addAriaAndCollapsedClass(e(r), r)
        }, this)).end()
    }, n.prototype.addAriaAndCollapsedClass = function (t, e) {
        var i = t.hasClass("in");
        t.attr("aria-expanded", i), e.toggleClass("collapsed", !i).attr("aria-expanded", i)
    };
    var r = t.fn.collapse;
    t.fn.collapse = i, t.fn.collapse.Constructor = n, t.fn.collapse.noConflict = function () {
        return t.fn.collapse = r, this
    }, t(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (n) {
        var r = t(this);
        r.attr("data-target") || n.preventDefault();
        var o = e(r), a = o.data("bs.collapse") ? "toggle" : r.data();
        i.call(o, a)
    })
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        var i = e.attr("data-target");
        i || (i = (i = e.attr("href")) && /#[A-Za-z]/.test(i) && i.replace(/.*(?=#[^\s]*$)/, ""));
        var n = i && t(i);
        return n && n.length ? n : e.parent()
    }

    function i(i) {
        i && 3 === i.which || (t(n).remove(), t(r).each(function () {
            var n = t(this), r = e(n), o = {relatedTarget: this};
            r.hasClass("open") && (i && "click" == i.type && /input|textarea/i.test(i.target.tagName) && t.contains(r[0], i.target) || (r.trigger(i = t.Event("hide.bs.dropdown", o)), i.isDefaultPrevented() || (n.attr("aria-expanded", "false"), r.removeClass("open").trigger(t.Event("hidden.bs.dropdown", o)))))
        }))
    }

    var n = ".dropdown-backdrop", r = '[data-toggle="dropdown"]', o = function (e) {
        t(e).on("click.bs.dropdown", this.toggle)
    };
    o.VERSION = "3.3.7", o.prototype.toggle = function (n) {
        var r = t(this);
        if (!r.is(".disabled, :disabled")) {
            var o = e(r), a = o.hasClass("open");
            if (i(), !a) {
                "ontouchstart" in document.documentElement && !o.closest(".navbar-nav").length && t(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(t(this)).on("click", i);
                var s = {relatedTarget: this};
                if (o.trigger(n = t.Event("show.bs.dropdown", s)), n.isDefaultPrevented()) return;
                r.trigger("focus").attr("aria-expanded", "true"), o.toggleClass("open").trigger(t.Event("shown.bs.dropdown", s))
            }
            return !1
        }
    }, o.prototype.keydown = function (i) {
        if (/(38|40|27|32)/.test(i.which) && !/input|textarea/i.test(i.target.tagName)) {
            var n = t(this);
            if (i.preventDefault(), i.stopPropagation(), !n.is(".disabled, :disabled")) {
                var o = e(n), a = o.hasClass("open");
                if (!a && 27 != i.which || a && 27 == i.which) return 27 == i.which && o.find(r).trigger("focus"), n.trigger("click");
                var s = o.find(".dropdown-menu li:not(.disabled):visible a");
                if (s.length) {
                    var l = s.index(i.target);
                    38 == i.which && l > 0 && l--, 40 == i.which && l < s.length - 1 && l++, ~l || (l = 0), s.eq(l).trigger("focus")
                }
            }
        }
    };
    var a = t.fn.dropdown;
    t.fn.dropdown = function (e) {
        return this.each(function () {
            var i = t(this), n = i.data("bs.dropdown");
            n || i.data("bs.dropdown", n = new o(this)), "string" == typeof e && n[e].call(i)
        })
    }, t.fn.dropdown.Constructor = o, t.fn.dropdown.noConflict = function () {
        return t.fn.dropdown = a, this
    }, t(document).on("click.bs.dropdown.data-api", i).on("click.bs.dropdown.data-api", ".dropdown form", function (t) {
        t.stopPropagation()
    }).on("click.bs.dropdown.data-api", r, o.prototype.toggle).on("keydown.bs.dropdown.data-api", r, o.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", o.prototype.keydown)
}(jQuery), function (t) {
    "use strict";

    function e(e, n) {
        return this.each(function () {
            var r = t(this), o = r.data("bs.modal"), a = t.extend({}, i.DEFAULTS, r.data(), "object" == typeof e && e);
            o || r.data("bs.modal", o = new i(this, a)), "string" == typeof e ? o[e](n) : a.show && o.show(n)
        })
    }

    var i = function (e, i) {
        this.options = i, this.$body = t(document.body), this.$element = t(e), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, t.proxy(function () {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 300, i.BACKDROP_TRANSITION_DURATION = 150, i.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, i.prototype.toggle = function (t) {
        return this.isShown ? this.hide() : this.show(t)
    }, i.prototype.show = function (e) {
        var n = this, r = t.Event("show.bs.modal", {relatedTarget: e});
        this.$element.trigger(r), this.isShown || r.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', t.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
            n.$element.one("mouseup.dismiss.bs.modal", function (e) {
                t(e.target).is(n.$element) && (n.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function () {
            var r = t.support.transition && n.$element.hasClass("fade");
            n.$element.parent().length || n.$element.appendTo(n.$body), n.$element.show().scrollTop(0), n.adjustDialog(), r && n.$element[0].offsetWidth, n.$element.addClass("in"), n.enforceFocus();
            var o = t.Event("shown.bs.modal", {relatedTarget: e});
            r ? n.$dialog.one("bsTransitionEnd", function () {
                n.$element.trigger("focus").trigger(o)
            }).emulateTransitionEnd(i.TRANSITION_DURATION) : n.$element.trigger("focus").trigger(o)
        }))
    }, i.prototype.hide = function (e) {
        e && e.preventDefault(), e = t.Event("hide.bs.modal"), this.$element.trigger(e), this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), t(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), t.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", t.proxy(this.hideModal, this)).emulateTransitionEnd(i.TRANSITION_DURATION) : this.hideModal())
    }, i.prototype.enforceFocus = function () {
        t(document).off("focusin.bs.modal").on("focusin.bs.modal", t.proxy(function (t) {
            document === t.target || this.$element[0] === t.target || this.$element.has(t.target).length || this.$element.trigger("focus")
        }, this))
    }, i.prototype.escape = function () {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", t.proxy(function (t) {
            27 == t.which && this.hide()
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, i.prototype.resize = function () {
        this.isShown ? t(window).on("resize.bs.modal", t.proxy(this.handleUpdate, this)) : t(window).off("resize.bs.modal")
    }, i.prototype.hideModal = function () {
        var t = this;
        this.$element.hide(), this.backdrop(function () {
            t.$body.removeClass("modal-open"), t.resetAdjustments(), t.resetScrollbar(), t.$element.trigger("hidden.bs.modal")
        })
    }, i.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, i.prototype.backdrop = function (e) {
        var n = this, r = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var o = t.support.transition && r;
            if (this.$backdrop = t(document.createElement("div")).addClass("modal-backdrop " + r).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", t.proxy(function (t) {
                return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (t.target === t.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
            }, this)), o && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !e) return;
            o ? this.$backdrop.one("bsTransitionEnd", e).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : e()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var a = function () {
                n.removeBackdrop(), e && e()
            };
            t.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", a).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : a()
        } else e && e()
    }, i.prototype.handleUpdate = function () {
        this.adjustDialog()
    }, i.prototype.adjustDialog = function () {
        var t = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && t ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !t ? this.scrollbarWidth : ""
        })
    }, i.prototype.resetAdjustments = function () {
        this.$element.css({paddingLeft: "", paddingRight: ""})
    }, i.prototype.checkScrollbar = function () {
        var t = window.innerWidth;
        if (!t) {
            var e = document.documentElement.getBoundingClientRect();
            t = e.right - Math.abs(e.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < t, this.scrollbarWidth = this.measureScrollbar()
    }, i.prototype.setScrollbar = function () {
        var t = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", t + this.scrollbarWidth)
    }, i.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }, i.prototype.measureScrollbar = function () {
        var t = document.createElement("div");
        t.className = "modal-scrollbar-measure", this.$body.append(t);
        var e = t.offsetWidth - t.clientWidth;
        return this.$body[0].removeChild(t), e
    };
    var n = t.fn.modal;
    t.fn.modal = e, t.fn.modal.Constructor = i, t.fn.modal.noConflict = function () {
        return t.fn.modal = n, this
    }, t(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (i) {
        var n = t(this), r = n.attr("href"), o = t(n.attr("data-target") || r && r.replace(/.*(?=#[^\s]+$)/, "")),
            a = o.data("bs.modal") ? "toggle" : t.extend({remote: !/#/.test(r) && r}, o.data(), n.data());
        n.is("a") && i.preventDefault(), o.one("show.bs.modal", function (t) {
            t.isDefaultPrevented() || o.one("hidden.bs.modal", function () {
                n.is(":visible") && n.trigger("focus")
            })
        }), e.call(o, a, this)
    })
}(jQuery), function (t) {
    "use strict";
    var e = function (t, e) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", t, e)
    };
    e.VERSION = "3.3.7", e.TRANSITION_DURATION = 150, e.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {selector: "body", padding: 0}
    }, e.prototype.init = function (e, i, n) {
        if (this.enabled = !0, this.type = e, this.$element = t(i), this.options = this.getOptions(n), this.$viewport = this.options.viewport && t(t.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var r = this.options.trigger.split(" "), o = r.length; o--;) {
            var a = r[o];
            if ("click" == a) this.$element.on("click." + this.type, this.options.selector, t.proxy(this.toggle, this)); else if ("manual" != a) {
                var s = "hover" == a ? "mouseenter" : "focusin", l = "hover" == a ? "mouseleave" : "focusout";
                this.$element.on(s + "." + this.type, this.options.selector, t.proxy(this.enter, this)), this.$element.on(l + "." + this.type, this.options.selector, t.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = t.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }, e.prototype.getDefaults = function () {
        return e.DEFAULTS
    }, e.prototype.getOptions = function (e) {
        return (e = t.extend({}, this.getDefaults(), this.$element.data(), e)).delay && "number" == typeof e.delay && (e.delay = {
            show: e.delay,
            hide: e.delay
        }), e
    }, e.prototype.getDelegateOptions = function () {
        var e = {}, i = this.getDefaults();
        return this._options && t.each(this._options, function (t, n) {
            i[t] != n && (e[t] = n)
        }), e
    }, e.prototype.enter = function (e) {
        var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type);
        return i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusin" == e.type ? "focus" : "hover"] = !0), i.tip().hasClass("in") || "in" == i.hoverState ? void (i.hoverState = "in") : (clearTimeout(i.timeout), i.hoverState = "in", i.options.delay && i.options.delay.show ? void (i.timeout = setTimeout(function () {
            "in" == i.hoverState && i.show()
        }, i.options.delay.show)) : i.show())
    }, e.prototype.isInStateTrue = function () {
        for (var t in this.inState) if (this.inState[t]) return !0;
        return !1
    }, e.prototype.leave = function (e) {
        var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type);
        if (i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusout" == e.type ? "focus" : "hover"] = !1), !i.isInStateTrue()) return clearTimeout(i.timeout), i.hoverState = "out", i.options.delay && i.options.delay.hide ? void (i.timeout = setTimeout(function () {
            "out" == i.hoverState && i.hide()
        }, i.options.delay.hide)) : i.hide()
    }, e.prototype.show = function () {
        var i = t.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(i);
            var n = t.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (i.isDefaultPrevented() || !n) return;
            var r = this, o = this.tip(), a = this.getUID(this.type);
            this.setContent(), o.attr("id", a), this.$element.attr("aria-describedby", a), this.options.animation && o.addClass("fade");
            var s = "function" == typeof this.options.placement ? this.options.placement.call(this, o[0], this.$element[0]) : this.options.placement,
                l = /\s?auto?\s?/i, h = l.test(s);
            h && (s = s.replace(l, "") || "top"), o.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(s).data("bs." + this.type, this), this.options.container ? o.appendTo(this.options.container) : o.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var c = this.getPosition(), u = o[0].offsetWidth, d = o[0].offsetHeight;
            if (h) {
                var f = s, p = this.getPosition(this.$viewport);
                s = "bottom" == s && c.bottom + d > p.bottom ? "top" : "top" == s && c.top - d < p.top ? "bottom" : "right" == s && c.right + u > p.width ? "left" : "left" == s && c.left - u < p.left ? "right" : s, o.removeClass(f).addClass(s)
            }
            var g = this.getCalculatedOffset(s, c, u, d);
            this.applyPlacement(g, s);
            var m = function () {
                var t = r.hoverState;
                r.$element.trigger("shown.bs." + r.type), r.hoverState = null, "out" == t && r.leave(r)
            };
            t.support.transition && this.$tip.hasClass("fade") ? o.one("bsTransitionEnd", m).emulateTransitionEnd(e.TRANSITION_DURATION) : m()
        }
    }, e.prototype.applyPlacement = function (e, i) {
        var n = this.tip(), r = n[0].offsetWidth, o = n[0].offsetHeight, a = parseInt(n.css("margin-top"), 10),
            s = parseInt(n.css("margin-left"), 10);
        isNaN(a) && (a = 0), isNaN(s) && (s = 0), e.top += a, e.left += s, t.offset.setOffset(n[0], t.extend({
            using: function (t) {
                n.css({top: Math.round(t.top), left: Math.round(t.left)})
            }
        }, e), 0), n.addClass("in");
        var l = n[0].offsetWidth, h = n[0].offsetHeight;
        "top" == i && h != o && (e.top = e.top + o - h);
        var c = this.getViewportAdjustedDelta(i, e, l, h);
        c.left ? e.left += c.left : e.top += c.top;
        var u = /top|bottom/.test(i), d = u ? 2 * c.left - r + l : 2 * c.top - o + h,
            f = u ? "offsetWidth" : "offsetHeight";
        n.offset(e), this.replaceArrow(d, n[0][f], u)
    }, e.prototype.replaceArrow = function (t, e, i) {
        this.arrow().css(i ? "left" : "top", 50 * (1 - t / e) + "%").css(i ? "top" : "left", "")
    }, e.prototype.setContent = function () {
        var t = this.tip(), e = this.getTitle();
        t.find(".tooltip-inner")[this.options.html ? "html" : "text"](e), t.removeClass("fade in top bottom left right")
    }, e.prototype.hide = function (i) {
        function n() {
            "in" != r.hoverState && o.detach(), r.$element && r.$element.removeAttr("aria-describedby").trigger("hidden.bs." + r.type), i && i()
        }

        var r = this, o = t(this.$tip), a = t.Event("hide.bs." + this.type);
        if (this.$element.trigger(a), !a.isDefaultPrevented()) return o.removeClass("in"), t.support.transition && o.hasClass("fade") ? o.one("bsTransitionEnd", n).emulateTransitionEnd(e.TRANSITION_DURATION) : n(), this.hoverState = null, this
    }, e.prototype.fixTitle = function () {
        var t = this.$element;
        (t.attr("title") || "string" != typeof t.attr("data-original-title")) && t.attr("data-original-title", t.attr("title") || "").attr("title", "")
    }, e.prototype.hasContent = function () {
        return this.getTitle()
    }, e.prototype.getPosition = function (e) {
        var i = (e = e || this.$element)[0], n = "BODY" == i.tagName, r = i.getBoundingClientRect();
        null == r.width && (r = t.extend({}, r, {width: r.right - r.left, height: r.bottom - r.top}));
        var o = window.SVGElement && i instanceof window.SVGElement, a = n ? {top: 0, left: 0} : o ? null : e.offset(),
            s = {scroll: n ? document.documentElement.scrollTop || document.body.scrollTop : e.scrollTop()},
            l = n ? {width: t(window).width(), height: t(window).height()} : null;
        return t.extend({}, r, s, l, a)
    }, e.prototype.getCalculatedOffset = function (t, e, i, n) {
        return "bottom" == t ? {
            top: e.top + e.height,
            left: e.left + e.width / 2 - i / 2
        } : "top" == t ? {
            top: e.top - n,
            left: e.left + e.width / 2 - i / 2
        } : "left" == t ? {top: e.top + e.height / 2 - n / 2, left: e.left - i} : {
            top: e.top + e.height / 2 - n / 2,
            left: e.left + e.width
        }
    }, e.prototype.getViewportAdjustedDelta = function (t, e, i, n) {
        var r = {top: 0, left: 0};
        if (!this.$viewport) return r;
        var o = this.options.viewport && this.options.viewport.padding || 0, a = this.getPosition(this.$viewport);
        if (/right|left/.test(t)) {
            var s = e.top - o - a.scroll, l = e.top + o - a.scroll + n;
            s < a.top ? r.top = a.top - s : l > a.top + a.height && (r.top = a.top + a.height - l)
        } else {
            var h = e.left - o, c = e.left + o + i;
            h < a.left ? r.left = a.left - h : c > a.right && (r.left = a.left + a.width - c)
        }
        return r
    }, e.prototype.getTitle = function () {
        var t = this.$element, e = this.options;
        return t.attr("data-original-title") || ("function" == typeof e.title ? e.title.call(t[0]) : e.title)
    }, e.prototype.getUID = function (t) {
        do {
            t += ~~(1e6 * Math.random())
        } while (document.getElementById(t));
        return t
    }, e.prototype.tip = function () {
        if (!this.$tip && (this.$tip = t(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }, e.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }, e.prototype.enable = function () {
        this.enabled = !0
    }, e.prototype.disable = function () {
        this.enabled = !1
    }, e.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }, e.prototype.toggle = function (e) {
        var i = this;
        e && ((i = t(e.currentTarget).data("bs." + this.type)) || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i))), e ? (i.inState.click = !i.inState.click, i.isInStateTrue() ? i.enter(i) : i.leave(i)) : i.tip().hasClass("in") ? i.leave(i) : i.enter(i)
    }, e.prototype.destroy = function () {
        var t = this;
        clearTimeout(this.timeout), this.hide(function () {
            t.$element.off("." + t.type).removeData("bs." + t.type), t.$tip && t.$tip.detach(), t.$tip = null, t.$arrow = null, t.$viewport = null, t.$element = null
        })
    };
    var i = t.fn.tooltip;
    t.fn.tooltip = function (i) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.tooltip"), o = "object" == typeof i && i;
            !r && /destroy|hide/.test(i) || (r || n.data("bs.tooltip", r = new e(this, o)), "string" == typeof i && r[i]())
        })
    }, t.fn.tooltip.Constructor = e, t.fn.tooltip.noConflict = function () {
        return t.fn.tooltip = i, this
    }
}(jQuery), function (t) {
    "use strict";
    var e = function (t, e) {
        this.init("popover", t, e)
    };
    if (!t.fn.tooltip) throw new Error("Popover requires tooltip.js");
    e.VERSION = "3.3.7", e.DEFAULTS = t.extend({}, t.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), e.prototype = t.extend({}, t.fn.tooltip.Constructor.prototype), e.prototype.constructor = e, e.prototype.getDefaults = function () {
        return e.DEFAULTS
    }, e.prototype.setContent = function () {
        var t = this.tip(), e = this.getTitle(), i = this.getContent();
        t.find(".popover-title")[this.options.html ? "html" : "text"](e), t.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof i ? "html" : "append" : "text"](i), t.removeClass("fade top bottom left right in"), t.find(".popover-title").html() || t.find(".popover-title").hide()
    }, e.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }, e.prototype.getContent = function () {
        var t = this.$element, e = this.options;
        return t.attr("data-content") || ("function" == typeof e.content ? e.content.call(t[0]) : e.content)
    }, e.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var i = t.fn.popover;
    t.fn.popover = function (i) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.popover"), o = "object" == typeof i && i;
            !r && /destroy|hide/.test(i) || (r || n.data("bs.popover", r = new e(this, o)), "string" == typeof i && r[i]())
        })
    }, t.fn.popover.Constructor = e, t.fn.popover.noConflict = function () {
        return t.fn.popover = i, this
    }
}(jQuery), function (t) {
    "use strict";

    function e(i, n) {
        this.$body = t(document.body), this.$scrollElement = t(t(i).is(document.body) ? window : i), this.options = t.extend({}, e.DEFAULTS, n), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", t.proxy(this.process, this)), this.refresh(), this.process()
    }

    function i(i) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.scrollspy"), o = "object" == typeof i && i;
            r || n.data("bs.scrollspy", r = new e(this, o)), "string" == typeof i && r[i]()
        })
    }

    e.VERSION = "3.3.7", e.DEFAULTS = {offset: 10}, e.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }, e.prototype.refresh = function () {
        var e = this, i = "offset", n = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), t.isWindow(this.$scrollElement[0]) || (i = "position", n = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
            var e = t(this), r = e.data("target") || e.attr("href"), o = /^#./.test(r) && t(r);
            return o && o.length && o.is(":visible") && [[o[i]().top + n, r]] || null
        }).sort(function (t, e) {
            return t[0] - e[0]
        }).each(function () {
            e.offsets.push(this[0]), e.targets.push(this[1])
        })
    }, e.prototype.process = function () {
        var t, e = this.$scrollElement.scrollTop() + this.options.offset, i = this.getScrollHeight(),
            n = this.options.offset + i - this.$scrollElement.height(), r = this.offsets, o = this.targets,
            a = this.activeTarget;
        if (this.scrollHeight != i && this.refresh(), e >= n) return a != (t = o[o.length - 1]) && this.activate(t);
        if (a && e < r[0]) return this.activeTarget = null, this.clear();
        for (t = r.length; t--;) a != o[t] && e >= r[t] && (void 0 === r[t + 1] || e < r[t + 1]) && this.activate(o[t])
    }, e.prototype.activate = function (e) {
        this.activeTarget = e, this.clear();
        var i = this.selector + '[data-target="' + e + '"],' + this.selector + '[href="' + e + '"]',
            n = t(i).parents("li").addClass("active");
        n.parent(".dropdown-menu").length && (n = n.closest("li.dropdown").addClass("active")), n.trigger("activate.bs.scrollspy")
    }, e.prototype.clear = function () {
        t(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var n = t.fn.scrollspy;
    t.fn.scrollspy = i, t.fn.scrollspy.Constructor = e, t.fn.scrollspy.noConflict = function () {
        return t.fn.scrollspy = n, this
    }, t(window).on("load.bs.scrollspy.data-api", function () {
        t('[data-spy="scroll"]').each(function () {
            var e = t(this);
            i.call(e, e.data())
        })
    })
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.tab");
            r || n.data("bs.tab", r = new i(this)), "string" == typeof e && r[e]()
        })
    }

    var i = function (e) {
        this.element = t(e)
    };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 150, i.prototype.show = function () {
        var e = this.element, i = e.closest("ul:not(.dropdown-menu)"), n = e.data("target");
        if (n || (n = (n = e.attr("href")) && n.replace(/.*(?=#[^\s]*$)/, "")), !e.parent("li").hasClass("active")) {
            var r = i.find(".active:last a"), o = t.Event("hide.bs.tab", {relatedTarget: e[0]}),
                a = t.Event("show.bs.tab", {relatedTarget: r[0]});
            if (r.trigger(o), e.trigger(a), !a.isDefaultPrevented() && !o.isDefaultPrevented()) {
                var s = t(n);
                this.activate(e.closest("li"), i), this.activate(s, s.parent(), function () {
                    r.trigger({type: "hidden.bs.tab", relatedTarget: e[0]}), e.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: r[0]
                    })
                })
            }
        }
    }, i.prototype.activate = function (e, n, r) {
        function o() {
            a.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), e.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), s ? (e[0].offsetWidth, e.addClass("in")) : e.removeClass("fade"), e.parent(".dropdown-menu").length && e.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), r && r()
        }

        var a = n.find("> .active"),
            s = r && t.support.transition && (a.length && a.hasClass("fade") || !!n.find("> .fade").length);
        a.length && s ? a.one("bsTransitionEnd", o).emulateTransitionEnd(i.TRANSITION_DURATION) : o(), a.removeClass("in")
    };
    var n = t.fn.tab;
    t.fn.tab = e, t.fn.tab.Constructor = i, t.fn.tab.noConflict = function () {
        return t.fn.tab = n, this
    };
    var r = function (i) {
        i.preventDefault(), e.call(t(this), "show")
    };
    t(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', r).on("click.bs.tab.data-api", '[data-toggle="pill"]', r)
}(jQuery), function (t) {
    "use strict";

    function e(e) {
        return this.each(function () {
            var n = t(this), r = n.data("bs.affix"), o = "object" == typeof e && e;
            r || n.data("bs.affix", r = new i(this, o)), "string" == typeof e && r[e]()
        })
    }

    var i = function (e, n) {
        this.options = t.extend({}, i.DEFAULTS, n), this.$target = t(this.options.target).on("scroll.bs.affix.data-api", t.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", t.proxy(this.checkPositionWithEventLoop, this)), this.$element = t(e), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
    };
    i.VERSION = "3.3.7", i.RESET = "affix affix-top affix-bottom", i.DEFAULTS = {
        offset: 0,
        target: window
    }, i.prototype.getState = function (t, e, i, n) {
        var r = this.$target.scrollTop(), o = this.$element.offset(), a = this.$target.height();
        if (null != i && "top" == this.affixed) return r < i && "top";
        if ("bottom" == this.affixed) return null != i ? !(r + this.unpin <= o.top) && "bottom" : !(r + a <= t - n) && "bottom";
        var s = null == this.affixed, l = s ? r : o.top;
        return null != i && r <= i ? "top" : null != n && l + (s ? a : e) >= t - n && "bottom"
    }, i.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(i.RESET).addClass("affix");
        var t = this.$target.scrollTop(), e = this.$element.offset();
        return this.pinnedOffset = e.top - t
    }, i.prototype.checkPositionWithEventLoop = function () {
        setTimeout(t.proxy(this.checkPosition, this), 1)
    }, i.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
            var e = this.$element.height(), n = this.options.offset, r = n.top, o = n.bottom,
                a = Math.max(t(document).height(), t(document.body).height());
            "object" != typeof n && (o = r = n), "function" == typeof r && (r = n.top(this.$element)), "function" == typeof o && (o = n.bottom(this.$element));
            var s = this.getState(a, e, r, o);
            if (this.affixed != s) {
                null != this.unpin && this.$element.css("top", "");
                var l = "affix" + (s ? "-" + s : ""), h = t.Event(l + ".bs.affix");
                if (this.$element.trigger(h), h.isDefaultPrevented()) return;
                this.affixed = s, this.unpin = "bottom" == s ? this.getPinnedOffset() : null, this.$element.removeClass(i.RESET).addClass(l).trigger(l.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == s && this.$element.offset({top: a - e - o})
        }
    };
    var n = t.fn.affix;
    t.fn.affix = e, t.fn.affix.Constructor = i, t.fn.affix.noConflict = function () {
        return t.fn.affix = n, this
    }, t(window).on("load", function () {
        t('[data-spy="affix"]').each(function () {
            var i = t(this), n = i.data();
            n.offset = n.offset || {}, null != n.offsetBottom && (n.offset.bottom = n.offsetBottom), null != n.offsetTop && (n.offset.top = n.offsetTop), e.call(i, n)
        })
    })
}(jQuery), function (t, e) {
    "object" == typeof module && module.exports ? (e.default = e, module.exports = t.document ? e(t) : e) : "function" == typeof define && define.amd ? define("highcharts/highstock", function () {
        return e(t)
    }) : (t.Highcharts && t.Highcharts.error(16, !0), t.Highcharts = e(t))
}("undefined" != typeof window ? window : this, function (t) {
    function e(t, e, i, n) {
        t.hasOwnProperty(e) || (t[e] = n.apply(null, i))
    }

    var i = {};
    return e(i, "parts/Globals.js", [], function () {
        var e = void 0 !== t ? t : "undefined" != typeof window ? window : {}, i = e.document,
            n = e.navigator && e.navigator.userAgent || "",
            r = i && i.createElementNS && !!i.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
            o = /(edge|msie|trident)/i.test(n) && !e.opera, a = -1 !== n.indexOf("Firefox"),
            s = -1 !== n.indexOf("Chrome"), l = a && 4 > parseInt(n.split("Firefox/")[1], 10);
        return {
            product: "Highcharts",
            version: "7.2.0",
            deg2rad: 2 * Math.PI / 360,
            doc: i,
            hasBidiBug: l,
            hasTouch: !!e.TouchEvent,
            isMS: o,
            isWebKit: -1 !== n.indexOf("AppleWebKit"),
            isFirefox: a,
            isChrome: s,
            isSafari: !s && -1 !== n.indexOf("Safari"),
            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(n),
            SVG_NS: "http://www.w3.org/2000/svg",
            chartCount: 0,
            seriesTypes: {},
            symbolSizes: {},
            svg: r,
            win: e,
            marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
            noop: function () {
            },
            charts: [],
            dateFormats: {}
        }
    }), e(i, "parts/Utilities.js", [i["parts/Globals.js"]], function (t) {
        function e(t, e) {
            return parseInt(t, e || 10)
        }

        function i(t) {
            return "string" == typeof t
        }

        function n(t) {
            return "[object Array]" === (t = Object.prototype.toString.call(t)) || "[object Array Iterator]" === t
        }

        function r(t, e) {
            return !(!t || "object" != typeof t || e && n(t))
        }

        function o(t) {
            return r(t) && "number" == typeof t.nodeType
        }

        function a(t) {
            var e = t && t.constructor;
            return !(!r(t, !0) || o(t) || !e || !e.name || "Object" === e.name)
        }

        function s(t) {
            return "number" == typeof t && !isNaN(t) && 1 / 0 > t && -1 / 0 < t
        }

        function l(t) {
            return null != t
        }

        function h(t, e, n) {
            var r;
            return i(e) ? l(n) ? t.setAttribute(e, n) : t && t.getAttribute && ((r = t.getAttribute(e)) || "class" !== e || (r = t.getAttribute(e + "Name"))) : c(e, function (e, i) {
                t.setAttribute(i, e)
            }), r
        }

        function c(t, e, i) {
            for (var n in t) Object.hasOwnProperty.call(t, n) && e.call(i || t[n], t[n], n, t)
        }

        t.timers = [];
        var u, d, f = t.charts, p = t.doc, g = t.win;
        return t.error = function (e, i, n) {
            var r = s(e) ? "Highcharts error #" + e + ": www.highcharts.com/errors/" + e : e, o = function () {
                if (i) throw Error(r);
                g.console && console.log(r)
            };
            n ? t.fireEvent(n, "displayError", {code: e, message: r}, o) : o()
        }, t.Fx = function (t, e, i) {
            this.options = e, this.elem = t, this.prop = i
        }, t.Fx.prototype = {
            dSetter: function () {
                var t = this.paths[0], e = this.paths[1], i = [], n = this.now, r = t.length;
                if (1 === n) i = this.toD; else if (r === e.length && 1 > n) for (; r--;) {
                    var o = parseFloat(t[r]);
                    i[r] = isNaN(o) ? e[r] : n * parseFloat("" + (e[r] - o)) + o
                } else i = e;
                this.elem.attr("d", i, null, !0)
            }, update: function () {
                var t = this.elem, e = this.prop, i = this.now, n = this.options.step;
                this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, n && n.call(t, i, this)
            }, run: function (e, i, n) {
                var r = this, o = r.options, a = function (t) {
                    return !a.stopped && r.step(t)
                }, s = g.requestAnimationFrame || function (t) {
                    setTimeout(t, 13)
                }, l = function () {
                    for (var e = 0; e < t.timers.length; e++) t.timers[e]() || t.timers.splice(e--, 1);
                    t.timers.length && s(l)
                };
                e !== i || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = e, this.end = i, this.unit = n, this.now = this.start, this.pos = 0, a.elem = this.elem, a.prop = this.prop, a() && 1 === t.timers.push(a) && s(l)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem))
            }, step: function (t) {
                var e = +new Date, i = this.options, n = this.elem, r = i.complete, o = i.duration, a = i.curAnim;
                if (n.attr && !n.element) t = !1; else if (t || e >= o + this.startTime) {
                    this.now = this.end, this.pos = 1, this.update();
                    var s = a[this.prop] = !0;
                    c(a, function (t) {
                        !0 !== t && (s = !1)
                    }), s && r && r.call(n), t = !1
                } else this.pos = i.easing((e - this.startTime) / o), this.now = this.start + (this.end - this.start) * this.pos, this.update(), t = !0;
                return t
            }, initPath: function (t, e, i) {
                function n(t) {
                    for (l = t.length; l--;) {
                        var e = "M" === t[l] || "L" === t[l], i = /[a-zA-Z]/.test(t[l + 3]);
                        e && i && t.splice(l + 1, 0, t[l + 1], t[l + 2], t[l + 1], t[l + 2])
                    }
                }

                function r(t, e) {
                    for (; t.length < v;) {
                        t[0] = e[v - t.length];
                        var i = t.slice(0, d);
                        [].splice.apply(t, [0, 0].concat(i)), f && (i = t.slice(t.length - d), [].splice.apply(t, [t.length, 0].concat(i)), l--)
                    }
                    t[0] = "M"
                }

                function o(t, e) {
                    for (var i = (v - t.length) / d; 0 < i && i--;) (a = t.slice().splice(t.length / p - d, d * p))[0] = e[v - d - i * d], u && (a[d - 6] = a[d - 2], a[d - 5] = a[d - 1]), [].splice.apply(t, [t.length / p, 0].concat(a)), f && i--
                }

                e = e || "";
                var a, l, h = t.startX, c = t.endX, u = -1 < e.indexOf("C"), d = u ? 7 : 3;
                e = e.split(" "), i = i.slice();
                var f = t.isArea, p = f ? 2 : 1;
                if (u && (n(e), n(i)), h && c) {
                    for (l = 0; l < h.length; l++) {
                        if (h[l] === c[0]) {
                            var g = l;
                            break
                        }
                        if (h[0] === c[c.length - h.length + l]) {
                            g = l;
                            var m = !0;
                            break
                        }
                        if (h[h.length - 1] === c[c.length - h.length + l]) {
                            g = h.length - l;
                            break
                        }
                    }
                    void 0 === g && (e = [])
                }
                if (e.length && s(g)) {
                    var v = i.length + g * p * d;
                    m ? (r(e, i), o(i, e)) : (r(i, e), o(e, i))
                }
                return [e, i]
            }, fillSetter: function () {
                t.Fx.prototype.strokeSetter.apply(this, arguments)
            }, strokeSetter: function () {
                this.elem.attr(this.prop, t.color(this.start).tweenTo(t.color(this.end), this.pos), null, !0)
            }
        }, t.merge = function () {
            var t, e = arguments, i = {}, n = function (t, e) {
                return "object" != typeof t && (t = {}), c(e, function (i, s) {
                    !r(i, !0) || a(i) || o(i) ? t[s] = e[s] : t[s] = n(t[s] || {}, i)
                }), t
            };
            !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));
            var s = e.length;
            for (t = 0; t < s; t++) i = n(i, e[t]);
            return i
        }, t.syncTimeout = function (t, e, i) {
            if (e) return setTimeout(t, e, i);
            t.call(0, i)
        }, t.clearTimeout = function (t) {
            l(t) && clearTimeout(t)
        }, t.extend = function (t, e) {
            var i;
            for (i in t || (t = {}), e) t[i] = e[i];
            return t
        }, t.pick = function () {
            var t, e = arguments, i = e.length;
            for (t = 0; t < i; t++) {
                var n = e[t];
                if (null != n) return n
            }
        }, t.css = function (e, i) {
            t.isMS && !t.svg && i && void 0 !== i.opacity && (i.filter = "alpha(opacity=" + 100 * i.opacity + ")"), t.extend(e.style, i)
        }, t.createElement = function (e, i, n, r, o) {
            e = p.createElement(e);
            var a = t.css;
            return i && t.extend(e, i), o && a(e, {
                padding: "0",
                border: "none",
                margin: "0"
            }), n && a(e, n), r && r.appendChild(e), e
        }, t.extendClass = function (e, i) {
            var n = function () {
            };
            return n.prototype = new e, t.extend(n.prototype, i), n
        }, t.pad = function (t, e, i) {
            return Array((e || 2) + 1 - String(t).replace("-", "").length).join(i || "0") + t
        }, t.relativeLength = function (t, e, i) {
            return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t)
        }, t.wrap = function (t, e, i) {
            var n = t[e];
            t[e] = function () {
                var t = Array.prototype.slice.call(arguments), e = arguments, r = this;
                return r.proceed = function () {
                    n.apply(r, arguments.length ? arguments : e)
                }, t.unshift(n), t = i.apply(this, t), r.proceed = null, t
            }
        }, t.datePropsToTimestamps = function (e) {
            c(e, function (i, o) {
                r(i) && "function" == typeof i.getTime ? e[o] = i.getTime() : (r(i) || n(i)) && t.datePropsToTimestamps(i)
            })
        }, t.formatSingle = function (e, i, n) {
            var r = t.defaultOptions.lang;
            return /f$/.test(e) ? (n = (n = e.match(/\.([0-9])/)) ? n[1] : -1, null !== i && (i = t.numberFormat(i, n, r.decimalPoint, -1 < e.indexOf(",") ? r.thousandsSep : ""))) : i = (n || t.time).dateFormat(e, i), i
        }, t.format = function (e, i, n) {
            for (var r, o, a, s, l, h = "{", c = !1, u = []; e && -1 !== (h = e.indexOf(h));) {
                if (r = e.slice(0, h), c) {
                    for (s = (o = (r = r.split(":")).shift().split(".")).length, l = i, a = 0; a < s; a++) l && (l = l[o[a]]);
                    r.length && (l = t.formatSingle(r.join(":"), l, n)), u.push(l)
                } else u.push(r);
                e = e.slice(h + 1), h = (c = !c) ? "}" : "{"
            }
            return u.push(e), u.join("")
        }, t.getMagnitude = function (t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
        }, t.normalizeTickInterval = function (e, i, n, r, o) {
            var a = e, s = e / (n = t.pick(n, 1));
            for (i || (i = o ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === r && (1 === n ? i = i.filter(function (t) {
                return 0 == t % 1
            }) : .1 >= n && (i = [1 / n]))), r = 0; r < i.length && (a = i[r], !(o && a * n >= e || !o && s <= (i[r] + (i[r + 1] || i[r])) / 2)); r++) ;
            return t.correctFloat(a * n, -Math.round(Math.log(.001) / Math.LN10))
        }, t.stableSort = function (t, e) {
            var i, n, r = t.length;
            for (n = 0; n < r; n++) t[n].safeI = n;
            for (t.sort(function (t, n) {
                return 0 === (i = e(t, n)) ? t.safeI - n.safeI : i
            }), n = 0; n < r; n++) delete t[n].safeI
        }, t.arrayMin = function (t) {
            for (var e = t.length, i = t[0]; e--;) t[e] < i && (i = t[e]);
            return i
        }, t.arrayMax = function (t) {
            for (var e = t.length, i = t[0]; e--;) t[e] > i && (i = t[e]);
            return i
        }, t.destroyObjectProperties = function (t, e) {
            c(t, function (i, n) {
                i && i !== e && i.destroy && i.destroy(), delete t[n]
            })
        }, t.discardElement = function (e) {
            var i = t.garbageBin;
            i || (i = t.createElement("div")), e && i.appendChild(e), i.innerHTML = ""
        }, t.correctFloat = function (t, e) {
            return parseFloat(t.toPrecision(e || 14))
        }, t.setAnimation = function (e, i) {
            i.renderer.globalAnimation = t.pick(e, i.options.chart.animation, !0)
        }, t.animObject = function (e) {
            return r(e) ? t.merge(e) : {duration: e ? 500 : 0}
        }, t.timeUnits = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            week: 6048e5,
            month: 24192e5,
            year: 314496e5
        }, t.numberFormat = function (i, n, r, o) {
            i = +i || 0, n = +n;
            var a = t.defaultOptions.lang, l = (i.toString().split(".")[1] || "").split("e")[0].length,
                h = i.toString().split("e");
            if (-1 === n) n = Math.min(l, 20); else if (s(n)) {
                if (n && h[1] && 0 > h[1]) {
                    var c = n + +h[1];
                    0 <= c ? (h[0] = (+h[0]).toExponential(c).split("e")[0], n = c) : (h[0] = h[0].split(".")[0] || 0, i = 20 > n ? (h[0] * Math.pow(10, h[1])).toFixed(n) : 0, h[1] = 0)
                }
            } else n = 2;
            var u = (Math.abs(h[1] ? h[0] : i) + Math.pow(10, -Math.max(n, l) - 1)).toFixed(n);
            return c = 3 < (l = String(e(u))).length ? l.length % 3 : 0, r = t.pick(r, a.decimalPoint), o = t.pick(o, a.thousandsSep), i = (0 > i ? "-" : "") + (c ? l.substr(0, c) + o : ""), i += l.substr(c).replace(/(\d{3})(?=\d)/g, "$1" + o), n && (i += r + u.slice(-n)), h[1] && 0 != +i && (i += "e" + h[1]), i
        }, Math.easeInOutSine = function (t) {
            return -.5 * (Math.cos(Math.PI * t) - 1)
        }, t.getStyle = function (i, n, r) {
            return "width" === n ? (n = Math.min(i.offsetWidth, i.scrollWidth), (r = i.getBoundingClientRect && i.getBoundingClientRect().width) < n && r >= n - 1 && (n = Math.floor(r)), Math.max(0, n - t.getStyle(i, "padding-left") - t.getStyle(i, "padding-right"))) : "height" === n ? Math.max(0, Math.min(i.offsetHeight, i.scrollHeight) - t.getStyle(i, "padding-top") - t.getStyle(i, "padding-bottom")) : (g.getComputedStyle || t.error(27, !0), (i = g.getComputedStyle(i, void 0)) && (i = i.getPropertyValue(n), t.pick(r, "opacity" !== n) && (i = e(i))), i)
        }, t.inArray = function (t, e, i) {
            return e.indexOf(t, i)
        }, t.find = Array.prototype.find ? function (t, e) {
            return t.find(e)
        } : function (t, e) {
            var i, n = t.length;
            for (i = 0; i < n; i++) if (e(t[i], i)) return t[i]
        }, t.keys = Object.keys, t.offset = function (t) {
            var e = p.documentElement;
            return {
                top: (t = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {
                    top: 0,
                    left: 0
                }).top + (g.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                left: t.left + (g.pageXOffset || e.scrollLeft) - (e.clientLeft || 0)
            }
        }, t.stop = function (e, i) {
            for (var n = t.timers.length; n--;) t.timers[n].elem !== e || i && i !== t.timers[n].prop || (t.timers[n].stopped = !0)
        }, c({map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some"}, function (e, i) {
            t[i] = function (t) {
                return Array.prototype[e].apply(t, [].slice.call(arguments, 1))
            }
        }), t.addEvent = function (e, i, n, r) {
            void 0 === r && (r = {});
            var o = e.addEventListener || t.addEventListenerPolyfill,
                a = "function" == typeof e && e.prototype ? e.prototype.protoEvents = e.prototype.protoEvents || {} : e.hcEvents = e.hcEvents || {};
            return t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0), o && o.call(e, i, n, !1), a[i] || (a[i] = []), a[i].push({
                fn: n,
                order: "number" == typeof r.order ? r.order : 1 / 0
            }), a[i].sort(function (t, e) {
                return t.order - e.order
            }), function () {
                t.removeEvent(e, i, n)
            }
        }, t.removeEvent = function (e, i, n) {
            function r(i, n) {
                var r = e.removeEventListener || t.removeEventListenerPolyfill;
                r && r.call(e, i, n, !1)
            }

            function o(t) {
                var n;
                if (e.nodeName) {
                    if (i) {
                        var o = {};
                        o[i] = !0
                    } else o = t;
                    c(o, function (e, i) {
                        if (t[i]) for (n = t[i].length; n--;) r(i, t[i][n].fn)
                    })
                }
            }

            var a;
            ["protoEvents", "hcEvents"].forEach(function (t) {
                var s = e[t];
                s && (i ? (a = s[i] || [], n ? (s[i] = a.filter(function (t) {
                    return n !== t.fn
                }), r(i, n)) : (o(s), s[i] = [])) : (o(s), e[t] = {}))
            })
        }, t.fireEvent = function (e, i, n, r) {
            var o;
            if (n = n || {}, p.createEvent && (e.dispatchEvent || e.fireEvent)) {
                var a = p.createEvent("Events");
                a.initEvent(i, !0, !0), t.extend(a, n), e.dispatchEvent ? e.dispatchEvent(a) : e.fireEvent(i, a)
            } else n.target || t.extend(n, {
                preventDefault: function () {
                    n.defaultPrevented = !0
                }, target: e, type: i
            }), function (t, i) {
                void 0 === t && (t = []), void 0 === i && (i = []);
                var r = 0, a = 0, s = t.length + i.length;
                for (o = 0; o < s; o++) !1 === (t[r] ? i[a] ? t[r].order <= i[a].order ? t[r++] : i[a++] : t[r++] : i[a++]).fn.call(e, n) && n.preventDefault()
            }(e.protoEvents && e.protoEvents[i], e.hcEvents && e.hcEvents[i]);
            r && !n.defaultPrevented && r.call(e, n)
        }, t.animate = function (e, i, n) {
            var o, a, l, h = "";
            if (!r(n)) {
                var u = arguments;
                n = {duration: u[2], easing: u[3], complete: u[4]}
            }
            s(n.duration) || (n.duration = 400), n.easing = "function" == typeof n.easing ? n.easing : Math[n.easing] || Math.easeInOutSine, n.curAnim = t.merge(i), c(i, function (r, s) {
                t.stop(e, s), l = new t.Fx(e, n, s), a = null, "d" === s ? (l.paths = l.initPath(e, e.d, i.d), l.toD = i.d, o = 0, a = 1) : e.attr ? o = e.attr(s) : (o = parseFloat(t.getStyle(e, s)) || 0, "opacity" !== s && (h = "px")), a || (a = r), a && a.match && a.match("px") && (a = a.replace(/px/g, "")), l.run(o, a, h)
            })
        }, t.seriesType = function (e, i, n, r, o) {
            var a = t.getOptions(), s = t.seriesTypes;
            return a.plotOptions[e] = t.merge(a.plotOptions[i], n), s[e] = t.extendClass(s[i] || function () {
            }, r), s[e].prototype.type = e, o && (s[e].prototype.pointClass = t.extendClass(t.Point, o)), s[e]
        }, t.uniqueKey = (u = Math.random().toString(36).substring(2, 9), d = 0, function () {
            return "highcharts-" + u + "-" + d++
        }), t.isFunction = function (t) {
            return "function" == typeof t
        }, g.jQuery && (g.jQuery.fn.highcharts = function () {
            var e = [].slice.call(arguments);
            if (this[0]) return e[0] ? (new (t[i(e[0]) ? e.shift() : "Chart"])(this[0], e[0], e[1]), this) : f[h(this[0], "data-highcharts-chart")]
        }), {
            attr: h,
            defined: l,
            erase: function (t, e) {
                for (var i = t.length; i--;) if (t[i] === e) {
                    t.splice(i, 1);
                    break
                }
            },
            isArray: n,
            isClass: a,
            isDOMElement: o,
            isNumber: s,
            isObject: r,
            isString: i,
            objectEach: c,
            pInt: e,
            splat: function (t) {
                return n(t) ? t : [t]
            }
        }
    }), e(i, "parts/Color.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.isNumber, n = e.pInt, r = t.merge;
        t.Color = function (e) {
            if (!(this instanceof t.Color)) return new t.Color(e);
            this.init(e)
        }, t.Color.prototype = {
            parsers: [{
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function (t) {
                    return [n(t[1]), n(t[2]), n(t[3]), parseFloat(t[4], 10)]
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function (t) {
                    return [n(t[1]), n(t[2]), n(t[3]), 1]
                }
            }], names: {white: "#ffffff", black: "#000000"}, init: function (e) {
                var i, n;
                if ((this.input = e = this.names[e && e.toLowerCase ? e.toLowerCase() : ""] || e) && e.stops) this.stops = e.stops.map(function (e) {
                    return new t.Color(e[1])
                }); else {
                    if (e && e.charAt && "#" === e.charAt()) {
                        var r = e.length;
                        e = parseInt(e.substr(1), 16), 7 === r ? i = [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : 4 === r && (i = [(3840 & e) >> 4 | (3840 & e) >> 8, (240 & e) >> 4 | 240 & e, (15 & e) << 4 | 15 & e, 1])
                    }
                    if (!i) for (n = this.parsers.length; n-- && !i;) {
                        var o = this.parsers[n];
                        (r = o.regex.exec(e)) && (i = o.parse(r))
                    }
                }
                this.rgba = i || []
            }, get: function (t) {
                var e = this.input, n = this.rgba;
                if (this.stops) {
                    var o = r(e);
                    o.stops = [].concat(o.stops), this.stops.forEach(function (e, i) {
                        o.stops[i] = [o.stops[i][0], e.get(t)]
                    })
                } else o = n && i(n[0]) ? "rgb" === t || !t && 1 === n[3] ? "rgb(" + n[0] + "," + n[1] + "," + n[2] + ")" : "a" === t ? n[3] : "rgba(" + n.join(",") + ")" : e;
                return o
            }, brighten: function (t) {
                var e, r = this.rgba;
                if (this.stops) this.stops.forEach(function (e) {
                    e.brighten(t)
                }); else if (i(t) && 0 !== t) for (e = 0; 3 > e; e++) r[e] += n(255 * t), 0 > r[e] && (r[e] = 0), 255 < r[e] && (r[e] = 255);
                return this
            }, setOpacity: function (t) {
                return this.rgba[3] = t, this
            }, tweenTo: function (t, e) {
                var i = this.rgba, n = t.rgba;
                return n.length && i && i.length ? e = ((t = 1 !== n[3] || 1 !== i[3]) ? "rgba(" : "rgb(") + Math.round(n[0] + (i[0] - n[0]) * (1 - e)) + "," + Math.round(n[1] + (i[1] - n[1]) * (1 - e)) + "," + Math.round(n[2] + (i[2] - n[2]) * (1 - e)) + (t ? "," + (n[3] + (i[3] - n[3]) * (1 - e)) : "") + ")" : e = t.input || "none", e
            }
        }, t.color = function (e) {
            return new t.Color(e)
        }
    }), e(i, "parts/SvgRenderer.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.attr, n = e.defined, r = e.erase, o = e.isArray, a = e.isNumber, s = e.isObject, l = e.isString,
            h = e.objectEach, c = e.pInt, u = e.splat, d = t.addEvent, f = t.animate, p = t.charts, g = t.color,
            m = t.css, v = t.createElement, y = t.deg2rad, x = t.destroyObjectProperties, b = t.doc, M = t.extend,
            A = t.hasTouch, w = t.isFirefox, k = t.isMS, S = t.isWebKit, T = t.merge, E = t.noop, C = t.pick,
            D = t.removeEvent, P = t.stop, _ = t.svg, O = t.SVG_NS, L = t.symbolSizes, N = t.win,
            z = t.SVGElement = function () {
                return this
            };
        M(z.prototype, {
            opacity: 1,
            SVG_NS: O,
            textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
            init: function (e, i) {
                this.element = "span" === i ? v(i) : b.createElementNS(this.SVG_NS, i), this.renderer = e, t.fireEvent(this, "afterInit")
            },
            animate: function (e, i, n) {
                var r = t.animObject(C(i, this.renderer.globalAnimation, !0));
                return C(b.hidden, b.msHidden, b.webkitHidden, !1) && (r.duration = 0), 0 !== r.duration ? (n && (r.complete = n), f(this, e, r)) : (this.attr(e, void 0, n), h(e, function (t, e) {
                    r.step && r.step.call(this, t, {prop: e, pos: 1})
                }, this)), this
            },
            complexColor: function (e, i, r) {
                var a, s, l, c, u, d, f, p, g, m, v, y, x = this.renderer, b = [];
                t.fireEvent(this.renderer, "complexColor", {args: arguments}, function () {
                    e.radialGradient ? s = "radialGradient" : e.linearGradient && (s = "linearGradient"), s && (l = e[s], u = x.gradients, f = e.stops, m = r.radialReference, o(l) && (e[s] = l = {
                        x1: l[0],
                        y1: l[1],
                        x2: l[2],
                        y2: l[3],
                        gradientUnits: "userSpaceOnUse"
                    }), "radialGradient" === s && m && !n(l.gradientUnits) && (c = l, l = T(l, x.getRadialAttr(m, c), {gradientUnits: "userSpaceOnUse"})), h(l, function (t, e) {
                        "id" !== e && b.push(e, t)
                    }), h(f, function (t) {
                        b.push(t)
                    }), b = b.join(","), u[b] ? v = u[b].attr("id") : (l.id = v = t.uniqueKey(), u[b] = d = x.createElement(s).attr(l).add(x.defs), d.radAttr = c, d.stops = [], f.forEach(function (e) {
                        0 === e[1].indexOf("rgba") ? (a = t.color(e[1]), p = a.get("rgb"), g = a.get("a")) : (p = e[1], g = 1), e = x.createElement("stop").attr({
                            offset: e[0],
                            "stop-color": p,
                            "stop-opacity": g
                        }).add(d), d.stops.push(e)
                    })), y = "url(" + x.url + "#" + v + ")", r.setAttribute(i, y), r.gradient = b, e.toString = function () {
                        return y
                    })
                })
            },
            applyTextOutline: function (e) {
                var n, r = this.element;
                -1 !== e.indexOf("contrast") && (e = e.replace(/contrast/g, this.renderer.getContrast(r.style.fill)));
                var o = (e = e.split(" "))[e.length - 1];
                if ((n = e[0]) && "none" !== n && t.svg) {
                    this.fakeTS = !0, e = [].slice.call(r.getElementsByTagName("tspan")), this.ySetter = this.xSetter, n = n.replace(/(^[\d\.]+)(.*?)$/g, function (t, e, i) {
                        return 2 * e + i
                    }), this.removeTextOutline(e);
                    var a = r.firstChild;
                    e.forEach(function (t, e) {
                        0 === e && (t.setAttribute("x", r.getAttribute("x")), e = r.getAttribute("y"), t.setAttribute("y", e || 0), null === e && r.setAttribute("y", 0)), t = t.cloneNode(1), i(t, {
                            class: "highcharts-text-outline",
                            fill: o,
                            stroke: o,
                            "stroke-width": n,
                            "stroke-linejoin": "round"
                        }), r.insertBefore(t, a)
                    })
                }
            },
            removeTextOutline: function (t) {
                for (var e, i = t.length; i--;) "highcharts-text-outline" === (e = t[i]).getAttribute("class") && r(t, this.element.removeChild(e))
            },
            symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
            attr: function (e, i, n, r) {
                var o, a, s, l = this.element, c = this, u = this.symbolCustomAttribs;
                if ("string" == typeof e && void 0 !== i) {
                    var d = e;
                    (e = {})[d] = i
                }
                return "string" == typeof e ? c = (this[e + "Getter"] || this._defaultGetter).call(this, e, l) : (h(e, function (i, n) {
                    a = !1, r || P(this, n), this.symbolName && -1 !== t.inArray(n, u) && (o || (this.symbolAttr(e), o = !0), a = !0), !this.rotation || "x" !== n && "y" !== n || (this.doTransform = !0), a || ((s = this[n + "Setter"] || this._defaultSetter).call(this, i, n, l), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(n) && this.updateShadows(n, i, s))
                }, this), this.afterSetters()), n && n.call(this), c
            },
            afterSetters: function () {
                this.doTransform && (this.updateTransform(), this.doTransform = !1)
            },
            updateShadows: function (t, e, i) {
                for (var n = this.shadows, r = n.length; r--;) i.call(n[r], "height" === t ? Math.max(e - (n[r].cutHeight || 0), 0) : "d" === t ? this.d : e, t, n[r])
            },
            addClass: function (t, e) {
                var i = this.attr("class") || "";
                return e || (t = (t || "").split(/ /g).reduce(function (t, e) {
                    return -1 === i.indexOf(e) && t.push(e), t
                }, i ? [i] : []).join(" ")), t !== i && this.attr("class", t), this
            },
            hasClass: function (t) {
                return -1 !== (this.attr("class") || "").split(" ").indexOf(t)
            },
            removeClass: function (t) {
                return this.attr("class", (this.attr("class") || "").replace(t, ""))
            },
            symbolAttr: function (t) {
                var e = this;
                "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (i) {
                    e[i] = C(t[i], e[i])
                }), e.attr({d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)})
            },
            clip: function (t) {
                return this.attr("clip-path", t ? "url(" + this.renderer.url + "#" + t.id + ")" : "none")
            },
            crisp: function (t, e) {
                e = e || t.strokeWidth || 0;
                var i = Math.round(e) % 2 / 2;
                return t.x = Math.floor(t.x || this.x || 0) + i, t.y = Math.floor(t.y || this.y || 0) + i, t.width = Math.floor((t.width || this.width || 0) - 2 * i), t.height = Math.floor((t.height || this.height || 0) - 2 * i), n(t.strokeWidth) && (t.strokeWidth = e), t
            },
            css: function (t) {
                var e = this.styles, n = {}, r = this.element, o = "", a = !e,
                    s = ["textOutline", "textOverflow", "width"];
                if (t && t.color && (t.fill = t.color), e && h(t, function (t, i) {
                    t !== e[i] && (n[i] = t, a = !0)
                }), a) {
                    if (e && (t = M(e, n)), t) if (null === t.width || "auto" === t.width) delete this.textWidth; else if ("text" === r.nodeName.toLowerCase() && t.width) var l = this.textWidth = c(t.width);
                    if (this.styles = t, l && !_ && this.renderer.forExport && delete t.width, r.namespaceURI === this.SVG_NS) {
                        var u = function (t, e) {
                            return "-" + e.toLowerCase()
                        };
                        h(t, function (t, e) {
                            -1 === s.indexOf(e) && (o += e.replace(/([A-Z])/g, u) + ":" + t + ";")
                        }), o && i(r, "style", o)
                    } else m(r, t);
                    this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t && t.textOutline && this.applyTextOutline(t.textOutline))
                }
                return this
            },
            getStyle: function (t) {
                return N.getComputedStyle(this.element || this, "").getPropertyValue(t)
            },
            strokeWidth: function () {
                if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                var t = this.getStyle("stroke-width");
                if (t.indexOf("px") === t.length - 2) t = c(t); else {
                    var e = b.createElementNS(O, "rect");
                    i(e, {
                        width: t,
                        "stroke-width": 0
                    }), this.element.parentNode.appendChild(e), t = e.getBBox().width, e.parentNode.removeChild(e)
                }
                return t
            },
            on: function (t, e) {
                var i = this, n = i.element;
                return A && "click" === t ? (n.ontouchstart = function (t) {
                    i.touchEventFired = Date.now(), t.preventDefault(), e.call(n, t)
                }, n.onclick = function (t) {
                    (-1 === N.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (i.touchEventFired || 0)) && e.call(n, t)
                }) : n["on" + t] = e, this
            },
            setRadialReference: function (t) {
                var e = this.renderer.gradients[this.element.gradient];
                return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this
            },
            translate: function (t, e) {
                return this.attr({translateX: t, translateY: e})
            },
            invert: function (t) {
                return this.inverted = t, this.updateTransform(), this
            },
            updateTransform: function () {
                var t = this.translateX || 0, e = this.translateY || 0, i = this.scaleX, r = this.scaleY,
                    o = this.inverted, a = this.rotation, s = this.matrix, l = this.element;
                o && (t += this.width, e += this.height), t = ["translate(" + t + "," + e + ")"], n(s) && t.push("matrix(" + s.join(",") + ")"), o ? t.push("rotate(90) scale(-1,1)") : a && t.push("rotate(" + a + " " + C(this.rotationOriginX, l.getAttribute("x"), 0) + " " + C(this.rotationOriginY, l.getAttribute("y") || 0) + ")"), (n(i) || n(r)) && t.push("scale(" + C(i, 1) + " " + C(r, 1) + ")"), t.length && l.setAttribute("transform", t.join(" "))
            },
            toFront: function () {
                var t = this.element;
                return t.parentNode.appendChild(t), this
            },
            align: function (t, e, i) {
                var n, o, a, s = {}, h = this.renderer, c = h.alignedObjects;
                t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || l(i)) && (this.alignTo = n = i || "renderer", r(c, this), c.push(this), i = null)) : (t = this.alignOptions, e = this.alignByTranslate, n = this.alignTo), i = C(i, h[n], h), n = t.align, h = t.verticalAlign, c = (i.x || 0) + (t.x || 0);
                var u = (i.y || 0) + (t.y || 0);
                return "right" === n ? o = 1 : "center" === n && (o = 2), o && (c += (i.width - (t.width || 0)) / o), s[e ? "translateX" : "x"] = Math.round(c), "bottom" === h ? a = 1 : "middle" === h && (a = 2), a && (u += (i.height - (t.height || 0)) / a), s[e ? "translateY" : "y"] = Math.round(u), this[this.placed ? "animate" : "attr"](s), this.placed = !0, this.alignAttr = s, this
            },
            getBBox: function (t, e) {
                var i, r, o = this.renderer, a = this.element, s = this.styles, l = this.textStr, h = o.cache,
                    c = o.cacheKeys, u = a.namespaceURI === this.SVG_NS, d = (e = C(e, this.rotation)) * y,
                    f = o.styledMode ? a && z.prototype.getStyle.call(a, "font-size") : s && s.fontSize;
                if (n(l)) {
                    var p = l.toString();
                    -1 === p.indexOf("<") && (p = p.replace(/[0-9]/g, "0")), p += ["", e || 0, f, this.textWidth, s && s.textOverflow].join()
                }
                if (p && !t && (i = h[p]), !i) {
                    if (u || o.forExport) {
                        try {
                            (r = this.fakeTS && function (t) {
                                [].forEach.call(a.querySelectorAll(".highcharts-text-outline"), function (e) {
                                    e.style.display = t
                                })
                            }) && r("none"), i = a.getBBox ? M({}, a.getBBox()) : {
                                width: a.offsetWidth,
                                height: a.offsetHeight
                            }, r && r("")
                        } catch (g) {
                        }
                        (!i || 0 > i.width) && (i = {width: 0, height: 0})
                    } else i = this.htmlGetBBox();
                    if (o.isSVG && (t = i.width, o = i.height, u && (i.height = o = {
                        "11px,17": 14,
                        "13px,20": 16
                    }[s && s.fontSize + "," + Math.round(o)] || o), e && (i.width = Math.abs(o * Math.sin(d)) + Math.abs(t * Math.cos(d)), i.height = Math.abs(o * Math.cos(d)) + Math.abs(t * Math.sin(d)))), p && 0 < i.height) {
                        for (; 250 < c.length;) delete h[c.shift()];
                        h[p] || c.push(p), h[p] = i
                    }
                }
                return i
            },
            show: function (t) {
                return this.attr({visibility: t ? "inherit" : "visible"})
            },
            hide: function (t) {
                return t ? this.attr({y: -9999}) : this.attr({visibility: "hidden"}), this
            },
            fadeOut: function (t) {
                var e = this;
                e.animate({opacity: 0}, {
                    duration: t || 150, complete: function () {
                        e.attr({y: -9999})
                    }
                })
            },
            add: function (t) {
                var e = this.renderer, i = this.element;
                if (t && (this.parentGroup = t), this.parentInverted = t && t.inverted, void 0 !== this.textStr && e.buildText(this), this.added = !0, !t || t.handleZ || this.zIndex) var n = this.zIndexSetter();
                return n || (t ? t.element : e.box).appendChild(i), this.onAdd && this.onAdd(), this
            },
            safeRemoveChild: function (t) {
                var e = t.parentNode;
                e && e.removeChild(t)
            },
            destroy: function () {
                var t = this, e = t.element || {}, i = t.renderer,
                    n = i.isSVG && "SPAN" === e.nodeName && t.parentGroup, o = e.ownerSVGElement, a = t.clipPath;
                if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, P(t), a && o && ([].forEach.call(o.querySelectorAll("[clip-path],[CLIP-PATH]"), function (t) {
                    -1 < t.getAttribute("clip-path").indexOf(a.element.id) && t.removeAttribute("clip-path")
                }), t.clipPath = a.destroy()), t.stops) {
                    for (o = 0; o < t.stops.length; o++) t.stops[o] = t.stops[o].destroy();
                    t.stops = null
                }
                for (t.safeRemoveChild(e), i.styledMode || t.destroyShadows(); n && n.div && 0 === n.div.childNodes.length;) e = n.parentGroup, t.safeRemoveChild(n.div), delete n.div, n = e;
                t.alignTo && r(i.alignedObjects, t), h(t, function (e, i) {
                    t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i]
                })
            },
            shadow: function (t, e, n) {
                var r, o = [], a = this.element;
                if (t) {
                    if (!this.shadows) {
                        var s = C(t.width, 3), l = (t.opacity || .15) / s,
                            h = this.parentInverted ? "(-1,-1)" : "(" + C(t.offsetX, 1) + ", " + C(t.offsetY, 1) + ")";
                        for (r = 1; r <= s; r++) {
                            var c = a.cloneNode(0), u = 2 * s + 1 - 2 * r;
                            i(c, {
                                stroke: t.color || "#000000",
                                "stroke-opacity": l * r,
                                "stroke-width": u,
                                transform: "translate" + h,
                                fill: "none"
                            }), c.setAttribute("class", (c.getAttribute("class") || "") + " highcharts-shadow"), n && (i(c, "height", Math.max(i(c, "height") - u, 0)), c.cutHeight = u), e ? e.element.appendChild(c) : a.parentNode && a.parentNode.insertBefore(c, a), o.push(c)
                        }
                        this.shadows = o
                    }
                } else this.destroyShadows();
                return this
            },
            destroyShadows: function () {
                (this.shadows || []).forEach(function (t) {
                    this.safeRemoveChild(t)
                }, this), this.shadows = void 0
            },
            xGetter: function (t) {
                return "circle" === this.element.nodeName && ("x" === t ? t = "cx" : "y" === t && (t = "cy")), this._defaultGetter(t)
            },
            _defaultGetter: function (t) {
                return t = C(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0), /^[\-0-9\.]+$/.test(t) && (t = parseFloat(t)), t
            },
            dSetter: function (t, e, i) {
                t && t.join && (t = t.join(" ")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t)
            },
            dashstyleSetter: function (t) {
                var e, i = this["stroke-width"];
                if ("inherit" === i && (i = 1), t = t && t.toLowerCase()) {
                    for (e = (t = t.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",")).length; e--;) t[e] = c(t[e]) * i;
                    t = t.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t)
                }
            },
            alignSetter: function (t) {
                var e = {left: "start", center: "middle", right: "end"};
                e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t]))
            },
            opacitySetter: function (t, e, i) {
                this[e] = t, i.setAttribute(e, t)
            },
            titleSetter: function (t) {
                var e = this.element.getElementsByTagName("title")[0];
                e || (e = b.createElementNS(this.SVG_NS, "title"), this.element.appendChild(e)), e.firstChild && e.removeChild(e.firstChild), e.appendChild(b.createTextNode(String(C(t, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")))
            },
            textSetter: function (t) {
                t !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this))
            },
            setTextPath: function (e, i) {
                var r = this.element, o = {textAnchor: "text-anchor"}, a = !1, s = this.textPathWrapper, l = !s,
                    c = (i = T(!0, {
                        enabled: !0,
                        attributes: {dy: -5, startOffset: "50%", textAnchor: "middle"}
                    }, i)).attributes;
                if (e && i && i.enabled) {
                    this.options && this.options.padding && (c.dx = -this.options.padding), s || (this.textPathWrapper = s = this.renderer.createElement("textPath"), a = !0);
                    var u = s.element;
                    if ((i = e.element.getAttribute("id")) || e.element.setAttribute("id", i = t.uniqueKey()), l) for (e = r.getElementsByTagName("tspan"); e.length;) e[0].setAttribute("y", 0), u.appendChild(e[0]);
                    a && s.add({element: this.text ? this.text.element : r}), u.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + i), n(c.dy) && (u.parentNode.setAttribute("dy", c.dy), delete c.dy), n(c.dx) && (u.parentNode.setAttribute("dx", c.dx), delete c.dx), h(c, function (t, e) {
                        u.setAttribute(o[e] || e, t)
                    }), r.removeAttribute("transform"), this.removeTextOutline.call(s, [].slice.call(r.getElementsByTagName("tspan"))), this.text && !this.renderer.styledMode && this.attr({
                        fill: "none",
                        "stroke-width": 0
                    }), this.applyTextOutline = this.updateTransform = E
                } else s && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(r, e));
                return this
            },
            destroyTextPath: function (t, e) {
                var i;
                for (e.element.setAttribute("id", ""), i = this.textPathWrapper.element.childNodes; i.length;) t.firstChild.appendChild(i[0]);
                t.firstChild.removeChild(this.textPathWrapper.element), delete e.textPathWrapper
            },
            fillSetter: function (t, e, i) {
                "string" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i)
            },
            visibilitySetter: function (t, e, i) {
                "inherit" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t
            },
            zIndexSetter: function (t, e) {
                var i = this.renderer, r = this.parentGroup, o = (r || i).element || i.box, a = this.element, s = !1;
                i = o === i.box;
                var l, h = this.added;
                if (n(t) ? (a.setAttribute("data-z-index", t), t = +t, this[e] === t && (h = !1)) : n(this[e]) && a.removeAttribute("data-z-index"), this[e] = t, h) {
                    for ((t = this.zIndex) && r && (r.handleZ = !0), l = (e = o.childNodes).length - 1; 0 <= l && !s; l--) {
                        h = (r = e[l]).getAttribute("data-z-index");
                        var u = !n(h);
                        r !== a && (0 > t && u && !i && !l ? (o.insertBefore(a, e[l]), s = !0) : (c(h) <= t || u && (!n(t) || 0 <= t)) && (o.insertBefore(a, e[l + 1] || null), s = !0))
                    }
                    s || (o.insertBefore(a, e[i ? 3 : 0] || null), s = !0)
                }
                return s
            },
            _defaultSetter: function (t, e, i) {
                i.setAttribute(e, t)
            }
        }), z.prototype.yGetter = z.prototype.xGetter, z.prototype.translateXSetter = z.prototype.translateYSetter = z.prototype.rotationSetter = z.prototype.verticalAlignSetter = z.prototype.rotationOriginXSetter = z.prototype.rotationOriginYSetter = z.prototype.scaleXSetter = z.prototype.scaleYSetter = z.prototype.matrixSetter = function (t, e) {
            this[e] = t, this.doTransform = !0
        }, z.prototype["stroke-widthSetter"] = z.prototype.strokeSetter = function (t, e, i) {
            this[e] = t, this.stroke && this["stroke-width"] ? (z.prototype.fillSetter.call(this, this.stroke, "stroke", i), i.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === e && 0 === t && this.hasStroke ? (i.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (i.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0)
        }, e = t.SVGRenderer = function () {
            this.init.apply(this, arguments)
        }, M(e.prototype, {
            Element: z, SVG_NS: O, init: function (t, e, n, r, o, a, s) {
                var l, h = this.createElement("svg").attr({version: "1.1", class: "highcharts-root"});
                s || h.css(this.getStyle(r)), r = h.element, t.appendChild(r), i(t, "dir", "ltr"), -1 === t.innerHTML.indexOf("xmlns") && i(r, "xmlns", this.SVG_NS), this.isSVG = !0, this.box = r, this.boxWrapper = h, this.alignedObjects = [], this.url = (w || S) && b.getElementsByTagName("base").length ? N.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", this.createElement("desc").add().element.appendChild(b.createTextNode("Created with Highcharts 7.2.0")), this.defs = this.createElement("defs").add(), this.allowHTML = a, this.forExport = o, this.styledMode = s, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.setSize(e, n, !1), w && t.getBoundingClientRect && ((e = function () {
                    m(t, {
                        left: 0,
                        top: 0
                    }), l = t.getBoundingClientRect(), m(t, {
                        left: Math.ceil(l.left) - l.left + "px",
                        top: Math.ceil(l.top) - l.top + "px"
                    })
                })(), this.unSubPixelFix = d(N, "resize", e))
            }, definition: function (t) {
                var e = this;
                return function t(i, n) {
                    var r;
                    return u(i).forEach(function (i) {
                        var o = e.createElement(i.tagName), a = {};
                        h(i, function (t, e) {
                            "tagName" !== e && "children" !== e && "textContent" !== e && (a[e] = t)
                        }), o.attr(a), o.add(n || e.defs), i.textContent && o.element.appendChild(b.createTextNode(i.textContent)), t(i.children || [], o), r = o
                    }), r
                }(t)
            }, getStyle: function (t) {
                return this.style = M({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                    fontSize: "12px"
                }, t)
            }, setStyle: function (t) {
                this.boxWrapper.css(this.getStyle(t))
            }, isHidden: function () {
                return !this.boxWrapper.getBBox().width
            }, destroy: function () {
                var t = this.defs;
                return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), x(this.gradients || {}), this.gradients = null, t && (this.defs = t.destroy()), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null
            }, createElement: function (t) {
                var e = new this.Element;
                return e.init(this, t), e
            }, draw: E, getRadialAttr: function (t, e) {
                return {cx: t[0] - t[2] / 2 + e.cx * t[2], cy: t[1] - t[2] / 2 + e.cy * t[2], r: e.r * t[2]}
            }, truncate: function (t, e, i, n, r, o, a) {
                var s, l, h = this, c = t.rotation, u = n ? 1 : 0, d = (i || n).length, f = d, p = [],
                    g = function (t) {
                        e.firstChild && e.removeChild(e.firstChild), t && e.appendChild(b.createTextNode(t))
                    }, m = function (o, s) {
                        if (void 0 === p[s = s || o]) if (e.getSubStringLength) try {
                            p[s] = r + e.getSubStringLength(0, n ? s + 1 : s)
                        } catch (l) {
                        } else h.getSpanWidth && (g(a(i || n, o)), p[s] = r + h.getSpanWidth(t, e));
                        return p[s]
                    };
                t.rotation = 0;
                var v = m(e.textContent.length);
                if (l = r + v > o) {
                    for (; u <= d;) f = Math.ceil((u + d) / 2), n && (s = a(n, f)), v = m(f, s && s.length - 1), u === d ? u = d + 1 : v > o ? d = f - 1 : u = f;
                    0 === d ? g("") : i && d === i.length - 1 || g(s || a(i || n, f))
                }
                return n && n.splice(0, f), t.actualWidth = v, t.rotation = c, l
            }, escapes: {"&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;"}, buildText: function (t) {
                var e, n, r = t.element, o = this, a = o.forExport, s = C(t.textStr, "").toString(),
                    l = -1 !== s.indexOf("<"), u = r.childNodes, d = i(r, "x"), f = t.styles, p = t.textWidth,
                    g = f && f.lineHeight, v = f && f.textOutline, y = f && "ellipsis" === f.textOverflow,
                    x = f && "nowrap" === f.whiteSpace, M = f && f.fontSize, A = u.length;
                f = p && !t.added && this.box;
                var w = function (t) {
                    var e;
                    return o.styledMode || (e = /(px|em)$/.test(t && t.style.fontSize) ? t.style.fontSize : M || o.style.fontSize || 12), g ? c(g) : o.fontMetrics(e, t.getAttribute("style") ? t : r).h
                }, k = function (t, e) {
                    return h(o.escapes, function (i, n) {
                        e && -1 !== e.indexOf(i) || (t = t.toString().replace(new RegExp(i, "g"), n))
                    }), t
                }, S = function (t, e) {
                    var i = t.indexOf("<");
                    if (-1 !== (i = (t = t.substring(i, t.indexOf(">") - i)).indexOf(e + "=")) && (i = i + e.length + 1, '"' === (e = t.charAt(i)) || "'" === e)) return (t = t.substring(i + 1)).substring(0, t.indexOf(e))
                }, T = /<br.*?>/g, E = [s, y, x, g, v, M, p].join();
                if (E !== t.textCache) {
                    for (t.textCache = E; A--;) r.removeChild(u[A]);
                    l || v || y || p || -1 !== s.indexOf(" ") && (!x || T.test(s)) ? (f && f.appendChild(r), l ? s = (s = o.styledMode ? s.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : s.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">')).replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(T) : s = [s], (s = s.filter(function (t) {
                        return "" !== t
                    })).forEach(function (s, l) {
                        var h = 0, c = 0,
                            u = (s = s.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||")).split("|||");
                        u.forEach(function (s) {
                            if ("" !== s || 1 === u.length) {
                                var f, g, v = {}, A = b.createElementNS(o.SVG_NS, "tspan");
                                if ((f = S(s, "class")) && i(A, "class", f), (f = S(s, "style")) && (f = f.replace(/(;| |^)color([ :])/, "$1fill$2"), i(A, "style", f)), (g = S(s, "href")) && !a && (i(A, "onclick", 'location.href="' + g + '"'), i(A, "class", "highcharts-anchor"), o.styledMode || m(A, {cursor: "pointer"})), " " !== (s = k(s.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " "))) {
                                    if (A.appendChild(b.createTextNode(s)), h ? v.dx = 0 : l && null !== d && (v.x = d), i(A, v), r.appendChild(A), !h && n && (!_ && a && m(A, {display: "block"}), i(A, "dy", w(A))), p) {
                                        var T = s.replace(/([^\^])-/g, "$1- ").split(" ");
                                        v = !x && (1 < u.length || l || 1 < T.length), g = 0;
                                        var E = w(A);
                                        if (y) e = o.truncate(t, A, s, void 0, 0, Math.max(0, p - parseInt(M || 12, 10)), function (t, e) {
                                            return t.substring(0, e) + "\u2026"
                                        }); else if (v) for (; T.length;) T.length && !x && 0 < g && (A = b.createElementNS(O, "tspan"), i(A, {
                                            dy: E,
                                            x: d
                                        }), f && i(A, "style", f), A.appendChild(b.createTextNode(T.join(" ").replace(/- /g, "-"))), r.appendChild(A)), o.truncate(t, A, null, T, 0 === g ? c : 0, p, function (t, e) {
                                            return T.slice(0, e).join(" ").replace(/- /g, "-")
                                        }), c = t.actualWidth, g++
                                    }
                                    h++
                                }
                            }
                        }), n = n || r.childNodes.length
                    }), y && e && t.attr("title", k(t.textStr, ["&lt;", "&gt;"])), f && f.removeChild(r), v && t.applyTextOutline && t.applyTextOutline(v)) : r.appendChild(b.createTextNode(k(s)))
                }
            }, getContrast: function (t) {
                return (t = g(t).rgba)[0] *= 1, t[1] *= 1.2, t[2] *= .5, 459 < t[0] + t[1] + t[2] ? "#000000" : "#FFFFFF"
            }, button: function (t, e, i, n, r, o, a, s, l, h) {
                var c = this.label(t, e, i, l, null, null, h, null, "button"), u = 0, f = this.styledMode;
                if (c.attr(T({padding: 8, r: 2}, r)), !f) {
                    var p = (r = T({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        "stroke-width": 1,
                        style: {color: "#333333", cursor: "pointer", fontWeight: "normal"}
                    }, r)).style;
                    delete r.style;
                    var g = (o = T(r, {fill: "#e6e6e6"}, o)).style;
                    delete o.style;
                    var m = (a = T(r, {fill: "#e6ebf5", style: {color: "#000000", fontWeight: "bold"}}, a)).style;
                    delete a.style;
                    var v = (s = T(r, {style: {color: "#cccccc"}}, s)).style;
                    delete s.style
                }
                return d(c.element, k ? "mouseover" : "mouseenter", function () {
                    3 !== u && c.setState(1)
                }), d(c.element, k ? "mouseout" : "mouseleave", function () {
                    3 !== u && c.setState(u)
                }), c.setState = function (t) {
                    1 !== t && (c.state = u = t), c.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t || 0]), f || c.attr([r, o, a, s][t || 0]).css([p, g, m, v][t || 0])
                }, f || c.attr(r).css(M({cursor: "default"}, p)), c.on("click", function (t) {
                    3 !== u && n.call(c, t)
                })
            }, crispLine: function (t, e) {
                return t[1] === t[4] && (t[1] = t[4] = Math.round(t[1]) - e % 2 / 2), t[2] === t[5] && (t[2] = t[5] = Math.round(t[2]) + e % 2 / 2), t
            }, path: function (t) {
                var e = this.styledMode ? {} : {fill: "none"};
                return o(t) ? e.d = t : s(t) && M(e, t), this.createElement("path").attr(e)
            }, circle: function (t, e, i) {
                return t = s(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    r: i
                }, (e = this.createElement("circle")).xSetter = e.ySetter = function (t, e, i) {
                    i.setAttribute("c" + e, t)
                }, e.attr(t)
            }, arc: function (t, e, i, n, r, o) {
                return s(t) ? (e = (n = t).y, i = n.r, t = n.x) : n = {
                    innerR: n,
                    start: r,
                    end: o
                }, (t = this.symbol("arc", t, e, i, i, n)).r = i, t
            }, rect: function (t, e, n, r, o, a) {
                o = s(t) ? t.r : o;
                var l = this.createElement("rect");
                return t = s(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    width: Math.max(n, 0),
                    height: Math.max(r, 0)
                }, this.styledMode || (void 0 !== a && (t.strokeWidth = a, t = l.crisp(t)), t.fill = "none"), o && (t.r = o), l.rSetter = function (t, e, n) {
                    l.r = t, i(n, {rx: t, ry: t})
                }, l.rGetter = function () {
                    return l.r
                }, l.attr(t)
            }, setSize: function (t, e, i) {
                var n = this.alignedObjects, r = n.length;
                for (this.width = t, this.height = e, this.boxWrapper.animate({
                    width: t,
                    height: e
                }, {
                    step: function () {
                        this.attr({viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")})
                    }, duration: C(i, !0) ? void 0 : 0
                }); r--;) n[r].align()
            }, g: function (t) {
                var e = this.createElement("g");
                return t ? e.attr({class: "highcharts-" + t}) : e
            }, image: function (t, e, i, n, r, o) {
                var a = {preserveAspectRatio: "none"}, s = function (t, e) {
                    t.setAttributeNS ? t.setAttributeNS("http://www.w3.org/1999/xlink", "href", e) : t.setAttribute("hc-svg-href", e)
                }, l = function (e) {
                    s(h.element, t), o.call(h, e)
                };
                1 < arguments.length && M(a, {x: e, y: i, width: n, height: r});
                var h = this.createElement("image").attr(a);
                return o ? (s(h.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), a = new N.Image, d(a, "load", l), a.src = t, a.complete && l({})) : s(h.element, t), h
            }, symbol: function (t, e, i, r, o, a) {
                var s = this, l = /^url\((.*?)\)$/, h = l.test(t), c = !h && (this.symbols[t] ? t : "circle"),
                    u = c && this.symbols[c],
                    d = n(e) && u && u.call(this.symbols, Math.round(e), Math.round(i), r, o, a);
                if (u) {
                    var f = this.path(d);
                    s.styledMode || f.attr("fill", "none"), M(f, {
                        symbolName: c,
                        x: e,
                        y: i,
                        width: r,
                        height: o
                    }), a && M(f, a)
                } else if (h) {
                    var g = t.match(l)[1];
                    (f = this.image(g)).imgwidth = C(L[g] && L[g].width, a && a.width), f.imgheight = C(L[g] && L[g].height, a && a.height);
                    var y = function () {
                        f.attr({width: f.width, height: f.height})
                    };
                    ["width", "height"].forEach(function (t) {
                        f[t + "Setter"] = function (t, e) {
                            var i = {}, r = this["img" + e], o = "width" === e ? "translateX" : "translateY";
                            this[e] = t, n(r) && (a && "within" === a.backgroundSize && this.width && this.height && (r = Math.round(r * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(e, r), this.alignByTranslate || (i[o] = ((this[e] || 0) - r) / 2, this.attr(i)))
                        }
                    }), n(e) && f.attr({
                        x: e,
                        y: i
                    }), f.isImg = !0, n(f.imgwidth) && n(f.imgheight) ? y() : (f.attr({
                        width: 0,
                        height: 0
                    }), v("img", {
                        onload: function () {
                            var t = p[s.chartIndex];
                            0 === this.width && (m(this, {
                                position: "absolute",
                                top: "-999em"
                            }), b.body.appendChild(this)), L[g] = {
                                width: this.width,
                                height: this.height
                            }, f.imgwidth = this.width, f.imgheight = this.height, f.element && y(), this.parentNode && this.parentNode.removeChild(this), s.imgCount--, !s.imgCount && t && t.onload && t.onload()
                        }, src: g
                    }), this.imgCount++)
                }
                return f
            }, symbols: {
                circle: function (t, e, i, n) {
                    return this.arc(t + i / 2, e + n / 2, i / 2, n / 2, {
                        start: .5 * Math.PI,
                        end: 2.5 * Math.PI,
                        open: !1
                    })
                }, square: function (t, e, i, n) {
                    return ["M", t, e, "L", t + i, e, t + i, e + n, t, e + n, "Z"]
                }, triangle: function (t, e, i, n) {
                    return ["M", t + i / 2, e, "L", t + i, e + n, t, e + n, "Z"]
                }, "triangle-down": function (t, e, i, n) {
                    return ["M", t, e, "L", t + i, e, t + i / 2, e + n, "Z"]
                }, diamond: function (t, e, i, n) {
                    return ["M", t + i / 2, e, "L", t + i, e + n / 2, t + i / 2, e + n, t, e + n / 2, "Z"]
                }, arc: function (t, e, i, r, o) {
                    var a = o.start, s = o.r || i, l = o.r || r || i, h = o.end - .001;
                    i = o.innerR, r = C(o.open, .001 > Math.abs(o.end - o.start - 2 * Math.PI));
                    var c = Math.cos(a), u = Math.sin(a), d = Math.cos(h);
                    return h = Math.sin(h), o = ["M", t + s * c, e + l * u, "A", s, l, 0, a = .001 > o.end - a - Math.PI ? 0 : 1, C(o.clockwise, 1), t + s * d, e + l * h], n(i) && o.push(r ? "M" : "L", t + i * d, e + i * h, "A", i, i, 0, a, 0, t + i * c, e + i * u), o.push(r ? "" : "Z"), o
                }, callout: function (t, e, i, n, r) {
                    var o = Math.min(r && r.r || 0, i, n), a = o + 6, s = r && r.anchorX;
                    r = r && r.anchorY;
                    var l = ["M", t + o, e, "L", t + i - o, e, "C", t + i, e, t + i, e, t + i, e + o, "L", t + i, e + n - o, "C", t + i, e + n, t + i, e + n, t + i - o, e + n, "L", t + o, e + n, "C", t, e + n, t, e + n, t, e + n - o, "L", t, e + o, "C", t, e, t, e, t + o, e];
                    return s && s > i ? r > e + a && r < e + n - a ? l.splice(13, 3, "L", t + i, r - 6, t + i + 6, r, t + i, r + 6, t + i, e + n - o) : l.splice(13, 3, "L", t + i, n / 2, s, r, t + i, n / 2, t + i, e + n - o) : s && 0 > s ? r > e + a && r < e + n - a ? l.splice(33, 3, "L", t, r + 6, t - 6, r, t, r - 6, t, e + o) : l.splice(33, 3, "L", t, n / 2, s, r, t, n / 2, t, e + o) : r && r > n && s > t + a && s < t + i - a ? l.splice(23, 3, "L", s + 6, e + n, s, e + n + 6, s - 6, e + n, t + o, e + n) : r && 0 > r && s > t + a && s < t + i - a && l.splice(3, 3, "L", s - 6, e, s, e - 6, s + 6, e, i - o, e), l
                }
            }, clipRect: function (e, i, n, r) {
                var o = t.uniqueKey() + "-", a = this.createElement("clipPath").attr({id: o}).add(this.defs);
                return (e = this.rect(e, i, n, r, 0).add(a)).id = o, e.clipPath = a, e.count = 0, e
            }, text: function (t, e, i, r) {
                var o = {};
                return !r || !this.allowHTML && this.forExport ? (o.x = Math.round(e || 0), i && (o.y = Math.round(i)), n(t) && (o.text = t), t = this.createElement("text").attr(o), r || (t.xSetter = function (t, e, i) {
                    var n, r = i.getElementsByTagName("tspan"), o = i.getAttribute(e);
                    for (n = 0; n < r.length; n++) {
                        var a = r[n];
                        a.getAttribute(e) === o && a.setAttribute(e, t)
                    }
                    i.setAttribute(e, t)
                }), t) : this.html(t, e, i)
            }, fontMetrics: function (t, e) {
                return t = !this.styledMode && /px/.test(t) || !N.getComputedStyle ? t || e && e.style && e.style.fontSize || this.style && this.style.fontSize : e && z.prototype.getStyle.call(e, "font-size"), {
                    h: e = 24 > (t = /px/.test(t) ? c(t) : 12) ? t + 3 : Math.round(1.2 * t),
                    b: Math.round(.8 * e),
                    f: t
                }
            }, rotCorr: function (t, e, i) {
                var n = t;
                return e && i && (n = Math.max(n * Math.cos(e * y), 4)), {x: -t / 3 * Math.sin(e * y), y: n}
            }, label: function (t, e, i, r, o, s, l, h, c) {
                var u, d, f, p, g, m, v, y, x, b = this, A = b.styledMode, w = b.g("button" !== c && "label"),
                    k = w.text = b.text("", 0, 0, l).attr({zIndex: 1}), S = 0, E = 3, C = 0, P = {},
                    _ = /^url\((.*?)\)$/.test(r), O = A || _, L = function () {
                        return A ? u.strokeWidth() % 2 / 2 : (y ? parseInt(y, 10) : 0) % 2 / 2
                    };
                c && w.addClass("highcharts-" + c);
                var N = function () {
                    var t = k.element.style, e = {};
                    d = (void 0 === f || void 0 === p || v) && n(k.textStr) && k.getBBox(), w.width = (f || d.width || 0) + 2 * E + C, w.height = (p || d.height || 0) + 2 * E, x = E + Math.min(b.fontMetrics(t && t.fontSize, k).b, d ? d.height : 1 / 0), O && (u || (w.box = u = b.symbols[r] || _ ? b.symbol(r) : b.rect(), u.addClass(("button" === c ? "" : "highcharts-label-box") + (c ? " highcharts-" + c + "-box" : "")), u.add(w), t = L(), e.x = t, e.y = (h ? -x : 0) + t), e.width = Math.round(w.width), e.height = Math.round(w.height), u.attr(M(e, P)), P = {})
                }, I = function () {
                    var t = C + E, e = h ? 0 : x;
                    n(f) && d && ("center" === v || "right" === v) && (t += {
                        center: .5,
                        right: 1
                    }[v] * (f - d.width)), t === k.x && e === k.y || (k.attr("x", t), k.hasBoxWidthChanged && (d = k.getBBox(!0), N()), void 0 !== e && k.attr("y", e)), k.x = t, k.y = e
                }, R = function (t, e) {
                    u ? u.attr(t, e) : P[t] = e
                };
                w.onAdd = function () {
                    k.add(w), w.attr({text: t || 0 === t ? t : "", x: e, y: i}), u && n(o) && w.attr({
                        anchorX: o,
                        anchorY: s
                    })
                }, w.widthSetter = function (t) {
                    f = a(t) ? t : null
                }, w.heightSetter = function (t) {
                    p = t
                }, w["text-alignSetter"] = function (t) {
                    v = t
                }, w.paddingSetter = function (t) {
                    n(t) && t !== E && (E = w.padding = t, I())
                }, w.paddingLeftSetter = function (t) {
                    n(t) && t !== C && (C = t, I())
                }, w.alignSetter = function (t) {
                    (t = {left: 0, center: .5, right: 1}[t]) !== S && (S = t, d && w.attr({x: g}))
                }, w.textSetter = function (t) {
                    void 0 !== t && k.attr({text: t}), N(), I()
                }, w["stroke-widthSetter"] = function (t, e) {
                    t && (O = !0), y = this["stroke-width"] = t, R(e, t)
                }, A ? w.rSetter = function (t, e) {
                    R(e, t)
                } : w.strokeSetter = w.fillSetter = w.rSetter = function (t, e) {
                    "r" !== e && ("fill" === e && t && (O = !0), w[e] = t), R(e, t)
                }, w.anchorXSetter = function (t, e) {
                    o = w.anchorX = t, R(e, Math.round(t) - L() - g)
                }, w.anchorYSetter = function (t, e) {
                    s = w.anchorY = t, R(e, t - m)
                }, w.xSetter = function (t) {
                    w.x = t, S && (t -= S * ((f || d.width) + 2 * E), w["forceAnimate:x"] = !0), g = Math.round(t), w.attr("translateX", g)
                }, w.ySetter = function (t) {
                    m = w.y = Math.round(t), w.attr("translateY", m)
                };
                var B = w.css;
                return l = {
                    css: function (t) {
                        if (t) {
                            var e = {};
                            t = T(t), w.textProps.forEach(function (i) {
                                void 0 !== t[i] && (e[i] = t[i], delete t[i])
                            }), k.css(e), "width" in e && N(), "fontSize" in e && (N(), I())
                        }
                        return B.call(w, t)
                    }, getBBox: function () {
                        return {width: d.width + 2 * E, height: d.height + 2 * E, x: d.x - E, y: d.y - E}
                    }, destroy: function () {
                        D(w.element, "mouseenter"), D(w.element, "mouseleave"), k && (k = k.destroy()), u && (u = u.destroy()), z.prototype.destroy.call(w), w = b = N = I = R = null
                    }
                }, A || (l.shadow = function (t) {
                    return t && (N(), u && u.shadow(t)), w
                }), M(w, l)
            }
        }), t.Renderer = e
    }), e(i, "parts/Html.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.attr, n = e.defined, r = e.pInt, o = t.createElement, a = t.css, s = t.extend, l = t.isFirefox,
            h = t.isMS, c = t.isWebKit, u = t.pick, d = t.SVGElement;
        e = t.SVGRenderer;
        var f = t.win;
        s(d.prototype, {
            htmlCss: function (t) {
                var e = "SPAN" === this.element.tagName && t && "width" in t, i = u(e && t.width, void 0);
                if (e) {
                    delete t.width, this.textWidth = i;
                    var n = !0
                }
                return t && "ellipsis" === t.textOverflow && (t.whiteSpace = "nowrap", t.overflow = "hidden"), this.styles = s(this.styles, t), a(this.element, t), n && this.htmlUpdateTransform(), this
            }, htmlGetBBox: function () {
                var t = this.element;
                return {x: t.offsetLeft, y: t.offsetTop, width: t.offsetWidth, height: t.offsetHeight}
            }, htmlUpdateTransform: function () {
                if (this.added) {
                    var t = this.renderer, e = this.element, i = this.translateX || 0, o = this.translateY || 0,
                        s = this.x || 0, l = this.y || 0, h = this.textAlign || "left",
                        c = {left: 0, center: .5, right: 1}[h], u = this.styles, d = u && u.whiteSpace;
                    if (a(e, {
                        marginLeft: i,
                        marginTop: o
                    }), !t.styledMode && this.shadows && this.shadows.forEach(function (t) {
                        a(t, {marginLeft: i + 1, marginTop: o + 1})
                    }), this.inverted && [].forEach.call(e.childNodes, function (i) {
                        t.invertChild(i, e)
                    }), "SPAN" === e.tagName) {
                        u = this.rotation;
                        var f, p = this.textWidth && r(this.textWidth),
                            g = [u, h, e.innerHTML, this.textWidth, this.textAlign].join();
                        (f = p !== this.oldTextWidth) && !(f = p > this.oldTextWidth) && ((f = this.textPxLength) || (a(e, {
                            width: "",
                            whiteSpace: d || "nowrap"
                        }), f = e.offsetWidth), f = f > p), f && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) ? (a(e, {
                            width: p + "px",
                            display: "block",
                            whiteSpace: d || "normal"
                        }), this.oldTextWidth = p, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1, g !== this.cTT && (d = t.fontMetrics(e.style.fontSize, e).b, !n(u) || u === (this.oldRotation || 0) && h === this.oldAlign || this.setSpanRotation(u, c, d), this.getSpanCorrection(!n(u) && this.textPxLength || e.offsetWidth, d, c, u, h)), a(e, {
                            left: s + (this.xCorr || 0) + "px",
                            top: l + (this.yCorr || 0) + "px"
                        }), this.cTT = g, this.oldRotation = u, this.oldAlign = h
                    }
                } else this.alignOnAdd = !0
            }, setSpanRotation: function (t, e, i) {
                var n = {}, r = this.renderer.getTransformKey();
                n[r] = n.transform = "rotate(" + t + "deg)", n[r + (l ? "Origin" : "-origin")] = n.transformOrigin = 100 * e + "% " + i + "px", a(this.element, n)
            }, getSpanCorrection: function (t, e, i) {
                this.xCorr = -t * i, this.yCorr = -e
            }
        }), s(e.prototype, {
            getTransformKey: function () {
                return h && !/Edge/.test(f.navigator.userAgent) ? "-ms-transform" : c ? "-webkit-transform" : l ? "MozTransform" : f.opera ? "-o-transform" : ""
            }, html: function (t, e, n) {
                var r = this.createElement("span"), a = r.element, l = r.renderer, h = l.isSVG, c = function (t, e) {
                    ["opacity", "visibility"].forEach(function (i) {
                        t[i + "Setter"] = function (n, r, o) {
                            var a = t.div ? t.div.style : e;
                            d.prototype[i + "Setter"].call(this, n, r, o), a && (a[r] = n)
                        }
                    }), t.addedSetters = !0
                };
                return r.textSetter = function (t) {
                    t !== a.innerHTML && (delete this.bBox, delete this.oldTextWidth), this.textStr = t, a.innerHTML = u(t, ""), r.doTransform = !0
                }, h && c(r, r.element.style), r.xSetter = r.ySetter = r.alignSetter = r.rotationSetter = function (t, e) {
                    "align" === e && (e = "textAlign"), r[e] = t, r.doTransform = !0
                }, r.afterSetters = function () {
                    this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1)
                }, r.attr({
                    text: t,
                    x: Math.round(e),
                    y: Math.round(n)
                }).css({position: "absolute"}), l.styledMode || r.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize
                }), a.style.whiteSpace = "nowrap", r.css = r.htmlCss, h && (r.add = function (t) {
                    var e = l.box.parentNode, n = [];
                    if (this.parentGroup = t) {
                        var h = t.div;
                        if (!h) {
                            for (; t;) n.push(t), t = t.parentGroup;
                            n.reverse().forEach(function (t) {
                                function a(e, i) {
                                    t[i] = e, "translateX" === i ? u.left = e + "px" : u.top = e + "px", t.doTransform = !0
                                }

                                var l = i(t.element, "class"),
                                    u = (h = t.div = t.div || o("div", l ? {className: l} : void 0, {
                                        position: "absolute",
                                        left: (t.translateX || 0) + "px",
                                        top: (t.translateY || 0) + "px",
                                        display: t.display,
                                        opacity: t.opacity,
                                        pointerEvents: t.styles && t.styles.pointerEvents
                                    }, h || e)).style;
                                s(t, {
                                    classSetter: function (t) {
                                        return function (e) {
                                            this.element.setAttribute("class", e), t.className = e
                                        }
                                    }(h), on: function () {
                                        return n[0].div && r.on.apply({element: n[0].div}, arguments), t
                                    }, translateXSetter: a, translateYSetter: a
                                }), t.addedSetters || c(t)
                            })
                        }
                    } else h = e;
                    return h.appendChild(a), r.added = !0, r.alignOnAdd && r.htmlUpdateTransform(), r
                }), r
            }
        })
    }), e(i, "parts/Time.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isObject, r = e.objectEach, o = e.splat, a = t.extend, s = t.merge, l = t.pick,
            h = t.timeUnits, c = t.win;
        t.Time = function (t) {
            this.update(t, !1)
        }, t.Time.prototype = {
            defaultOptions: {}, update: function (t) {
                var e = l(t && t.useUTC, !0), i = this;
                this.options = t = s(!0, this.options || {}, t), this.Date = t.Date || c.Date || Date, this.timezoneOffset = (this.useUTC = e) && t.timezoneOffset, this.getTimezoneOffset = this.timezoneOffsetFunction(), (this.variableTimezone = !(e && !t.getTimezoneOffset && !t.timezone)) || this.timezoneOffset ? (this.get = function (t, e) {
                    var n = e.getTime(), r = n - i.getTimezoneOffset(e);
                    return e.setTime(r), t = e["getUTC" + t](), e.setTime(n), t
                }, this.set = function (t, e, n) {
                    if ("Milliseconds" === t || "Seconds" === t || "Minutes" === t && 0 == e.getTimezoneOffset() % 60) e["set" + t](n); else {
                        var r = i.getTimezoneOffset(e);
                        r = e.getTime() - r, e.setTime(r), e["setUTC" + t](n), t = i.getTimezoneOffset(e), r = e.getTime() + t, e.setTime(r)
                    }
                }) : e ? (this.get = function (t, e) {
                    return e["getUTC" + t]()
                }, this.set = function (t, e, i) {
                    return e["setUTC" + t](i)
                }) : (this.get = function (t, e) {
                    return e["get" + t]()
                }, this.set = function (t, e, i) {
                    return e["set" + t](i)
                })
            }, makeTime: function (e, i, n, r, o, a) {
                if (this.useUTC) {
                    var s = this.Date.UTC.apply(0, arguments), h = this.getTimezoneOffset(s);
                    s += h;
                    var c = this.getTimezoneOffset(s);
                    h !== c ? s += c - h : h - 36e5 !== this.getTimezoneOffset(s - 36e5) || t.isSafari || (s -= 36e5)
                } else s = new this.Date(e, i, l(n, 1), l(r, 0), l(o, 0), l(a, 0)).getTime();
                return s
            }, timezoneOffsetFunction: function () {
                var e = this, i = this.options, n = c.moment;
                if (!this.useUTC) return function (t) {
                    return 6e4 * new Date(t).getTimezoneOffset()
                };
                if (i.timezone) {
                    if (n) return function (t) {
                        return 6e4 * -n.tz(t, i.timezone).utcOffset()
                    };
                    t.error(25)
                }
                return this.useUTC && i.getTimezoneOffset ? function (t) {
                    return 6e4 * i.getTimezoneOffset(t)
                } : function () {
                    return 6e4 * (e.timezoneOffset || 0)
                }
            }, dateFormat: function (e, n, o) {
                if (!i(n) || isNaN(n)) return t.defaultOptions.lang.invalidDate || "";
                e = t.pick(e, "%Y-%m-%d %H:%M:%S");
                var a = this, s = new this.Date(n), l = this.get("Hours", s), h = this.get("Day", s),
                    c = this.get("Date", s), u = this.get("Month", s), d = this.get("FullYear", s),
                    f = t.defaultOptions.lang, p = f.weekdays, g = f.shortWeekdays, m = t.pad;
                return s = t.extend({
                    a: g ? g[h] : p[h].substr(0, 3),
                    A: p[h],
                    d: m(c),
                    e: m(c, 2, " "),
                    w: h,
                    b: f.shortMonths[u],
                    B: f.months[u],
                    m: m(u + 1),
                    o: u + 1,
                    y: d.toString().substr(2, 2),
                    Y: d,
                    H: m(l),
                    k: l,
                    I: m(l % 12 || 12),
                    l: l % 12 || 12,
                    M: m(a.get("Minutes", s)),
                    p: 12 > l ? "AM" : "PM",
                    P: 12 > l ? "am" : "pm",
                    S: m(s.getSeconds()),
                    L: m(Math.floor(n % 1e3), 3)
                }, t.dateFormats), r(s, function (t, i) {
                    for (; -1 !== e.indexOf("%" + i);) e = e.replace("%" + i, "function" == typeof t ? t.call(a, n) : t)
                }), o ? e.substr(0, 1).toUpperCase() + e.substr(1) : e
            }, resolveDTLFormat: function (t) {
                return n(t, !0) ? t : {main: (t = o(t))[0], from: t[1], to: t[2]}
            }, getTimeTicks: function (t, e, n, r) {
                var o, s = this, c = [], u = {}, d = new s.Date(e), f = t.unitRange, p = t.count || 1;
                if (r = l(r, 1), i(e)) {
                    if (s.set("Milliseconds", d, f >= h.second ? 0 : p * Math.floor(s.get("Milliseconds", d) / p)), f >= h.second && s.set("Seconds", d, f >= h.minute ? 0 : p * Math.floor(s.get("Seconds", d) / p)), f >= h.minute && s.set("Minutes", d, f >= h.hour ? 0 : p * Math.floor(s.get("Minutes", d) / p)), f >= h.hour && s.set("Hours", d, f >= h.day ? 0 : p * Math.floor(s.get("Hours", d) / p)), f >= h.day && s.set("Date", d, f >= h.month ? 1 : Math.max(1, p * Math.floor(s.get("Date", d) / p))), f >= h.month) {
                        s.set("Month", d, f >= h.year ? 0 : p * Math.floor(s.get("Month", d) / p));
                        var g = s.get("FullYear", d)
                    }
                    f >= h.year && s.set("FullYear", d, g - g % p), f === h.week && (g = s.get("Day", d), s.set("Date", d, s.get("Date", d) - g + r + (g < r ? -7 : 0))), g = s.get("FullYear", d), r = s.get("Month", d);
                    var m = s.get("Date", d), v = s.get("Hours", d);
                    for (e = d.getTime(), s.variableTimezone && (o = n - e > 4 * h.month || s.getTimezoneOffset(e) !== s.getTimezoneOffset(n)), e = d.getTime(), d = 1; e < n;) c.push(e), e = f === h.year ? s.makeTime(g + d * p, 0) : f === h.month ? s.makeTime(g, r + d * p) : !o || f !== h.day && f !== h.week ? o && f === h.hour && 1 < p ? s.makeTime(g, r, m, v + d * p) : e + f * p : s.makeTime(g, r, m + d * p * (f === h.day ? 1 : 7)), d++;
                    c.push(e), f <= h.hour && 1e4 > c.length && c.forEach(function (t) {
                        0 == t % 18e5 && "000000000" === s.dateFormat("%H%M%S%L", t) && (u[t] = "day")
                    })
                }
                return c.info = a(t, {higherRanks: u, totalRange: f * p}), c
            }
        }
    }), e(i, "parts/Options.js", [i["parts/Globals.js"]], function (t) {
        var e = t.color, i = t.merge;
        t.defaultOptions = {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
                loading: "Loading...",
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " "
            },
            global: {},
            time: t.Time.prototype.defaultOptions,
            chart: {
                styledMode: !1,
                borderRadius: 0,
                colorCount: 10,
                defaultSeriesType: "line",
                ignoreHiddenSeries: !0,
                spacing: [10, 10, 15, 10],
                resetZoomButton: {theme: {zIndex: 6}, position: {align: "right", x: -10, y: 10}},
                width: null,
                height: null,
                borderColor: "#335cad",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {text: "Chart title", align: "center", margin: 15, widthAdjust: -44},
            subtitle: {text: "", align: "center", widthAdjust: -44},
            caption: {margin: 15, text: "", align: "left", verticalAlign: "bottom"},
            plotOptions: {},
            labels: {style: {position: "absolute", color: "#333333"}},
            legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                layout: "horizontal",
                labelFormatter: function () {
                    return this.name
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {activeColor: "#003399", inactiveColor: "#cccccc"},
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "12px",
                    fontWeight: "bold",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {color: "#000000"},
                itemHiddenStyle: {color: "#cccccc"},
                shadow: !1,
                itemCheckboxStyle: {position: "absolute", width: "13px", height: "13px"},
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {style: {fontWeight: "bold"}}
            },
            loading: {
                labelStyle: {fontWeight: "bold", position: "relative", top: "45%"},
                style: {position: "absolute", backgroundColor: "#ffffff", opacity: .5, textAlign: "center"}
            },
            tooltip: {
                enabled: !0,
                animation: t.svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%A, %b %e, %H:%M:%S.%L",
                    second: "%A, %b %e, %H:%M:%S",
                    minute: "%A, %b %e, %H:%M",
                    hour: "%A, %b %e, %H:%M",
                    day: "%A, %b %e, %Y",
                    week: "Week from %A, %b %e, %Y",
                    month: "%B %Y",
                    year: "%Y"
                },
                footerFormat: "",
                padding: 8,
                snap: t.isTouchDevice ? 25 : 10,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: e("#f7f7f7").setOpacity(.85).get(),
                borderWidth: 1,
                shadow: !0,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "12px",
                    pointerEvents: "none",
                    whiteSpace: "nowrap"
                }
            },
            credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {align: "right", x: -10, verticalAlign: "bottom", y: -5},
                style: {cursor: "pointer", color: "#999999", fontSize: "9px"},
                text: "Highcharts.com"
            }
        }, t.setOptions = function (e) {
            return t.defaultOptions = i(!0, t.defaultOptions, e), t.time.update(i(t.defaultOptions.global, t.defaultOptions.time), !1), t.defaultOptions
        }, t.getOptions = function () {
            return t.defaultOptions
        }, t.defaultPlotOptions = t.defaultOptions.plotOptions, t.time = new t.Time(i(t.defaultOptions.global, t.defaultOptions.time)), t.dateFormat = function (e, i, n) {
            return t.time.dateFormat(e, i, n)
        }
    }), e(i, "parts/Tick.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = t.correctFloat, o = t.destroyObjectProperties, a = t.fireEvent,
            s = t.merge, l = t.pick, h = t.deg2rad;
        t.Tick = function (t, e, i, n, r) {
            this.axis = t, this.pos = e, this.type = i || "", this.isNewLabel = this.isNew = !0, this.parameters = r || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, i || n || this.addLabel()
        }, t.Tick.prototype = {
            addLabel: function () {
                var e = this, n = e.axis, o = n.options, a = n.chart, h = n.categories, c = n.names, u = e.pos,
                    d = l(e.options && e.options.labels, o.labels), f = n.tickPositions, p = u === f[0],
                    g = u === f[f.length - 1];
                h = this.parameters.category || (h ? l(h[u], c[u], u) : u);
                var m, v, y = e.label;
                if (f = f.info, n.isDatetimeAxis && f) var x = a.time.resolveDTLFormat(o.dateTimeLabelFormats[!o.grid && f.higherRanks[u] || f.unitName]),
                    b = x.main;
                e.isFirst = p, e.isLast = g, e.formatCtx = {
                    axis: n,
                    chart: a,
                    isFirst: p,
                    isLast: g,
                    dateTimeLabelFormat: b,
                    tickPositionInfo: f,
                    value: n.isLog ? r(n.lin2log(h)) : h,
                    pos: u
                }, o = n.labelFormatter.call(e.formatCtx, this.formatCtx), (v = x && x.list) && (e.shortenLabel = function () {
                    for (m = 0; m < v.length; m++) if (y.attr({text: n.labelFormatter.call(t.extend(e.formatCtx, {dateTimeLabelFormat: v[m]}))}), y.getBBox().width < n.getSlotWidth(e) - 2 * l(d.padding, 5)) return;
                    y.attr({text: ""})
                }), i(y) ? y && y.textStr !== o && (!y.textWidth || d.style && d.style.width || y.styles.width || y.css({width: null}), y.attr({text: o}), y.textPxLength = y.getBBox().width) : ((e.label = y = i(o) && d.enabled ? a.renderer.text(o, 0, 0, d.useHTML).add(n.labelGroup) : null) && (a.styledMode || y.css(s(d.style)), y.textPxLength = y.getBBox().width), e.rotation = 0)
            }, getLabelSize: function () {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
            }, handleOverflow: function (t) {
                var e = this.axis, i = e.options.labels, n = t.x, r = e.chart.chartWidth, o = e.chart.spacing,
                    a = l(e.labelLeft, Math.min(e.pos, o[3]));
                o = l(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - o[1]));
                var s, c = this.label, u = this.rotation,
                    d = {left: 0, center: .5, right: 1}[e.labelAlign || c.attr("align")], f = c.getBBox().width,
                    p = e.getSlotWidth(this), g = p, m = 1, v = {};
                u || "justify" !== l(i.overflow, "justify") ? 0 > u && n - d * f < a ? s = Math.round(n / Math.cos(u * h) - a) : 0 < u && n + d * f > o && (s = Math.round((r - n) / Math.cos(u * h))) : (r = n + (1 - d) * f, n - d * f < a ? g = t.x + g * (1 - d) - a : r > o && (g = o - t.x + g * d, m = -1), (g = Math.min(p, g)) < p && "center" === e.labelAlign && (t.x += m * (p - g - d * (p - Math.min(f, g)))), (f > g || e.autoRotation && (c.styles || {}).width) && (s = g)), s && (this.shortenLabel ? this.shortenLabel() : (v.width = Math.floor(s), (i.style || {}).textOverflow || (v.textOverflow = "ellipsis"), c.css(v)))
            }, getPosition: function (e, i, n, r) {
                var o = this.axis, s = o.chart, l = r && s.oldChartHeight || s.chartHeight;
                return (e = {
                    x: e ? t.correctFloat(o.translate(i + n, null, null, r) + o.transB) : o.left + o.offset + (o.opposite ? (r && s.oldChartWidth || s.chartWidth) - o.right - o.left : 0),
                    y: e ? l - o.bottom + o.offset - (o.opposite ? o.height : 0) : t.correctFloat(l - o.translate(i + n, null, null, r) - o.transB)
                }).y = Math.max(Math.min(e.y, 1e5), -1e5), a(this, "afterGetPosition", {pos: e}), e
            }, getLabelPosition: function (t, e, n, r, o, s, l, c) {
                var u = this.axis, d = u.transA,
                    f = u.isLinked && u.linkedParent ? u.linkedParent.reversed : u.reversed, p = u.staggerLines,
                    g = u.tickRotCorr || {x: 0, y: 0}, m = o.y,
                    v = r || u.reserveSpaceDefault ? 0 : -u.labelOffset * ("center" === u.labelAlign ? .5 : 1), y = {};
                return i(m) || (m = 0 === u.side ? n.rotation ? -8 : -n.getBBox().height : 2 === u.side ? g.y + 8 : Math.cos(n.rotation * h) * (g.y - n.getBBox(!1, 0).height / 2)), t = t + o.x + v + g.x - (s && r ? s * d * (f ? -1 : 1) : 0), e = e + m - (s && !r ? s * d * (f ? 1 : -1) : 0), p && (n = l / (c || 1) % p, u.opposite && (n = p - n - 1), e += u.labelOffset / p * n), y.x = t, y.y = Math.round(e), a(this, "afterGetLabelPosition", {
                    pos: y,
                    tickmarkOffset: s,
                    index: l
                }), y
            }, getMarkPath: function (t, e, i, n, r, o) {
                return o.crispLine(["M", t, e, "L", t + (r ? 0 : -i), e + (r ? i : 0)], n)
            }, renderGridLine: function (t, e, i) {
                var n = this.axis, r = n.options, o = this.gridLine, a = {}, s = this.pos, h = this.type,
                    c = l(this.tickmarkOffset, n.tickmarkOffset), u = n.chart.renderer, d = h ? h + "Grid" : "grid",
                    f = r[d + "LineWidth"], p = r[d + "LineColor"];
                r = r[d + "LineDashStyle"], o || (n.chart.styledMode || (a.stroke = p, a["stroke-width"] = f, r && (a.dashstyle = r)), h || (a.zIndex = 1), t && (e = 0), this.gridLine = o = u.path().attr(a).addClass("highcharts-" + (h ? h + "-" : "") + "grid-line").add(n.gridGroup)), o && (i = n.getPlotLinePath({
                    value: s + c,
                    lineWidth: o.strokeWidth() * i,
                    force: "pass",
                    old: t
                })) && o[t || this.isNew ? "attr" : "animate"]({d: i, opacity: e})
            }, renderMark: function (t, e, i) {
                var n = this.axis, r = n.options, o = n.chart.renderer, a = this.type, s = a ? a + "Tick" : "tick",
                    h = n.tickSize(s), c = this.mark, u = !c, d = t.x;
                t = t.y;
                var f = l(r[s + "Width"], !a && n.isXAxis ? 1 : 0);
                r = r[s + "Color"], h && (n.opposite && (h[0] = -h[0]), u && (this.mark = c = o.path().addClass("highcharts-" + (a ? a + "-" : "") + "tick").add(n.axisGroup), n.chart.styledMode || c.attr({
                    stroke: r,
                    "stroke-width": f
                })), c[u ? "attr" : "animate"]({
                    d: this.getMarkPath(d, t, h[0], c.strokeWidth() * i, n.horiz, o),
                    opacity: e
                }))
            }, renderLabel: function (t, e, i, r) {
                var o = this.axis, a = o.horiz, s = o.options, h = this.label, c = s.labels, u = c.step;
                o = l(this.tickmarkOffset, o.tickmarkOffset);
                var d = !0, f = t.x;
                t = t.y, h && n(f) && (h.xy = t = this.getLabelPosition(f, t, h, a, c, o, r, u), this.isFirst && !this.isLast && !l(s.showFirstLabel, 1) || this.isLast && !this.isFirst && !l(s.showLastLabel, 1) ? d = !1 : !a || c.step || c.rotation || e || 0 === i || this.handleOverflow(t), u && r % u && (d = !1), d && n(t.y) ? (t.opacity = i, h[this.isNewLabel ? "attr" : "animate"](t), this.isNewLabel = !1) : (h.attr("y", -9999), this.isNewLabel = !0))
            }, render: function (e, i, n) {
                var r = this.axis, o = r.horiz, a = this.pos, s = l(this.tickmarkOffset, r.tickmarkOffset);
                s = (a = this.getPosition(o, a, s, i)).x;
                var h = a.y;
                r = o && s === r.pos + r.len || !o && h === r.pos ? -1 : 1, n = l(n, 1), this.isActive = !0, this.renderGridLine(i, n, r), this.renderMark(a, n, r), this.renderLabel(a, i, n, e), this.isNew = !1, t.fireEvent(this, "afterRender")
            }, destroy: function () {
                o(this, this.axis)
            }
        }
    }), e(i, "parts/Axis.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isArray, r = e.isNumber, o = e.isString, a = e.objectEach, s = e.splat, l = t.addEvent,
            h = t.animObject, c = t.arrayMax, u = t.arrayMin, d = t.color, f = t.correctFloat, p = t.defaultOptions,
            g = t.deg2rad, m = t.destroyObjectProperties, v = t.extend, y = t.fireEvent, x = t.format,
            b = t.getMagnitude, M = t.merge, A = t.normalizeTickInterval, w = t.pick, k = t.removeEvent,
            S = t.seriesTypes, T = t.syncTimeout, E = t.Tick;
        return e = function () {
            this.init.apply(this, arguments)
        }, t.extend(e.prototype, {
            defaultOptions: {
                dateTimeLabelFormats: {
                    millisecond: {main: "%H:%M:%S.%L", range: !1},
                    second: {main: "%H:%M:%S", range: !1},
                    minute: {main: "%H:%M", range: !1},
                    hour: {main: "%H:%M", range: !1},
                    day: {main: "%e. %b"},
                    week: {main: "%e. %b"},
                    month: {main: "%b '%y"},
                    year: {main: "%Y"}
                },
                endOnTick: !1,
                labels: {
                    enabled: !0,
                    indentation: 10,
                    x: 0,
                    style: {color: "#666666", cursor: "default", fontSize: "11px"}
                },
                maxPadding: .01,
                minorTickLength: 2,
                minorTickPosition: "outside",
                minPadding: .01,
                showEmpty: !0,
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {align: "middle", style: {color: "#666666"}},
                type: "linear",
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#ccd6eb",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                tickColor: "#ccd6eb"
            },
            defaultYAxisOptions: {
                endOnTick: !0,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {x: -8},
                startOnTick: !0,
                title: {rotation: 270, text: "Values"},
                stackLabels: {
                    allowOverlap: !1, enabled: !1, crop: !0, overflow: "justify", formatter: function () {
                        return t.numberFormat(this.total, -1)
                    }, style: {color: "#000000", fontSize: "11px", fontWeight: "bold", textOutline: "1px contrast"}
                },
                gridLineWidth: 1,
                lineWidth: 0
            },
            defaultLeftAxisOptions: {labels: {x: -15}, title: {rotation: 270}},
            defaultRightAxisOptions: {labels: {x: 15}, title: {rotation: 90}},
            defaultBottomAxisOptions: {labels: {autoRotation: [-45], x: 0}, margin: 15, title: {rotation: 0}},
            defaultTopAxisOptions: {labels: {autoRotation: [-45], x: 0}, margin: 15, title: {rotation: 0}},
            init: function (e, n) {
                var r = n.isX, o = this;
                o.chart = e, o.horiz = e.inverted && !o.isZAxis ? !r : r, o.isXAxis = r, o.coll = o.coll || (r ? "xAxis" : "yAxis"), y(this, "init", {userOptions: n}), o.opposite = n.opposite, o.side = n.side || (o.horiz ? o.opposite ? 0 : 2 : o.opposite ? 1 : 3), o.setOptions(n);
                var h = this.options, c = h.type;
                o.labelFormatter = h.labels.formatter || o.defaultLabelFormatter, o.userOptions = n, o.minPixelPadding = 0, o.reversed = h.reversed, o.visible = !1 !== h.visible, o.zoomEnabled = !1 !== h.zoomEnabled, o.hasNames = "category" === c || !0 === h.categories, o.categories = h.categories || o.hasNames, o.names || (o.names = [], o.names.keys = {}), o.plotLinesAndBandsGroups = {}, o.isLog = "logarithmic" === c, o.isDatetimeAxis = "datetime" === c, o.positiveValuesOnly = o.isLog && !o.allowNegativeLog, o.isLinked = i(h.linkedTo), o.ticks = {}, o.labelEdge = [], o.minorTicks = {}, o.plotLinesAndBands = [], o.alternateBands = {}, o.len = 0, o.minRange = o.userMinRange = h.minRange || h.maxZoom, o.range = h.range, o.offset = h.offset || 0, o.stacks = {}, o.oldStacks = {}, o.stacksTouched = 0, o.max = null, o.min = null, o.crosshair = w(h.crosshair, s(e.options.tooltip.crosshairs)[r ? 0 : 1], !1), n = o.options.events, -1 === e.axes.indexOf(o) && (r ? e.axes.splice(e.xAxis.length, 0, o) : e.axes.push(o), e[o.coll].push(o)), o.series = o.series || [], e.inverted && !o.isZAxis && r && void 0 === o.reversed && (o.reversed = !0), a(n, function (e, i) {
                    t.isFunction(e) && l(o, i, e)
                }), o.lin2log = h.linearToLogConverter || o.lin2log, o.isLog && (o.val2lin = o.log2lin, o.lin2val = o.lin2log), y(this, "afterInit")
            },
            setOptions: function (t) {
                this.options = M(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], M(p[this.coll], t)), y(this, "afterSetOptions", {userOptions: t})
            },
            defaultLabelFormatter: function () {
                var e = this.axis, i = this.value, n = e.chart.time, r = e.categories, o = this.dateTimeLabelFormat,
                    a = p.lang, s = a.numericSymbols;
                a = a.numericSymbolMagnitude || 1e3;
                var l = s && s.length, h = e.options.labels.format;
                if (e = e.isLog ? Math.abs(i) : e.tickInterval, h) var c = x(h, this, n); else if (r) c = i; else if (o) c = n.dateFormat(o, i); else if (l && 1e3 <= e) for (; l-- && void 0 === c;) e >= (n = Math.pow(a, l + 1)) && 0 == 10 * i % n && null !== s[l] && 0 !== i && (c = t.numberFormat(i / n, -1) + s[l]);
                return void 0 === c && (c = 1e4 <= Math.abs(i) ? t.numberFormat(i, -1) : t.numberFormat(i, -1, void 0, "")), c
            },
            getSeriesExtremes: function () {
                var t, e = this, n = e.chart;
                y(this, "getSeriesExtremes", null, function () {
                    e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = null, e.softThreshold = !e.isXAxis, e.buildStacks && e.buildStacks(), e.series.forEach(function (o) {
                        if (o.visible || !n.options.chart.ignoreHiddenSeries) {
                            var a = o.options, s = a.threshold;
                            if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= s && (s = null), e.isXAxis) {
                                if ((a = o.xData).length) {
                                    var l = (t = o.getXExtremes(a)).min, h = t.max;
                                    r(l) || l instanceof Date || (a = a.filter(r), l = (t = o.getXExtremes(a)).min, h = t.max), a.length && (e.dataMin = Math.min(w(e.dataMin, l), l), e.dataMax = Math.max(w(e.dataMax, h), h))
                                }
                            } else o.getExtremes(), h = o.dataMax, l = o.dataMin, i(l) && i(h) && (e.dataMin = Math.min(w(e.dataMin, l), l), e.dataMax = Math.max(w(e.dataMax, h), h)), i(s) && (e.threshold = s), (!a.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1)
                        }
                    })
                }), y(this, "afterGetSeriesExtremes")
            },
            translate: function (t, e, i, n, o, a) {
                var s = this.linkedParent || this, l = 1, h = 0, c = n ? s.oldTransA : s.transA;
                n = n ? s.oldMin : s.min;
                var u = s.minPixelPadding;
                return o = (s.isOrdinal || s.isBroken || s.isLog && o) && s.lin2val, c || (c = s.transA), i && (l *= -1, h = s.len), s.reversed && (h -= (l *= -1) * (s.sector || s.len)), e ? (t = (t * l + h - u) / c + n, o && (t = s.lin2val(t))) : (o && (t = s.val2lin(t)), t = r(n) ? l * (t - n) * c + h + l * u + (r(a) ? c * a : 0) : void 0), t
            },
            toPixels: function (t, e) {
                return this.translate(t, !1, !this.horiz, null, !0) + (e ? 0 : this.pos)
            },
            toValue: function (t, e) {
                return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, null, !0)
            },
            getPlotLinePath: function (t) {
                var e, i, n, o, a, s = this, l = s.chart, h = s.left, c = s.top, u = t.old, d = t.value,
                    f = t.translatedValue, p = t.lineWidth, g = t.force, m = u && l.oldChartHeight || l.chartHeight,
                    v = u && l.oldChartWidth || l.chartWidth, x = s.transB, b = function (t, e, i) {
                        return ("pass" !== g && t < e || t > i) && (g ? t = Math.min(Math.max(e, t), i) : a = !0), t
                    };
                return t = {
                    value: d,
                    lineWidth: p,
                    old: u,
                    force: g,
                    acrossPanes: t.acrossPanes,
                    translatedValue: f
                }, y(this, "getPlotLinePath", t, function (t) {
                    f = w(f, s.translate(d, null, null, u)), f = Math.min(Math.max(-1e5, f), 1e5), e = n = Math.round(f + x), i = o = Math.round(m - f - x), r(f) ? s.horiz ? (i = c, o = m - s.bottom, e = n = b(e, h, h + s.width)) : (e = h, n = v - s.right, i = o = b(i, c, c + s.height)) : (a = !0, g = !1), t.path = a && !g ? null : l.renderer.crispLine(["M", e, i, "L", n, o], p || 1)
                }), t.path
            },
            getLinearTickPositions: function (t, e, i) {
                var n = f(Math.floor(e / t) * t);
                i = f(Math.ceil(i / t) * t);
                var r, o = [];
                if (f(n + t) === n && (r = 20), this.single) return [e];
                for (e = n; e <= i && (o.push(e), (e = f(e + t, r)) !== a);) var a = e;
                return o
            },
            getMinorTickInterval: function () {
                var t = this.options;
                return !0 === t.minorTicks ? w(t.minorTickInterval, "auto") : !1 === t.minorTicks ? null : t.minorTickInterval
            },
            getMinorTickPositions: function () {
                var t = this, e = t.options, i = t.tickPositions, n = t.minorTickInterval, r = [],
                    o = t.pointRangePadding || 0, a = t.min - o, s = (o = t.max + o) - a;
                if (s && s / n < t.len / 3) if (t.isLog) this.paddedTicks.forEach(function (e, i, o) {
                    i && r.push.apply(r, t.getLogTickPositions(n, o[i - 1], o[i], !0))
                }); else if (t.isDatetimeAxis && "auto" === this.getMinorTickInterval()) r = r.concat(t.getTimeTicks(t.normalizeTimeTickInterval(n), a, o, e.startOfWeek)); else for (e = a + (i[0] - a) % n; e <= o && e !== r[0]; e += n) r.push(e);
                return 0 !== r.length && t.trimTicks(r), r
            },
            adjustForMinRange: function () {
                var t, e, n, r, o = this.options, a = this.min, s = this.max;
                if (this.isXAxis && void 0 === this.minRange && !this.isLog && (i(o.min) || i(o.max) ? this.minRange = null : (this.series.forEach(function (i) {
                    for (r = i.xData, e = i.xIncrement ? 1 : r.length - 1; 0 < e; e--) n = r[e] - r[e - 1], (void 0 === t || n < t) && (t = n)
                }), this.minRange = Math.min(5 * t, this.dataMax - this.dataMin))), s - a < this.minRange) {
                    var l = this.dataMax - this.dataMin >= this.minRange, h = this.minRange, d = (h - s + a) / 2;
                    d = [a - d, w(o.min, a - d)], l && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), s = [(a = c(d)) + h, w(o.max, a + h)], l && (s[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), (s = u(s)) - a < h && (d[0] = s - h, d[1] = w(o.min, s - h), a = c(d))
                }
                this.min = a, this.max = s
            },
            getClosest: function () {
                var t;
                return this.categories ? t = 1 : this.series.forEach(function (e) {
                    var n = e.closestPointRange, r = e.visible || !e.chart.options.chart.ignoreHiddenSeries;
                    !e.noSharedTooltip && i(n) && r && (t = i(t) ? Math.min(t, n) : n)
                }), t
            },
            nameToX: function (t) {
                var e = n(this.categories), r = e ? this.categories : this.names, o = t.options.x;
                if (t.series.requireSorting = !1, i(o) || (o = !1 === this.options.uniqueNames ? t.series.autoIncrement() : e ? r.indexOf(t.name) : w(r.keys[t.name], -1)), -1 === o) {
                    if (!e) var a = r.length
                } else a = o;
                return void 0 !== a && (this.names[a] = t.name, this.names.keys[t.name] = a), a
            },
            updateNames: function () {
                var t = this, e = this.names;
                0 < e.length && (Object.keys(e.keys).forEach(function (t) {
                    delete e.keys[t]
                }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {
                    e.xIncrement = null, e.points && !e.isDirtyData || (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function (i, n) {
                        if (i && i.options && void 0 !== i.name) {
                            var r = t.nameToX(i);
                            void 0 !== r && r !== i.x && (i.x = r, e.xData[n] = r)
                        }
                    })
                }))
            },
            setAxisTranslation: function (t) {
                var e = this, i = e.max - e.min, n = e.axisPointRange || 0, r = 0, a = 0, s = e.linkedParent,
                    l = !!e.categories, h = e.transA, c = e.isXAxis;
                if (c || l || n) {
                    var u = e.getClosest();
                    s ? (r = s.minPointOffset, a = s.pointRangePadding) : e.series.forEach(function (t) {
                        var i = l ? 1 : c ? w(t.options.pointRange, u, 0) : e.axisPointRange || 0,
                            s = t.options.pointPlacement;
                        n = Math.max(n, i), e.single && !l || (t = S.xrange && t instanceof S.xrange ? !c : c, r = Math.max(r, t && o(s) ? 0 : i / 2), a = Math.max(a, t && "on" === s ? 0 : i))
                    }), s = e.ordinalSlope && u ? e.ordinalSlope / u : 1, e.minPointOffset = r *= s, e.pointRangePadding = a *= s, e.pointRange = Math.min(n, i), c && (e.closestPointRange = u)
                }
                t && (e.oldTransA = h), e.translationSlope = e.transA = h = e.staticScale || e.len / (i + a || 1), e.transB = e.horiz ? e.left : e.bottom, e.minPixelPadding = h * r, y(this, "afterSetAxisTranslation")
            },
            minFromRange: function () {
                return this.max - this.range
            },
            setTickInterval: function (e) {
                var n = this, o = n.chart, a = n.options, s = n.isLog, l = n.isDatetimeAxis, h = n.isXAxis,
                    c = n.isLinked, u = a.maxPadding, d = a.minPadding, p = a.tickInterval, g = a.tickPixelInterval,
                    m = n.categories, v = r(n.threshold) ? n.threshold : null, x = n.softThreshold;
                l || m || c || this.getTickAmount();
                var M = w(n.userMin, a.min), k = w(n.userMax, a.max);
                if (c) {
                    n.linkedParent = o[n.coll][a.linkedTo];
                    var S = n.linkedParent.getExtremes();
                    n.min = w(S.min, S.dataMin), n.max = w(S.max, S.dataMax), a.type !== n.linkedParent.options.type && t.error(11, 1, o)
                } else {
                    if (!x && i(v)) if (n.dataMin >= v) S = v, d = 0; else if (n.dataMax <= v) {
                        var T = v;
                        u = 0
                    }
                    n.min = w(M, S, n.dataMin), n.max = w(k, T, n.dataMax)
                }
                s && (n.positiveValuesOnly && !e && 0 >= Math.min(n.min, w(n.dataMin, n.min)) && t.error(10, 1, o), n.min = f(n.log2lin(n.min), 15), n.max = f(n.log2lin(n.max), 15)), n.range && i(n.max) && (n.userMin = n.min = M = Math.max(n.dataMin, n.minFromRange()), n.userMax = k = n.max, n.range = null), y(n, "foundExtremes"), n.beforePadding && n.beforePadding(), n.adjustForMinRange(), !(m || n.axisPointRange || n.usePercentage || c) && i(n.min) && i(n.max) && (o = n.max - n.min) && (!i(M) && d && (n.min -= o * d), !i(k) && u && (n.max += o * u)), r(a.softMin) && !r(n.userMin) && a.softMin < n.min && (n.min = M = a.softMin), r(a.softMax) && !r(n.userMax) && a.softMax > n.max && (n.max = k = a.softMax), r(a.floor) && (n.min = Math.min(Math.max(n.min, a.floor), Number.MAX_VALUE)), r(a.ceiling) && (n.max = Math.max(Math.min(n.max, a.ceiling), w(n.userMax, -Number.MAX_VALUE))), x && i(n.dataMin) && (v = v || 0, !i(M) && n.min < v && n.dataMin >= v ? n.min = n.options.minRange ? Math.min(v, n.max - n.minRange) : v : !i(k) && n.max > v && n.dataMax <= v && (n.max = n.options.minRange ? Math.max(v, n.min + n.minRange) : v)), n.tickInterval = n.min === n.max || void 0 === n.min || void 0 === n.max ? 1 : c && !p && g === n.linkedParent.options.tickPixelInterval ? p = n.linkedParent.tickInterval : w(p, this.tickAmount ? (n.max - n.min) / Math.max(this.tickAmount - 1, 1) : void 0, m ? 1 : (n.max - n.min) * g / Math.max(n.len, g)), h && !e && n.series.forEach(function (t) {
                    t.processData(n.min !== n.oldMin || n.max !== n.oldMax)
                }), n.setAxisTranslation(!0), n.beforeSetTickPositions && n.beforeSetTickPositions(), n.postProcessTickInterval && (n.tickInterval = n.postProcessTickInterval(n.tickInterval)), n.pointRange && !p && (n.tickInterval = Math.max(n.pointRange, n.tickInterval)), e = w(a.minTickInterval, n.isDatetimeAxis && n.closestPointRange), !p && n.tickInterval < e && (n.tickInterval = e), l || s || p || (n.tickInterval = A(n.tickInterval, null, b(n.tickInterval), w(a.allowDecimals, !(.5 < n.tickInterval && 5 > n.tickInterval && 1e3 < n.max && 9999 > n.max)), !!this.tickAmount)), this.tickAmount || (n.tickInterval = n.unsquish()), this.setTickPositions()
            },
            setTickPositions: function () {
                var e = this.options, n = e.tickPositions, r = this.getMinorTickInterval(), o = e.tickPositioner,
                    a = e.startOnTick, s = e.endOnTick;
                this.tickmarkOffset = this.categories && "between" === e.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = "auto" === r && this.tickInterval ? this.tickInterval / 5 : r, this.single = this.min === this.max && i(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== e.allowDecimals), this.tickPositions = r = n && n.slice(), !r && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (r = [this.min, this.max], t.error(19, !1, this.chart)) : r = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, e.units), this.min, this.max, e.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), r.length > this.len && ((r = [r[0], r.pop()])[0] === r[1] && (r.length = 1)), this.tickPositions = r, o && (o = o.apply(this, [this.min, this.max]))) && (this.tickPositions = r = o), this.paddedTicks = r.slice(0), this.trimTicks(r, a, s), this.isLinked || (this.single && 2 > r.length && !this.categories && (this.min -= .5, this.max += .5), n || o || this.adjustTickAmount()), y(this, "afterSetTickPositions")
            },
            trimTicks: function (t, e, n) {
                var r = t[0], o = t[t.length - 1], a = this.minPointOffset || 0;
                if (y(this, "trimTicks"), !this.isLinked) {
                    if (e && -1 / 0 !== r) this.min = r; else for (; this.min - a > t[0];) t.shift();
                    if (n) this.max = o; else for (; this.max + a < t[t.length - 1];) t.pop();
                    0 === t.length && i(r) && !this.options.tickPositions && t.push((o + r) / 2)
                }
            },
            alignToOthers: function () {
                var t, e = {}, i = this.options;
                return !1 === this.chart.options.chart.alignTicks || !1 === i.alignTicks || !1 === i.startOnTick || !1 === i.endOnTick || this.isLog || this.chart[this.coll].forEach(function (i) {
                    var n = i.options;
                    n = [i.horiz ? n.left : n.top, n.width, n.height, n.pane].join(), i.series.length && (e[n] ? t = !0 : e[n] = 1)
                }), t
            },
            getTickAmount: function () {
                var t = this.options, e = t.tickAmount, n = t.tickPixelInterval;
                !i(t.tickInterval) && this.len < n && !this.isRadial && !this.isLog && t.startOnTick && t.endOnTick && (e = 2), !e && this.alignToOthers() && (e = Math.ceil(this.len / n) + 1), 4 > e && (this.finalTickAmt = e, e = 5), this.tickAmount = e
            },
            adjustTickAmount: function () {
                var t, e = this.options, n = this.tickInterval, r = this.tickPositions, o = this.tickAmount,
                    a = this.finalTickAmt, s = r && r.length, l = w(this.threshold, this.softThreshold ? 0 : null);
                if (this.hasData()) {
                    if (s < o) {
                        for (t = this.min; r.length < o;) r.length % 2 || t === l ? r.push(f(r[r.length - 1] + n)) : r.unshift(f(r[0] - n));
                        this.transA *= (s - 1) / (o - 1), this.min = e.startOnTick ? r[0] : Math.min(this.min, r[0]), this.max = e.endOnTick ? r[r.length - 1] : Math.max(this.max, r[r.length - 1])
                    } else s > o && (this.tickInterval *= 2, this.setTickPositions());
                    if (i(a)) {
                        for (n = e = r.length; n--;) (3 === a && 1 == n % 2 || 2 >= a && 0 < n && n < e - 1) && r.splice(n, 1);
                        this.finalTickAmt = void 0
                    }
                }
            },
            setScale: function () {
                var t, e = this.series.some(function (t) {
                    return t.isDirtyData || t.isDirty || t.xAxis && t.xAxis.isDirty
                });
                this.oldMin = this.min, this.oldMax = this.max, this.oldAxisLength = this.len, this.setAxisSize(), (t = this.len !== this.oldAxisLength) || e || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = t || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks(), y(this, "afterSetScale")
            },
            setExtremes: function (t, e, i, n, r) {
                var o = this, a = o.chart;
                i = w(i, !0), o.series.forEach(function (t) {
                    delete t.kdTree
                }), r = v(r, {min: t, max: e}), y(o, "setExtremes", r, function () {
                    o.userMin = t, o.userMax = e, o.eventArgs = r, i && a.redraw(n)
                })
            },
            zoom: function (t, e) {
                var n = this.dataMin, r = this.dataMax, o = this.options, a = Math.min(n, w(o.min, n)),
                    s = Math.max(r, w(o.max, r));
                return y(this, "zoom", t = {newMin: t, newMax: e}, function (t) {
                    var e = t.newMin, o = t.newMax;
                    e === this.min && o === this.max || (this.allowZoomOutside || (i(n) && (e < a && (e = a), e > s && (e = s)), i(r) && (o < a && (o = a), o > s && (o = s))), this.displayBtn = void 0 !== e || void 0 !== o, this.setExtremes(e, o, !1, void 0, {trigger: "zoom"})), t.zoomed = !0
                }), t.zoomed
            },
            setAxisSize: function () {
                var e = this.chart, i = this.options, n = i.offsets || [0, 0, 0, 0], r = this.horiz,
                    o = this.width = Math.round(t.relativeLength(w(i.width, e.plotWidth - n[3] + n[1]), e.plotWidth)),
                    a = this.height = Math.round(t.relativeLength(w(i.height, e.plotHeight - n[0] + n[2]), e.plotHeight)),
                    s = this.top = Math.round(t.relativeLength(w(i.top, e.plotTop + n[0]), e.plotHeight, e.plotTop));
                i = this.left = Math.round(t.relativeLength(w(i.left, e.plotLeft + n[3]), e.plotWidth, e.plotLeft)), this.bottom = e.chartHeight - a - s, this.right = e.chartWidth - o - i, this.len = Math.max(r ? o : a, 0), this.pos = r ? i : s
            },
            getExtremes: function () {
                var t = this.isLog;
                return {
                    min: t ? f(this.lin2log(this.min)) : this.min,
                    max: t ? f(this.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                }
            },
            getThreshold: function (t) {
                var e = this.isLog, i = e ? this.lin2log(this.min) : this.min;
                return e = e ? this.lin2log(this.max) : this.max, null === t || -1 / 0 === t ? t = i : 1 / 0 === t ? t = e : i > t ? t = i : e < t && (t = e), this.translate(t, 0, 1, 0, 1)
            },
            autoLabelAlign: function (t) {
                var e = (w(t, 0) - 90 * this.side + 720) % 360;
                return y(this, "autoLabelAlign", t = {align: "center"}, function (t) {
                    15 < e && 165 > e ? t.align = "right" : 195 < e && 345 > e && (t.align = "left")
                }), t.align
            },
            tickSize: function (t) {
                var e = this.options, i = e[t + "Length"],
                    n = w(e[t + "Width"], "tick" === t && this.isXAxis && !this.categories ? 1 : 0);
                if (n && i) {
                    "inside" === e[t + "Position"] && (i = -i);
                    var r = [i, n]
                }
                return y(this, "afterTickSize", t = {tickSize: r}), t.tickSize
            },
            labelMetrics: function () {
                var t = this.tickPositions && this.tickPositions[0] || 0;
                return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[t] && this.ticks[t].label)
            },
            unsquish: function () {
                var t, e, n, r = this.options.labels, o = this.horiz, a = this.tickInterval, s = a,
                    l = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a), h = r.rotation,
                    c = this.labelMetrics(), u = Number.MAX_VALUE, d = this.max - this.min, p = function (t) {
                        var e = t / (l || 1);
                        return (e = 1 < e ? Math.ceil(e) : 1) * a > d && 1 / 0 !== t && 1 / 0 !== l && d && (e = Math.ceil(d / a)), f(e * a)
                    };
                return o ? (n = !r.staggerLines && !r.step && (i(h) ? [h] : l < w(r.autoRotationLimit, 80) && r.autoRotation)) && n.forEach(function (i) {
                    if (i === h || i && -90 <= i && 90 >= i) {
                        var n = (e = p(Math.abs(c.h / Math.sin(g * i)))) + Math.abs(i / 360);
                        n < u && (u = n, t = i, s = e)
                    }
                }) : r.step || (s = p(c.h)), this.autoRotation = n, this.labelRotation = w(t, h), s
            },
            getSlotWidth: function (t) {
                var e = this.chart, i = this.horiz, n = this.options.labels,
                    r = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), o = e.margin[3];
                return t && t.slotWidth || i && 2 > (n.step || 0) && !n.rotation && (this.staggerLines || 1) * this.len / r || !i && (n.style && parseInt(n.style.width, 10) || o && o - e.spacing[3] || .33 * e.chartWidth)
            },
            renderUnsquish: function () {
                var t = this.chart, e = t.renderer, i = this.tickPositions, n = this.ticks, r = this.options.labels,
                    a = r && r.style || {}, s = this.horiz, l = this.getSlotWidth(),
                    h = Math.max(1, Math.round(l - 2 * (r.padding || 5))), c = {}, u = this.labelMetrics(),
                    d = r.style && r.style.textOverflow, f = 0;
                if (o(r.rotation) || (c.rotation = r.rotation || 0), i.forEach(function (t) {
                    (t = n[t]) && t.label && t.label.textPxLength > f && (f = t.label.textPxLength)
                }), this.maxLabelLength = f, this.autoRotation) f > h && f > u.h ? c.rotation = this.labelRotation : this.labelRotation = 0; else if (l) {
                    var p = h;
                    if (!d) {
                        var g = "clip";
                        for (h = i.length; !s && h--;) {
                            var m = i[h];
                            (m = n[m].label) && (m.styles && "ellipsis" === m.styles.textOverflow ? m.css({textOverflow: "clip"}) : m.textPxLength > l && m.css({width: l + "px"}), m.getBBox().height > this.len / i.length - (u.h - u.f) && (m.specificTextOverflow = "ellipsis"))
                        }
                    }
                }
                c.rotation && (p = f > .5 * t.chartHeight ? .33 * t.chartHeight : f, d || (g = "ellipsis")), (this.labelAlign = r.align || this.autoLabelAlign(this.labelRotation)) && (c.align = this.labelAlign), i.forEach(function (t) {
                    var e = (t = n[t]) && t.label, i = a.width, r = {};
                    e && (e.attr(c), t.shortenLabel ? t.shortenLabel() : p && !i && "nowrap" !== a.whiteSpace && (p < e.textPxLength || "SPAN" === e.element.tagName) ? (r.width = p, d || (r.textOverflow = e.specificTextOverflow || g), e.css(r)) : e.styles && e.styles.width && !r.width && !i && e.css({width: null}), delete e.specificTextOverflow, t.rotation = c.rotation)
                }, this), this.tickRotCorr = e.rotCorr(u.b, this.labelRotation || 0, 0 !== this.side)
            },
            hasData: function () {
                return this.series.some(function (t) {
                    return t.hasData()
                }) || this.options.showEmpty && i(this.min) && i(this.max)
            },
            addTitle: function (t) {
                var e, i = this.chart.renderer, n = this.horiz, r = this.opposite, o = this.options.title,
                    a = this.chart.styledMode;
                this.axisTitle || ((e = o.textAlign) || (e = (n ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: r ? "right" : "left",
                    middle: "center",
                    high: r ? "left" : "right"
                })[o.align]), this.axisTitle = i.text(o.text, 0, 0, o.useHTML).attr({
                    zIndex: 7,
                    rotation: o.rotation || 0,
                    align: e
                }).addClass("highcharts-axis-title"), a || this.axisTitle.css(M(o.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || o.style.width || this.isRadial || this.axisTitle.css({width: this.len}), this.axisTitle[t ? "show" : "hide"](t)
            },
            generateTick: function (t) {
                var e = this.ticks;
                e[t] ? e[t].addLabel() : e[t] = new E(this, t)
            },
            getOffset: function () {
                var t, e = this, n = e.chart, r = n.renderer, o = e.options, s = e.tickPositions, l = e.ticks,
                    h = e.horiz, c = e.side, u = n.inverted && !e.isZAxis ? [1, 0, 3, 2][c] : c, d = 0, f = 0,
                    p = o.title, g = o.labels, m = 0, v = n.axisOffset;
                n = n.clipOffset;
                var x = [-1, 1, 1, -1][c], b = o.className, M = e.axisParent, A = e.hasData();
                if (e.showAxis = t = A || w(o.showEmpty, !0), e.staggerLines = e.horiz && g.staggerLines, e.axisGroup || (e.gridGroup = r.g("grid").attr({zIndex: o.gridZIndex || 1}).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (b || "")).add(M), e.axisGroup = r.g("axis").attr({zIndex: o.zIndex || 2}).addClass("highcharts-" + this.coll.toLowerCase() + " " + (b || "")).add(M), e.labelGroup = r.g("axis-labels").attr({zIndex: g.zIndex || 7}).addClass("highcharts-" + e.coll.toLowerCase() + "-labels " + (b || "")).add(M)), A || e.isLinked ? (s.forEach(function (t, i) {
                    e.generateTick(t, i)
                }), e.renderUnsquish(), e.reserveSpaceDefault = 0 === c || 2 === c || {
                    1: "left",
                    3: "right"
                }[c] === e.labelAlign, w(g.reserveSpace, "center" === e.labelAlign || null, e.reserveSpaceDefault) && s.forEach(function (t) {
                    m = Math.max(l[t].getLabelSize(), m)
                }), e.staggerLines && (m *= e.staggerLines), e.labelOffset = m * (e.opposite ? -1 : 1)) : a(l, function (t, e) {
                    t.destroy(), delete l[e]
                }), p && p.text && !1 !== p.enabled && (e.addTitle(t), t && !1 !== p.reserveSpace)) {
                    e.titleOffset = d = e.axisTitle.getBBox()[h ? "height" : "width"];
                    var k = p.offset;
                    f = i(k) ? 0 : w(p.margin, h ? 5 : 10)
                }
                e.renderLine(), e.offset = x * w(o.offset, v[c] ? v[c] + (o.margin || 0) : 0), e.tickRotCorr = e.tickRotCorr || {
                    x: 0,
                    y: 0
                }, r = 0 === c ? -e.labelMetrics().h : 2 === c ? e.tickRotCorr.y : 0, f = Math.abs(m) + f, m && (f = f - r + x * (h ? w(g.y, e.tickRotCorr.y + 8 * x) : g.x)), e.axisTitleMargin = w(k, f), e.getMaxLabelDimensions && (e.maxLabelDimensions = e.getMaxLabelDimensions(l, s)), h = this.tickSize("tick"), v[c] = Math.max(v[c], e.axisTitleMargin + d + x * e.offset, f, s && s.length && h ? h[0] + x * e.offset : 0), o = o.offset ? 0 : 2 * Math.floor(e.axisLine.strokeWidth() / 2), n[u] = Math.max(n[u], o), y(this, "afterGetOffset")
            },
            getLinePath: function (t) {
                var e = this.chart, i = this.opposite, n = this.offset, r = this.horiz,
                    o = this.left + (i ? this.width : 0) + n;
                return n = e.chartHeight - this.bottom - (i ? this.height : 0) + n, i && (t *= -1), e.renderer.crispLine(["M", r ? this.left : o, r ? n : this.top, "L", r ? e.chartWidth - this.right : o, r ? n : e.chartHeight - this.bottom], t)
            },
            renderLine: function () {
                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7
                }))
            },
            getTitlePosition: function () {
                var t = this.horiz, e = this.left, i = this.top, n = this.len, r = this.options.title, o = t ? e : i,
                    a = this.opposite, s = this.offset, l = r.x || 0, h = r.y || 0, c = this.axisTitle,
                    u = this.chart.renderer.fontMetrics(r.style && r.style.fontSize, c);
                return c = Math.max(c.getBBox(null, 0).height - u.h - 1, 0), n = {
                    low: o + (t ? 0 : n),
                    middle: o + n / 2,
                    high: o + (t ? n : 0)
                }[r.align], e = (t ? i + this.height : e) + (t ? 1 : -1) * (a ? -1 : 1) * this.axisTitleMargin + [-c, c, u.f, -c][this.side], t = {
                    x: t ? n + l : e + (a ? this.width : 0) + s + l,
                    y: t ? e + h - (a ? this.height : 0) + s : n + h
                }, y(this, "afterGetTitlePosition", {titlePosition: t}), t
            },
            renderMinorTick: function (t) {
                var e = this.chart.hasRendered && r(this.oldMin), i = this.minorTicks;
                i[t] || (i[t] = new E(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1)
            },
            renderTick: function (t, e) {
                var i = this.isLinked, n = this.ticks, o = this.chart.hasRendered && r(this.oldMin);
                (!i || t >= this.min && t <= this.max) && (n[t] || (n[t] = new E(this, t)), o && n[t].isNew && n[t].render(e, !0, -1), n[t].render(e))
            },
            render: function () {
                var e, i, n = this, o = n.chart, s = n.options, l = n.isLog, c = n.isLinked, u = n.tickPositions,
                    d = n.axisTitle, f = n.ticks, p = n.minorTicks, g = n.alternateBands, m = s.stackLabels,
                    v = s.alternateGridColor, x = n.tickmarkOffset, b = n.axisLine, M = n.showAxis,
                    A = h(o.renderer.globalAnimation);
                n.labelEdge.length = 0, n.overlap = !1, [f, p, g].forEach(function (t) {
                    a(t, function (t) {
                        t.isActive = !1
                    })
                }), (n.hasData() || c) && (n.minorTickInterval && !n.categories && n.getMinorTickPositions().forEach(function (t) {
                    n.renderMinorTick(t)
                }), u.length && (u.forEach(function (t, e) {
                    n.renderTick(t, e)
                }), x && (0 === n.min || n.single) && (f[-1] || (f[-1] = new E(n, -1, null, !0)), f[-1].render(-1))), v && u.forEach(function (r, a) {
                    i = void 0 !== u[a + 1] ? u[a + 1] + x : n.max - x, 0 == a % 2 && r < n.max && i <= n.max + (o.polar ? -x : x) && (g[r] || (g[r] = new t.PlotLineOrBand(n)), e = r + x, g[r].options = {
                        from: l ? n.lin2log(e) : e,
                        to: l ? n.lin2log(i) : i,
                        color: v
                    }, g[r].render(), g[r].isActive = !0)
                }), n._addedPlotLB || ((s.plotLines || []).concat(s.plotBands || []).forEach(function (t) {
                    n.addPlotBandOrLine(t)
                }), n._addedPlotLB = !0)), [f, p, g].forEach(function (t) {
                    var e, i = [], n = A.duration;
                    a(t, function (t, e) {
                        t.isActive || (t.render(e, !1, 0), t.isActive = !1, i.push(e))
                    }), T(function () {
                        for (e = i.length; e--;) t[i[e]] && !t[i[e]].isActive && (t[i[e]].destroy(), delete t[i[e]])
                    }, t !== g && o.hasRendered && n ? n : 0)
                }), b && (b[b.isPlaced ? "animate" : "attr"]({d: this.getLinePath(b.strokeWidth())}), b.isPlaced = !0, b[M ? "show" : "hide"](M)), d && M && (s = n.getTitlePosition(), r(s.y) ? (d[d.isNew ? "attr" : "animate"](s), d.isNew = !1) : (d.attr("y", -9999), d.isNew = !0)), m && m.enabled && n.renderStackTotals(), n.isDirty = !1, y(this, "afterRender")
            },
            redraw: function () {
                this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) {
                    t.render()
                })), this.series.forEach(function (t) {
                    t.isDirty = !0
                })
            },
            keepProps: "extKey hcEvents names series userMax userMin".split(" "),
            destroy: function (t) {
                var e, i = this, n = i.stacks, r = i.plotLinesAndBands;
                if (y(this, "destroy", {keepEvents: t}), t || k(i), a(n, function (t, e) {
                    m(t), n[e] = null
                }), [i.ticks, i.minorTicks, i.alternateBands].forEach(function (t) {
                    m(t)
                }), r) for (t = r.length; t--;) r[t].destroy();
                for (e in "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (t) {
                    i[t] && (i[t] = i[t].destroy())
                }), i.plotLinesAndBandsGroups) i.plotLinesAndBandsGroups[e] = i.plotLinesAndBandsGroups[e].destroy();
                a(i, function (t, e) {
                    -1 === i.keepProps.indexOf(e) && delete i[e]
                })
            },
            drawCrosshair: function (t, e) {
                var n, r, o = this.crosshair, a = w(o.snap, !0), s = this.cross;
                if (y(this, "drawCrosshair", {
                    e: t,
                    point: e
                }), t || (t = this.cross && this.cross.e), this.crosshair && !1 !== (i(e) || !a)) {
                    if (a ? i(e) && (r = w("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : r = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), i(r) && (n = this.getPlotLinePath({
                        value: e && (this.isXAxis ? e.x : w(e.stackY, e.y)),
                        translatedValue: r
                    }) || null), !i(n)) return void this.hideCrosshair();
                    a = this.categories && !this.isRadial, s || (this.cross = s = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + o.className).attr({zIndex: w(o.zIndex, 2)}).add(), this.chart.styledMode || (s.attr({
                        stroke: o.color || (a ? d("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                        "stroke-width": w(o.width, 1)
                    }).css({"pointer-events": "none"}), o.dashStyle && s.attr({dashstyle: o.dashStyle}))), s.show().attr({d: n}), a && !o.width && s.attr({"stroke-width": this.transA}), this.cross.e = t
                } else this.hideCrosshair();
                y(this, "afterDrawCrosshair", {e: t, point: e})
            },
            hideCrosshair: function () {
                this.cross && this.cross.hide(), y(this, "afterHideCrosshair")
            }
        }), t.Axis = e
    }), e(i, "parts/DateTimeAxis.js", [i["parts/Globals.js"]], function (t) {
        var e = t.Axis, i = t.getMagnitude, n = t.normalizeTickInterval, r = t.timeUnits;
        e.prototype.getTimeTicks = function () {
            return this.chart.time.getTimeTicks.apply(this.chart.time, arguments)
        }, e.prototype.normalizeTimeTickInterval = function (t, e) {
            var o = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
            e = o[o.length - 1];
            var a, s = r[e[0]], l = e[1];
            for (a = 0; a < o.length && (e = o[a], s = r[e[0]], l = e[1], !(o[a + 1] && t <= (s * l[l.length - 1] + r[o[a + 1][0]]) / 2)); a++) ;
            return s === r.year && t < 5 * s && (l = [1, 2, 5]), {
                unitRange: s,
                count: t = n(t / s, l, "year" === e[0] ? Math.max(i(t / s), 1) : 1),
                unitName: e[0]
            }
        }
    }), e(i, "parts/LogarithmicAxis.js", [i["parts/Globals.js"]], function (t) {
        var e = t.Axis, i = t.getMagnitude, n = t.normalizeTickInterval, r = t.pick;
        e.prototype.getLogTickPositions = function (t, e, o, a) {
            var s = this.options, l = this.len, h = [];
            if (a || (this._minorAutoInterval = null), .5 <= t) t = Math.round(t), h = this.getLinearTickPositions(t, e, o); else if (.08 <= t) {
                var c, u;
                for (l = Math.floor(e), s = .3 < t ? [1, 2, 4] : .15 < t ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; l < o + 1 && !u; l++) {
                    var d = s.length;
                    for (c = 0; c < d && !u; c++) {
                        var f = this.log2lin(this.lin2log(l) * s[c]);
                        f > e && (!a || p <= o) && void 0 !== p && h.push(p), p > o && (u = !0);
                        var p = f
                    }
                }
            } else e = this.lin2log(e), o = this.lin2log(o), t = a ? this.getMinorTickInterval() : s.tickInterval, t = r("auto" === t ? null : t, this._minorAutoInterval, s.tickPixelInterval / (a ? 5 : 1) * (o - e) / ((a ? l / this.tickPositions.length : l) || 1)), t = n(t, null, i(t)), h = this.getLinearTickPositions(t, e, o).map(this.log2lin), a || (this._minorAutoInterval = t / 5);
            return a || (this.tickInterval = t), h
        }, e.prototype.log2lin = function (t) {
            return Math.log(t) / Math.LN10
        }, e.prototype.lin2log = function (t) {
            return Math.pow(10, t)
        }
    }), e(i, "parts/PlotLineOrBand.js", [i["parts/Globals.js"], i["parts/Axis.js"], i["parts/Utilities.js"]], function (t, e, i) {
        var n = i.defined, r = i.erase, o = i.objectEach, a = t.arrayMax, s = t.arrayMin, l = t.destroyObjectProperties,
            h = t.merge, c = t.pick;
        t.PlotLineOrBand = function (t, e) {
            this.axis = t, e && (this.options = e, this.id = e.id)
        }, t.PlotLineOrBand.prototype = {
            render: function () {
                t.fireEvent(this, "render");
                var e = this, i = e.axis, r = i.horiz, a = e.options, s = a.label, l = e.label, u = a.to, d = a.from,
                    f = a.value, p = n(d) && n(u), g = n(f), m = e.svgElem, v = !m, y = [], x = a.color,
                    b = c(a.zIndex, 0), M = a.events;
                y = {class: "highcharts-plot-" + (p ? "band " : "line ") + (a.className || "")};
                var A = {}, w = i.chart.renderer, k = p ? "bands" : "lines";
                if (i.isLog && (d = i.log2lin(d), u = i.log2lin(u), f = i.log2lin(f)), i.chart.styledMode || (g ? (y.stroke = x || "#999999", y["stroke-width"] = c(a.width, 1), a.dashStyle && (y.dashstyle = a.dashStyle)) : p && (y.fill = x || "#e6ebf5", a.borderWidth && (y.stroke = a.borderColor, y["stroke-width"] = a.borderWidth))), A.zIndex = b, k += "-" + b, (x = i.plotLinesAndBandsGroups[k]) || (i.plotLinesAndBandsGroups[k] = x = w.g("plot-" + k).attr(A).add()), v && (e.svgElem = m = w.path().attr(y).add(x)), g) y = i.getPlotLinePath({
                    value: f,
                    lineWidth: m.strokeWidth(),
                    acrossPanes: a.acrossPanes
                }); else {
                    if (!p) return;
                    y = i.getPlotBandPath(d, u, a)
                }
                return (v || !m.d) && y && y.length ? (m.attr({d: y}), M && o(M, function (t, i) {
                    m.on(i, function (t) {
                        M[i].apply(e, [t])
                    })
                })) : m && (y ? (m.show(!0), m.animate({d: y})) : m.d && (m.hide(), l && (e.label = l = l.destroy()))), s && (n(s.text) || n(s.formatter)) && y && y.length && 0 < i.width && 0 < i.height && !y.isFlat ? (s = h({
                    align: r && p && "center",
                    x: r ? !p && 4 : 10,
                    verticalAlign: !r && p && "middle",
                    y: r ? p ? 16 : 10 : p ? 6 : -4,
                    rotation: r && !p && 90
                }, s), this.renderLabel(s, y, p, b)) : l && l.hide(), e
            }, renderLabel: function (t, e, i, n) {
                var r = this.label, o = this.axis.chart.renderer;
                r || ((r = {
                    align: t.textAlign || t.align,
                    rotation: t.rotation,
                    class: "highcharts-plot-" + (i ? "band" : "line") + "-label " + (t.className || "")
                }).zIndex = n, n = this.getLabelText(t), this.label = r = o.text(n, 0, 0, t.useHTML).attr(r).add(), this.axis.chart.styledMode || r.css(t.style)), o = e.xBounds || [e[1], e[4], i ? e[6] : e[1]], e = e.yBounds || [e[2], e[5], i ? e[7] : e[2]], i = s(o), n = s(e), r.align(t, !1, {
                    x: i,
                    y: n,
                    width: a(o) - i,
                    height: a(e) - n
                }), r.show(!0)
            }, getLabelText: function (t) {
                return n(t.formatter) ? t.formatter.call(this) : t.text
            }, destroy: function () {
                r(this.axis.plotLinesAndBands, this), delete this.axis, l(this)
            }
        }, t.extend(e.prototype, {
            getPlotBandPath: function (t, e) {
                var i = this.getPlotLinePath({value: e, force: !0, acrossPanes: this.options.acrossPanes}),
                    n = this.getPlotLinePath({value: t, force: !0, acrossPanes: this.options.acrossPanes}), r = [],
                    o = this.horiz, a = 1;
                if (t = t < this.min && e < this.min || t > this.max && e > this.max, n && i) {
                    if (t) {
                        var s = n.toString() === i.toString();
                        a = 0
                    }
                    for (t = 0; t < n.length; t += 6) o && i[t + 1] === n[t + 1] ? (i[t + 1] += a, i[t + 4] += a) : o || i[t + 2] !== n[t + 2] || (i[t + 2] += a, i[t + 5] += a), r.push("M", n[t + 1], n[t + 2], "L", n[t + 4], n[t + 5], i[t + 4], i[t + 5], i[t + 1], i[t + 2], "z"), r.isFlat = s
                }
                return r
            }, addPlotBand: function (t) {
                return this.addPlotBandOrLine(t, "plotBands")
            }, addPlotLine: function (t) {
                return this.addPlotBandOrLine(t, "plotLines")
            }, addPlotBandOrLine: function (e, i) {
                var n = new t.PlotLineOrBand(this, e).render(), r = this.userOptions;
                if (n) {
                    if (i) {
                        var o = r[i] || [];
                        o.push(e), r[i] = o
                    }
                    this.plotLinesAndBands.push(n)
                }
                return n
            }, removePlotBandOrLine: function (t) {
                for (var e = this.plotLinesAndBands, i = this.options, n = this.userOptions, o = e.length; o--;) e[o].id === t && e[o].destroy();
                [i.plotLines || [], n.plotLines || [], i.plotBands || [], n.plotBands || []].forEach(function (e) {
                    for (o = e.length; o--;) e[o].id === t && r(e, e[o])
                })
            }, removePlotBand: function (t) {
                this.removePlotBandOrLine(t)
            }, removePlotLine: function (t) {
                this.removePlotBandOrLine(t)
            }
        })
    }), e(i, "parts/Tooltip.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = e.isString, o = e.splat, a = t.doc, s = t.extend, l = t.format,
            h = t.merge, c = t.pick, u = t.syncTimeout, d = t.timeUnits;
        t.Tooltip = function () {
            this.init.apply(this, arguments)
        }, t.Tooltip.prototype = {
            init: function (t, e) {
                this.chart = t, this.options = e, this.crosshairs = [], this.now = {
                    x: 0,
                    y: 0
                }, this.isHidden = !0, this.split = e.split && !t.inverted, this.shared = e.shared || this.split, this.outside = c(e.outside, !(!t.scrollablePixelsX && !t.scrollablePixelsY)) && !this.split
            }, cleanSplit: function (t) {
                this.chart.series.forEach(function (e) {
                    var i = e && e.tt;
                    i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1)
                })
            }, applyFilter: function () {
                var t = this.chart;
                t.renderer.definition({
                    tagName: "filter",
                    id: "drop-shadow-" + t.index,
                    opacity: .5,
                    children: [{tagName: "feGaussianBlur", in: "SourceAlpha", stdDeviation: 1}, {
                        tagName: "feOffset",
                        dx: 1,
                        dy: 1
                    }, {
                        tagName: "feComponentTransfer",
                        children: [{tagName: "feFuncA", type: "linear", slope: .3}]
                    }, {
                        tagName: "feMerge",
                        children: [{tagName: "feMergeNode"}, {tagName: "feMergeNode", in: "SourceGraphic"}]
                    }]
                }), t.renderer.definition({
                    tagName: "style",
                    textContent: ".highcharts-tooltip-" + t.index + "{filter:url(#drop-shadow-" + t.index + ")}"
                })
            }, getLabel: function () {
                var e, n = this, r = this.chart.renderer, o = this.chart.styledMode, a = this.options,
                    s = "tooltip" + (i(a.className) ? " " + a.className : "");
                if (!this.label) {
                    if (this.outside && (this.container = e = t.doc.createElement("div"), e.className = "highcharts-tooltip-container", t.css(e, {
                        position: "absolute",
                        top: "1px",
                        pointerEvents: a.style && a.style.pointerEvents,
                        zIndex: 3
                    }), t.doc.body.appendChild(e), this.renderer = r = new t.Renderer(e, 0, 0, {}, void 0, void 0, r.styledMode)), this.split ? this.label = r.g(s) : (this.label = r.label("", 0, 0, a.shape || "callout", null, null, a.useHTML, null, s).attr({
                        padding: a.padding,
                        r: a.borderRadius
                    }), o || this.label.attr({
                        fill: a.backgroundColor,
                        "stroke-width": a.borderWidth
                    }).css(a.style).shadow(a.shadow)), o && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index)), this.outside) {
                        var l = {x: this.label.xSetter, y: this.label.ySetter};
                        this.label.xSetter = function (t, i) {
                            l[i].call(this.label, n.distance), e.style.left = t + "px"
                        }, this.label.ySetter = function (t, i) {
                            l[i].call(this.label, n.distance), e.style.top = t + "px"
                        }
                    }
                    this.label.attr({zIndex: 8}).add()
                }
                return this.label
            }, update: function (t) {
                this.destroy(), h(!0, this.chart.options.tooltip.userOptions, t), this.init(this.chart, h(!0, this.options, t))
            }, destroy: function () {
                this.label && (this.label = this.label.destroy()), this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy()), this.renderer && (this.renderer = this.renderer.destroy(), t.discardElement(this.container)), t.clearTimeout(this.hideTimer), t.clearTimeout(this.tooltipTimeout)
            }, move: function (e, i, n, r) {
                var o = this, a = o.now,
                    l = !1 !== o.options.animation && !o.isHidden && (1 < Math.abs(e - a.x) || 1 < Math.abs(i - a.y)),
                    h = o.followPointer || 1 < o.len;
                s(a, {
                    x: l ? (2 * a.x + e) / 3 : e,
                    y: l ? (a.y + i) / 2 : i,
                    anchorX: h ? void 0 : l ? (2 * a.anchorX + n) / 3 : n,
                    anchorY: h ? void 0 : l ? (a.anchorY + r) / 2 : r
                }), o.getLabel().attr(a), l && (t.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
                    o && o.move(e, i, n, r)
                }, 32))
            }, hide: function (e) {
                var i = this;
                t.clearTimeout(this.hideTimer), e = c(e, this.options.hideDelay, 500), this.isHidden || (this.hideTimer = u(function () {
                    i.getLabel()[e ? "fadeOut" : "hide"](), i.isHidden = !0
                }, e))
            }, getAnchor: function (t, e) {
                var i, n, r = this.chart, a = r.pointer, s = r.inverted, l = r.plotTop, h = r.plotLeft, c = 0, u = 0;
                return t = o(t), this.followPointer && e ? (void 0 === e.chartX && (e = a.normalize(e)), t = [e.chartX - r.plotLeft, e.chartY - l]) : t[0].tooltipPos ? t = t[0].tooltipPos : (t.forEach(function (t) {
                    i = t.series.yAxis, n = t.series.xAxis, c += t.plotX + (!s && n ? n.left - h : 0), u += (t.plotLow ? (t.plotLow + t.plotHigh) / 2 : t.plotY) + (!s && i ? i.top - l : 0)
                }), c /= t.length, u /= t.length, t = [s ? r.plotWidth - u : c, this.shared && !s && 1 < t.length && e ? e.chartY - l : s ? r.plotHeight - c : u]), t.map(Math.round)
            }, getPosition: function (t, e, i) {
                var n, r = this.chart, o = this.distance, s = {}, l = r.inverted && i.h || 0, h = this.outside,
                    u = h ? a.documentElement.clientWidth - 2 * o : r.chartWidth,
                    d = h ? Math.max(a.body.scrollHeight, a.documentElement.scrollHeight, a.body.offsetHeight, a.documentElement.offsetHeight, a.documentElement.clientHeight) : r.chartHeight,
                    f = r.pointer.chartPosition, p = r.containerScaling, g = function (t) {
                        return p ? t * p.scaleX : t
                    }, m = function (t) {
                        return p ? t * p.scaleY : t
                    }, v = function (n) {
                        var a = "x" === n;
                        return [n, a ? u : d, a ? t : e].concat(h ? [a ? g(t) : m(e), a ? f.left - o + g(i.plotX + r.plotLeft) : f.top - o + m(i.plotY + r.plotTop), 0, a ? u : d] : [a ? t : e, a ? i.plotX + r.plotLeft : i.plotY + r.plotTop, a ? r.plotLeft : r.plotTop, a ? r.plotLeft + r.plotWidth : r.plotTop + r.plotHeight])
                    }, y = v("y"), x = v("x"), b = !this.followPointer && c(i.ttBelow, !r.inverted == !!i.negative),
                    M = function (t) {
                        var e = y;
                        y = x, x = e, n = t
                    }, A = function () {
                        !1 !== (function (t, e, i, n, r, a, h) {
                            var c = "y" === t ? m(o) : g(o), u = (i - n) / 2, d = n < r - o, f = r + o + n < e,
                                p = r - c - i + u;
                            if (r = r + c - u, b && f) s[t] = r; else if (!b && d) s[t] = p; else if (d) s[t] = Math.min(h - n, 0 > p - l ? p : p - l); else {
                                if (!f) return !1;
                                s[t] = Math.max(a, r + l + i > e ? r : r + l)
                            }
                        }).apply(0, y) ? !1 !== (function (t, e, i, n, r) {
                            var a;
                            return r < o || r > e - o ? a = !1 : s[t] = r < i / 2 ? 1 : r > e - n / 2 ? e - n - 2 : r - i / 2, a
                        }).apply(0, x) || n || (M(!0), A()) : n ? s.x = s.y = 0 : (M(!0), A())
                    };
                return (r.inverted || 1 < this.len) && M(), A(), s
            }, defaultFormatter: function (t) {
                var e = this.points || o(this), i = [t.tooltipFooterHeaderFormatter(e[0])];
                return (i = i.concat(t.bodyFormatter(e))).push(t.tooltipFooterHeaderFormatter(e[0], !0)), i
            }, refresh: function (e, i) {
                var n = this.chart, r = this.options, a = e, s = {}, l = [], h = r.formatter || this.defaultFormatter;
                s = this.shared;
                var u = n.styledMode;
                if (r.enabled) {
                    t.clearTimeout(this.hideTimer), this.followPointer = o(a)[0].series.tooltipOptions.followPointer;
                    var d = this.getAnchor(a, i);
                    i = d[0];
                    var f = d[1];
                    !s || a.series && a.series.noSharedTooltip ? s = a.getLabelConfig() : (n.pointer.applyInactiveState(a), a.forEach(function (t) {
                        t.setState("hover"), l.push(t.getLabelConfig())
                    }), (s = {
                        x: a[0].category,
                        y: a[0].y
                    }).points = l, a = a[0]), this.len = l.length, h = h.call(s, this), s = a.series, this.distance = c(s.tooltipOptions.distance, 16), !1 === h ? this.hide() : (n = this.getLabel(), this.isHidden && n.attr({opacity: 1}).show(), this.split ? this.renderSplit(h, o(e)) : (r.style.width && !u || n.css({width: this.chart.spacingBox.width}), n.attr({text: h && h.join ? h.join("") : h}), n.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + c(a.colorIndex, s.colorIndex)), u || n.attr({stroke: r.borderColor || a.color || s.color || "#666666"}), this.updatePosition({
                        plotX: i,
                        plotY: f,
                        negative: a.negative,
                        ttBelow: a.ttBelow,
                        h: d[2] || 0
                    })), this.isHidden = !1), t.fireEvent(this, "refresh")
                }
            }, renderSplit: function (e, i) {
                var n, o = this, a = [], s = this.chart, l = s.renderer, h = !0, u = this.options, d = 0,
                    f = this.getLabel(), p = s.plotTop;
                r(e) && (e = [!1, e]), e.slice(0, i.length + 1).forEach(function (t, e) {
                    if (!1 !== t && "" !== t) {
                        var r = (e = i[e - 1] || {isHeader: !0, plotX: i[0].plotX, plotY: s.plotHeight}).series || o,
                            g = r.tt, m = e.series || {},
                            v = "highcharts-color-" + c(e.colorIndex, m.colorIndex, "none");
                        g || (g = {
                            padding: u.padding,
                            r: u.borderRadius
                        }, s.styledMode || (g.fill = u.backgroundColor, g["stroke-width"] = u.borderWidth), r.tt = g = l.label(null, null, null, (e.isHeader ? u.headerShape : u.shape) || "callout", null, null, u.useHTML).addClass("highcharts-tooltip-box " + v).attr(g).add(f)), g.isActive = !0, g.attr({text: t}), s.styledMode || g.css(u.style).shadow(u.shadow).attr({stroke: u.borderColor || e.color || m.color || "#333333"}), v = (t = g.getBBox()).width + g.strokeWidth(), e.isHeader ? (d = t.height, s.xAxis[0].opposite && (n = !0, p -= d), t = Math.max(0, Math.min(e.plotX + s.plotLeft - v / 2, s.chartWidth + (s.scrollablePixelsX ? s.scrollablePixelsX - s.marginRight : 0) - v))) : t = e.plotX + s.plotLeft - c(u.distance, 16) - v, 0 > t && (h = !1), e.isHeader ? m = n ? -d : s.plotHeight + d : m = (m = m.yAxis).pos - p + Math.max(0, Math.min(e.plotY || 0, m.len)), a.push({
                            target: m,
                            rank: e.isHeader ? 1 : 0,
                            size: r.tt.getBBox().height + 1,
                            point: e,
                            x: t,
                            tt: g
                        })
                    }
                }), this.cleanSplit(), u.positioner && a.forEach(function (t) {
                    var e = u.positioner.call(o, t.tt.getBBox().width, t.size, t.point);
                    t.x = e.x, t.align = 0, t.target = e.y, t.rank = c(e.rank, t.rank)
                }), t.distribute(a, s.plotHeight + d), a.forEach(function (t) {
                    var e = t.point, i = e.series, n = i && i.yAxis;
                    t.tt.attr({
                        visibility: void 0 === t.pos ? "hidden" : "inherit",
                        x: h || e.isHeader || u.positioner ? t.x : e.plotX + s.plotLeft + o.distance,
                        y: t.pos + p,
                        anchorX: e.isHeader ? e.plotX + s.plotLeft : e.plotX + i.xAxis.pos,
                        anchorY: e.isHeader ? s.plotTop + s.plotHeight / 2 : n.pos + Math.max(0, Math.min(e.plotY, n.len))
                    })
                })
            }, updatePosition: function (e) {
                var i = this.chart, n = i.pointer, r = this.getLabel(), o = e.plotX + i.plotLeft,
                    a = e.plotY + i.plotTop;
                if (n.chartPosition || (n.chartPosition = t.offset(i.container)), e = (this.options.positioner || this.getPosition).call(this, r.width, r.height, e), this.outside) {
                    var s = (this.options.borderWidth || 0) + 2 * this.distance;
                    this.renderer.setSize(r.width + s, r.height + s, !1), (i = i.containerScaling) && (t.css(this.container, {transform: "scale(" + i.scaleX + ", " + i.scaleY + ")"}), o *= i.scaleX, a *= i.scaleY), o += n.chartPosition.left - e.x, a += n.chartPosition.top - e.y
                }
                this.move(Math.round(e.x), Math.round(e.y || 0), o, a)
            }, getDateFormat: function (t, e, i, n) {
                var r = this.chart.time, o = r.dateFormat("%m-%d %H:%M:%S.%L", e),
                    a = {millisecond: 15, second: 12, minute: 9, hour: 6, day: 3}, s = "millisecond";
                for (l in d) {
                    if (t === d.week && +r.dateFormat("%w", e) === i && "00:00:00.000" === o.substr(6)) {
                        var l = "week";
                        break
                    }
                    if (d[l] > t) {
                        l = s;
                        break
                    }
                    if (a[l] && o.substr(a[l]) !== "01-01 00:00:00.000".substr(a[l])) break;
                    "week" !== l && (s = l)
                }
                if (l) var h = r.resolveDTLFormat(n[l]).main;
                return h
            }, getXDateFormat: function (t, e, i) {
                e = e.dateTimeLabelFormats;
                var n = i && i.closestPointRange;
                return (n ? this.getDateFormat(n, t.x, i.options.startOfWeek, e) : e.day) || e.year
            }, tooltipFooterHeaderFormatter: function (e, i) {
                var r = i ? "footer" : "header", o = e.series, a = o.tooltipOptions, s = a.xDateFormat, h = o.xAxis,
                    c = h && "datetime" === h.options.type && n(e.key), u = a[r + "Format"];
                return i = {isFooter: i, labelConfig: e}, t.fireEvent(this, "headerFormatter", i, function (t) {
                    c && !s && (s = this.getXDateFormat(e, a, h)), c && s && (e.point && e.point.tooltipDateKeys || ["key"]).forEach(function (t) {
                        u = u.replace("{point." + t + "}", "{point." + t + ":" + s + "}")
                    }), o.chart.styledMode && (u = this.styledModeFormat(u)), t.text = l(u, {
                        point: e,
                        series: o
                    }, this.chart.time)
                }), i.text
            }, bodyFormatter: function (t) {
                return t.map(function (t) {
                    var e = t.series.tooltipOptions;
                    return (e[(t.point.formatPrefix || "point") + "Formatter"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || "point") + "Format"] || "")
                })
            }, styledModeFormat: function (t) {
                return t.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"')
            }
        }
    }), e(i, "parts/Pointer.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.attr, n = e.defined, r = e.isNumber, o = e.isObject, a = e.objectEach, s = e.splat, l = t.addEvent,
            h = t.charts, c = t.color, u = t.css, d = t.extend, f = t.find, p = t.fireEvent, g = t.offset, m = t.pick,
            v = t.Tooltip;
        t.Pointer = function (t, e) {
            this.init(t, e)
        }, t.Pointer.prototype = {
            init: function (t, e) {
                this.options = e, this.chart = t, this.runChartClick = e.chart.events && !!e.chart.events.click, this.pinchDown = [], this.lastValidTouch = {}, v && (t.tooltip = new v(t, e.tooltip), this.followTouchMove = m(e.tooltip.followTouchMove, !0)), this.setDOMEvents()
            }, zoomOption: function (t) {
                var e = this.chart, i = e.options.chart, n = i.zoomType || "";
                e = e.inverted, /touch/.test(t.type) && (n = m(i.pinchType, n)), this.zoomX = t = /x/.test(n), this.zoomY = n = /y/.test(n), this.zoomHor = t && !e || n && e, this.zoomVert = n && !e || t && e, this.hasZoom = t || n
            }, normalize: function (t, e) {
                var i = t.touches ? t.touches.length ? t.touches.item(0) : t.changedTouches[0] : t;
                e || (this.chartPosition = e = g(this.chart.container));
                var n = i.pageX - e.left;
                return e = i.pageY - e.top, (i = this.chart.containerScaling) && (n /= i.scaleX, e /= i.scaleY), d(t, {
                    chartX: Math.round(n),
                    chartY: Math.round(e)
                })
            }, getCoordinates: function (t) {
                var e = {xAxis: [], yAxis: []};
                return this.chart.axes.forEach(function (i) {
                    e[i.isXAxis ? "xAxis" : "yAxis"].push({axis: i, value: i.toValue(t[i.horiz ? "chartX" : "chartY"])})
                }), e
            }, findNearestKDPoint: function (t, e, i) {
                var n;
                return t.forEach(function (t) {
                    var r = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf("y");
                    if (t = t.searchPoint(i, r), (r = o(t, !0)) && !(r = !o(n, !0))) {
                        r = n.distX - t.distX;
                        var a = n.dist - t.dist,
                            s = (t.series.group && t.series.group.zIndex) - (n.series.group && n.series.group.zIndex);
                        r = 0 < (0 !== r && e ? r : 0 !== a ? a : 0 !== s ? s : n.series.index > t.series.index ? -1 : 1)
                    }
                    r && (n = t)
                }), n
            }, getPointFromEvent: function (t) {
                t = t.target;
                for (var e; t && !e;) e = t.point, t = t.parentNode;
                return e
            }, getChartCoordinatesFromPoint: function (t, e) {
                var i = t.series, n = i.xAxis;
                i = i.yAxis;
                var r = m(t.clientX, t.plotX), o = t.shapeArgs;
                return n && i ? e ? {chartX: n.len + n.pos - r, chartY: i.len + i.pos - t.plotY} : {
                    chartX: r + n.pos,
                    chartY: t.plotY + i.pos
                } : o && o.x && o.y ? {chartX: o.x, chartY: o.y} : void 0
            }, getHoverData: function (t, e, i, n, r, a) {
                var s, l = [];
                n = !(!n || !t);
                var h = e && !e.stickyTracking ? [e] : i.filter(function (t) {
                    return t.visible && !(!r && t.directTouch) && m(t.options.enableMouseTracking, !0) && t.stickyTracking
                });
                return e = (s = n || !a ? t : this.findNearestKDPoint(h, r, a)) && s.series, s && (r && !e.noSharedTooltip ? (h = i.filter(function (t) {
                    return t.visible && !(!r && t.directTouch) && m(t.options.enableMouseTracking, !0) && !t.noSharedTooltip
                })).forEach(function (t) {
                    var e = f(t.points, function (t) {
                        return t.x === s.x && !t.isNull
                    });
                    o(e) && (t.chart.isBoosting && (e = t.getPoint(e)), l.push(e))
                }) : l.push(s)), {hoverPoint: s, hoverSeries: e, hoverPoints: l}
            }, runPointActions: function (e, i) {
                var n = this.chart, r = n.tooltip && n.tooltip.options.enabled ? n.tooltip : void 0,
                    o = !!r && r.shared, a = i || n.hoverPoint, s = a && a.series || n.hoverSeries;
                a = (s = this.getHoverData(a, s, n.series, (!e || "touchmove" !== e.type) && (!!i || s && s.directTouch && this.isDirectTouch), o, e)).hoverPoint;
                var c = s.hoverPoints;
                if (i = (s = s.hoverSeries) && s.tooltipOptions.followPointer, o = o && s && !s.noSharedTooltip, a && (a !== n.hoverPoint || r && r.isHidden)) {
                    if ((n.hoverPoints || []).forEach(function (t) {
                        -1 === c.indexOf(t) && t.setState()
                    }), n.hoverSeries !== s && s.onMouseOver(), this.applyInactiveState(c), (c || []).forEach(function (t) {
                        t.setState("hover")
                    }), n.hoverPoint && n.hoverPoint.firePointEvent("mouseOut"), !a.series) return;
                    a.firePointEvent("mouseOver"), n.hoverPoints = c, n.hoverPoint = a, r && r.refresh(o ? c : a, e)
                } else i && r && !r.isHidden && (a = r.getAnchor([{}], e), r.updatePosition({
                    plotX: a[0],
                    plotY: a[1]
                }));
                this.unDocMouseMove || (this.unDocMouseMove = l(n.container.ownerDocument, "mousemove", function (e) {
                    var i = h[t.hoverChartIndex];
                    i && i.pointer.onDocumentMouseMove(e)
                })), n.axes.forEach(function (i) {
                    var n = m(i.crosshair.snap, !0), r = n ? t.find(c, function (t) {
                        return t.series[i.coll] === i
                    }) : void 0;
                    r || !n ? i.drawCrosshair(e, r) : i.hideCrosshair()
                })
            }, applyInactiveState: function (t) {
                var e, i = [];
                (t || []).forEach(function (t) {
                    e = t.series, i.push(e), e.linkedParent && i.push(e.linkedParent), e.linkedSeries && (i = i.concat(e.linkedSeries)), e.navigatorSeries && i.push(e.navigatorSeries)
                }), this.chart.series.forEach(function (t) {
                    -1 === i.indexOf(t) ? t.setState("inactive", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState("inactive")
                })
            }, reset: function (t, e) {
                var i = this.chart, n = i.hoverSeries, r = i.hoverPoint, o = i.hoverPoints, a = i.tooltip,
                    l = a && a.shared ? o : r;
                t && l && s(l).forEach(function (e) {
                    e.series.isCartesian && void 0 === e.plotX && (t = !1)
                }), t ? a && l && s(l).length && (a.refresh(l), a.shared && o ? o.forEach(function (t) {
                    t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t))
                }) : r && (r.setState(r.state, !0), i.axes.forEach(function (t) {
                    t.crosshair && t.drawCrosshair(null, r)
                }))) : (r && r.onMouseOut(), o && o.forEach(function (t) {
                    t.setState()
                }), n && n.onMouseOut(), a && a.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (t) {
                    t.hideCrosshair()
                }), this.hoverX = i.hoverPoints = i.hoverPoint = null)
            }, scaleGroups: function (t, e) {
                var i, n = this.chart;
                n.series.forEach(function (r) {
                    i = t || r.getPlotBox(), r.xAxis && r.xAxis.zoomEnabled && r.group && (r.group.attr(i), r.markerGroup && (r.markerGroup.attr(i), r.markerGroup.clip(e ? n.clipRect : null)), r.dataLabelsGroup && r.dataLabelsGroup.attr(i))
                }), n.clipRect.attr(e || n.clipBox)
            }, dragStart: function (t) {
                var e = this.chart;
                e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY
            }, drag: function (t) {
                var e = this.chart, i = e.options.chart, n = t.chartX, r = t.chartY, o = this.zoomHor,
                    a = this.zoomVert, s = e.plotLeft, l = e.plotTop, h = e.plotWidth, u = e.plotHeight,
                    d = this.selectionMarker, f = this.mouseDownX, p = this.mouseDownY,
                    g = i.panKey && t[i.panKey + "Key"];
                if ((!d || !d.touch) && (n < s ? n = s : n > s + h && (n = s + h), r < l ? r = l : r > l + u && (r = l + u), this.hasDragged = Math.sqrt(Math.pow(f - n, 2) + Math.pow(p - r, 2)), 10 < this.hasDragged)) {
                    var m = e.isInsidePlot(f - s, p - l);
                    e.hasCartesianSeries && (this.zoomX || this.zoomY) && m && !g && !d && (this.selectionMarker = d = e.renderer.rect(s, l, o ? 1 : h, a ? 1 : u, 0).attr({
                        class: "highcharts-selection-marker",
                        zIndex: 7
                    }).add(), e.styledMode || d.attr({fill: i.selectionMarkerFill || c("#335cad").setOpacity(.25).get()})), d && o && (n -= f, d.attr({
                        width: Math.abs(n),
                        x: (0 < n ? 0 : n) + f
                    })), d && a && (n = r - p, d.attr({
                        height: Math.abs(n),
                        y: (0 < n ? 0 : n) + p
                    })), m && !d && i.panning && e.pan(t, i.panning)
                }
            }, drop: function (t) {
                var e = this, i = this.chart, o = this.hasPinched;
                if (this.selectionMarker) {
                    var a, s = {originalEvent: t, xAxis: [], yAxis: []}, l = this.selectionMarker,
                        h = l.attr ? l.attr("x") : l.x, c = l.attr ? l.attr("y") : l.y,
                        f = l.attr ? l.attr("width") : l.width, g = l.attr ? l.attr("height") : l.height;
                    (this.hasDragged || o) && (i.axes.forEach(function (i) {
                        if (i.zoomEnabled && n(i.min) && (o || e[{xAxis: "zoomX", yAxis: "zoomY"}[i.coll]])) {
                            var r = i.horiz, l = "touchend" === t.type ? i.minPixelPadding : 0,
                                u = i.toValue((r ? h : c) + l);
                            r = i.toValue((r ? h + f : c + g) - l), s[i.coll].push({
                                axis: i,
                                min: Math.min(u, r),
                                max: Math.max(u, r)
                            }), a = !0
                        }
                    }), a && p(i, "selection", s, function (t) {
                        i.zoom(d(t, o ? {animation: !1} : null))
                    })), r(i.index) && (this.selectionMarker = this.selectionMarker.destroy()), o && this.scaleGroups()
                }
                i && r(i.index) && (u(i.container, {cursor: i._cursor}), i.cancelClick = 10 < this.hasDragged, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
            }, onContainerMouseDown: function (t) {
                2 !== (t = this.normalize(t)).button && (this.zoomOption(t), t.preventDefault && t.preventDefault(), this.dragStart(t))
            }, onDocumentMouseUp: function (e) {
                h[t.hoverChartIndex] && h[t.hoverChartIndex].pointer.drop(e)
            }, onDocumentMouseMove: function (t) {
                var e = this.chart, i = this.chartPosition;
                t = this.normalize(t, i), !i || this.inClass(t.target, "highcharts-tracker") || e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop) || this.reset()
            }, onContainerMouseLeave: function (e) {
                var i = h[t.hoverChartIndex];
                i && (e.relatedTarget || e.toElement) && (i.pointer.reset(), i.pointer.chartPosition = null)
            }, onContainerMouseMove: function (e) {
                var i = this.chart;
                n(t.hoverChartIndex) && h[t.hoverChartIndex] && h[t.hoverChartIndex].mouseIsDown || (t.hoverChartIndex = i.index), (e = this.normalize(e)).preventDefault || (e.returnValue = !1), "mousedown" === i.mouseIsDown && this.drag(e), !this.inClass(e.target, "highcharts-tracker") && !i.isInsidePlot(e.chartX - i.plotLeft, e.chartY - i.plotTop) || i.openMenu || this.runPointActions(e)
            }, inClass: function (t, e) {
                for (var n; t;) {
                    if (n = i(t, "class")) {
                        if (-1 !== n.indexOf(e)) return !0;
                        if (-1 !== n.indexOf("highcharts-container")) return !1
                    }
                    t = t.parentNode
                }
            }, onTrackerMouseOut: function (t) {
                var e = this.chart.hoverSeries;
                t = t.relatedTarget || t.toElement, this.isDirectTouch = !1, !e || !t || e.stickyTracking || this.inClass(t, "highcharts-tooltip") || this.inClass(t, "highcharts-series-" + e.index) && this.inClass(t, "highcharts-tracker") || e.onMouseOut()
            }, onContainerClick: function (t) {
                var e = this.chart, i = e.hoverPoint, n = e.plotLeft, r = e.plotTop;
                t = this.normalize(t), e.cancelClick || (i && this.inClass(t.target, "highcharts-tracker") ? (p(i.series, "click", d(t, {point: i})), e.hoverPoint && i.firePointEvent("click", t)) : (d(t, this.getCoordinates(t)), e.isInsidePlot(t.chartX - n, t.chartY - r) && p(e, "click", t)))
            }, setDOMEvents: function () {
                var e = this, i = e.chart.container, n = i.ownerDocument;
                i.onmousedown = function (t) {
                    e.onContainerMouseDown(t)
                }, i.onmousemove = function (t) {
                    e.onContainerMouseMove(t)
                }, i.onclick = function (t) {
                    e.onContainerClick(t)
                }, this.unbindContainerMouseLeave = l(i, "mouseleave", e.onContainerMouseLeave), t.unbindDocumentMouseUp || (t.unbindDocumentMouseUp = l(n, "mouseup", e.onDocumentMouseUp)), t.hasTouch && (l(i, "touchstart", function (t) {
                    e.onContainerTouchStart(t)
                }), l(i, "touchmove", function (t) {
                    e.onContainerTouchMove(t)
                }), t.unbindDocumentTouchEnd || (t.unbindDocumentTouchEnd = l(n, "touchend", e.onDocumentTouchEnd)))
            }, destroy: function () {
                var e = this;
                e.unDocMouseMove && e.unDocMouseMove(), this.unbindContainerMouseLeave(), t.chartCount || (t.unbindDocumentMouseUp && (t.unbindDocumentMouseUp = t.unbindDocumentMouseUp()), t.unbindDocumentTouchEnd && (t.unbindDocumentTouchEnd = t.unbindDocumentTouchEnd())), clearInterval(e.tooltipTimeout), a(e, function (t, i) {
                    e[i] = null
                })
            }
        }
    }), e(i, "parts/TouchPointer.js", [i["parts/Globals.js"]], function (t) {
        var e = t.charts, i = t.extend, n = t.noop, r = t.pick;
        i(t.Pointer.prototype, {
            pinchTranslate: function (t, e, i, n, r, o) {
                this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, n, r, o), this.zoomVert && this.pinchTranslateDirection(!1, t, e, i, n, r, o)
            }, pinchTranslateDirection: function (t, e, i, n, r, o, a, s) {
                var l, h, c = this.chart, u = t ? "x" : "y", d = t ? "X" : "Y", f = "chart" + d,
                    p = t ? "width" : "height", g = c["plot" + (t ? "Left" : "Top")], m = s || 1, v = c.inverted,
                    y = c.bounds[t ? "h" : "v"], x = 1 === e.length, b = e[0][f], M = i[0][f], A = !x && e[1][f],
                    w = !x && i[1][f];
                if ((i = function () {
                    !x && 20 < Math.abs(b - A) && (m = s || Math.abs(M - w) / Math.abs(b - A)), h = (g - M) / m + b, l = c["plot" + (t ? "Width" : "Height")] / m
                })(), (e = h) < y.min) {
                    e = y.min;
                    var k = !0
                } else e + l > y.max && (e = y.max - l, k = !0);
                k ? (M -= .8 * (M - a[u][0]), x || (w -= .8 * (w - a[u][1])), i()) : a[u] = [M, w], v || (o[u] = h - g, o[p] = l), o = v ? 1 / m : m, r[p] = l, r[u] = e, n[v ? t ? "scaleY" : "scaleX" : "scale" + d] = m, n["translate" + d] = o * g + (M - o * b)
            }, pinch: function (t) {
                var e = this, o = e.chart, a = e.pinchDown, s = t.touches, l = s.length, h = e.lastValidTouch,
                    c = e.hasZoom, u = e.selectionMarker, d = {},
                    f = 1 === l && (e.inClass(t.target, "highcharts-tracker") && o.runTrackerClick || e.runChartClick),
                    p = {};
                1 < l && (e.initiated = !0), c && e.initiated && !f && t.preventDefault(), [].map.call(s, function (t) {
                    return e.normalize(t)
                }), "touchstart" === t.type ? ([].forEach.call(s, function (t, e) {
                    a[e] = {chartX: t.chartX, chartY: t.chartY}
                }), h.x = [a[0].chartX, a[1] && a[1].chartX], h.y = [a[0].chartY, a[1] && a[1].chartY], o.axes.forEach(function (t) {
                    if (t.zoomEnabled) {
                        var e = o.bounds[t.horiz ? "h" : "v"], i = t.minPixelPadding,
                            n = t.toPixels(Math.min(r(t.options.min, t.dataMin), t.dataMin)),
                            a = t.toPixels(Math.max(r(t.options.max, t.dataMax), t.dataMax)), s = Math.max(n, a);
                        e.min = Math.min(t.pos, Math.min(n, a) - i), e.max = Math.max(t.pos + t.len, s + i)
                    }
                }), e.res = !0) : e.followTouchMove && 1 === l ? this.runPointActions(e.normalize(t)) : a.length && (u || (e.selectionMarker = u = i({
                    destroy: n,
                    touch: !0
                }, o.plotBox)), e.pinchTranslate(a, s, d, u, p, h), e.hasPinched = c, e.scaleGroups(d, p), e.res && (e.res = !1, this.reset(!1, 0)))
            }, touch: function (e, i) {
                var n = this.chart;
                if (n.index !== t.hoverChartIndex && this.onContainerMouseLeave({relatedTarget: !0}), t.hoverChartIndex = n.index, 1 === e.touches.length) if (e = this.normalize(e), n.isInsidePlot(e.chartX - n.plotLeft, e.chartY - n.plotTop) && !n.openMenu) {
                    if (i && this.runPointActions(e), "touchmove" === e.type) var o = !!(i = this.pinchDown)[0] && 4 <= Math.sqrt(Math.pow(i[0].chartX - e.chartX, 2) + Math.pow(i[0].chartY - e.chartY, 2));
                    r(o, !0) && this.pinch(e)
                } else i && this.reset(); else 2 === e.touches.length && this.pinch(e)
            }, onContainerTouchStart: function (t) {
                this.zoomOption(t), this.touch(t, !0)
            }, onContainerTouchMove: function (t) {
                this.touch(t)
            }, onDocumentTouchEnd: function (i) {
                e[t.hoverChartIndex] && e[t.hoverChartIndex].pointer.drop(i)
            }
        })
    }), e(i, "parts/MSPointer.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.objectEach, n = t.addEvent, r = t.charts, o = t.css, a = t.doc;
        e = t.extend;
        var s = t.noop, l = t.Pointer, h = t.removeEvent, c = t.win, u = t.wrap;
        if (!t.hasTouch && (c.PointerEvent || c.MSPointerEvent)) {
            var d = {}, f = !!c.PointerEvent, p = function () {
                var t = [];
                return t.item = function (t) {
                    return this[t]
                }, i(d, function (e) {
                    t.push({pageX: e.pageX, pageY: e.pageY, target: e.target})
                }), t
            }, g = function (e, i, n, o) {
                "touch" !== e.pointerType && e.pointerType !== e.MSPOINTER_TYPE_TOUCH || !r[t.hoverChartIndex] || (o(e), (o = r[t.hoverChartIndex].pointer)[i]({
                    type: n,
                    target: e.currentTarget,
                    preventDefault: s,
                    touches: p()
                }))
            };
            e(l.prototype, {
                onContainerPointerDown: function (t) {
                    g(t, "onContainerTouchStart", "touchstart", function (t) {
                        d[t.pointerId] = {pageX: t.pageX, pageY: t.pageY, target: t.currentTarget}
                    })
                }, onContainerPointerMove: function (t) {
                    g(t, "onContainerTouchMove", "touchmove", function (t) {
                        d[t.pointerId] = {
                            pageX: t.pageX,
                            pageY: t.pageY
                        }, d[t.pointerId].target || (d[t.pointerId].target = t.currentTarget)
                    })
                }, onDocumentPointerUp: function (t) {
                    g(t, "onDocumentTouchEnd", "touchend", function (t) {
                        delete d[t.pointerId]
                    })
                }, batchMSEvents: function (t) {
                    t(this.chart.container, f ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown), t(this.chart.container, f ? "pointermove" : "MSPointerMove", this.onContainerPointerMove), t(a, f ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
                }
            }), u(l.prototype, "init", function (t, e, i) {
                t.call(this, e, i), this.hasZoom && o(e.container, {"-ms-touch-action": "none", "touch-action": "none"})
            }), u(l.prototype, "setDOMEvents", function (t) {
                t.apply(this), (this.hasZoom || this.followTouchMove) && this.batchMSEvents(n)
            }), u(l.prototype, "destroy", function (t) {
                this.batchMSEvents(h), t.call(this)
            })
        }
    }), e(i, "parts/Legend.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = t.addEvent, o = t.css, a = t.discardElement, s = t.fireEvent;
        e = t.isFirefox;
        var l = t.marginNames, h = t.merge, c = t.pick, u = t.setAnimation, d = t.stableSort, f = t.win, p = t.wrap;
        t.Legend = function (t, e) {
            this.init(t, e)
        }, t.Legend.prototype = {
            init: function (t, e) {
                this.chart = t, this.setOptions(e), e.enabled && (this.render(), r(this.chart, "endResize", function () {
                    this.legend.positionCheckboxes()
                }), this.proximate ? this.unchartrender = r(this.chart, "render", function () {
                    this.legend.proximatePositions(), this.legend.positionItems()
                }) : this.unchartrender && this.unchartrender())
            }, setOptions: function (t) {
                var e = c(t.padding, 8);
                this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = h(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop || 0, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = c(t.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t.layout && !this.chart.inverted
            }, update: function (t, e) {
                var i = this.chart;
                this.setOptions(h(!0, this.options, t)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, c(e, !0) && i.redraw(), s(this, "afterUpdate")
            }, colorizeItem: function (t, e) {
                if (t.legendGroup[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
                    var i = this.options, n = t.legendItem, r = t.legendLine, o = t.legendSymbol,
                        a = this.itemHiddenStyle.color;
                    i = e ? i.itemStyle.color : a;
                    var l = e && t.color || a, h = t.options && t.options.marker, c = {fill: l};
                    n && n.css({
                        fill: i,
                        color: i
                    }), r && r.attr({stroke: l}), o && (h && o.isMarker && (c = t.pointAttribs(), e || (c.stroke = c.fill = a)), o.attr(c))
                }
                s(this, "afterColorizeItem", {item: t, visible: e})
            }, positionItems: function () {
                this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes()
            }, positionItem: function (t) {
                var e = this.options, n = e.symbolPadding;
                e = !e.rtl;
                var r = t._legendItemPos, o = r[0];
                r = r[1];
                var a = t.checkbox;
                (t = t.legendGroup) && t.element && t[i(t.translateY) ? "animate" : "attr"]({
                    translateX: e ? o : this.legendWidth - o - 2 * n - 4,
                    translateY: r
                }), a && (a.x = o, a.y = r)
            }, destroyItem: function (t) {
                var e = t.checkbox;
                ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (e) {
                    t[e] && (t[e] = t[e].destroy())
                }), e && a(t.checkbox)
            }, destroy: function () {
                function t(t) {
                    this[t] && (this[t] = this[t].destroy())
                }

                this.getAllItems().forEach(function (e) {
                    ["legendItem", "legendGroup"].forEach(t, e)
                }), "clipRect up down pager nav box title group".split(" ").forEach(t, this), this.display = null
            }, positionCheckboxes: function () {
                var t = this.group && this.group.alignAttr, e = this.clipHeight || this.legendHeight,
                    i = this.titleHeight;
                if (t) {
                    var n = t.translateY;
                    this.allItems.forEach(function (r) {
                        var a = r.checkbox;
                        if (a) {
                            var s = n + i + a.y + (this.scrollOffset || 0) + 3;
                            o(a, {
                                left: t.translateX + r.checkboxOffset + a.x - 20 + "px",
                                top: s + "px",
                                display: this.proximate || s > n - 6 && s < n + e - 6 ? "" : "none"
                            })
                        }
                    }, this)
                }
            }, renderTitle: function () {
                var t = this.options, e = this.padding, i = t.title, n = 0;
                i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, null, null, null, t.useHTML, null, "legend-title").attr({zIndex: 1}), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({width: this.maxLegendWidth + "px"}), n = (t = this.title.getBBox()).height, this.offsetWidth = t.width, this.contentGroup.attr({translateY: n})), this.titleHeight = n
            }, setText: function (e) {
                var i = this.options;
                e.legendItem.attr({text: i.labelFormat ? t.format(i.labelFormat, e, this.chart.time) : i.labelFormatter.call(e)})
            }, renderItem: function (t) {
                var e = this.chart, i = e.renderer, n = this.options, r = this.symbolWidth, o = n.symbolPadding,
                    a = this.itemStyle, s = this.itemHiddenStyle,
                    l = "horizontal" === n.layout ? c(n.itemDistance, 20) : 0, u = !n.rtl, d = t.legendItem,
                    f = !t.series, p = !f && t.series.drawLegendSymbol ? t.series : t, g = p.options;
                l = r + o + l + ((g = this.createCheckboxForItem && g && g.showCheckbox) ? 20 : 0);
                var m = n.useHTML, v = t.options.className;
                d || (t.legendGroup = i.g("legend-item").addClass("highcharts-" + p.type + "-series highcharts-color-" + t.colorIndex + (v ? " " + v : "") + (f ? " highcharts-series-" + t.index : "")).attr({zIndex: 1}).add(this.scrollGroup), t.legendItem = d = i.text("", u ? r + o : -o, this.baseline || 0, m), e.styledMode || d.css(h(t.visible ? a : s)), d.attr({
                    align: u ? "left" : "right",
                    zIndex: 2
                }).add(t.legendGroup), this.baseline || (this.fontMetrics = i.fontMetrics(e.styledMode ? 12 : a.fontSize, d), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, d.attr("y", this.baseline)), this.symbolHeight = n.symbolHeight || this.fontMetrics.f, p.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, d, m)), g && !t.checkbox && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), !e.styledMode && a.width || d.css({width: (n.itemWidth || this.widthOption || e.spacingBox.width) - l}), this.setText(t), e = d.getBBox(), t.itemWidth = t.checkboxOffset = n.itemWidth || t.legendItemWidth || e.width + l, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(t.legendItemHeight || e.height || this.symbolHeight)
            }, layoutItem: function (t) {
                var e = this.options, i = this.padding, n = "horizontal" === e.layout, r = t.itemHeight,
                    o = e.itemMarginBottom || 0, a = this.itemMarginTop, s = n ? c(e.itemDistance, 20) : 0,
                    l = this.maxLegendWidth;
                e = e.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : t.itemWidth, n && this.itemX - i + e > l && (this.itemX = i, this.lastLineHeight && (this.itemY += a + this.lastLineHeight + o), this.lastLineHeight = 0), this.lastItemY = a + this.itemY + o, this.lastLineHeight = Math.max(r, this.lastLineHeight), t._legendItemPos = [this.itemX, this.itemY], n ? this.itemX += e : (this.itemY += a + r + o, this.lastLineHeight = r), this.offsetWidth = this.widthOption || Math.max((n ? this.itemX - i - (t.checkbox ? 0 : s) : e) + i, this.offsetWidth)
            }, getAllItems: function () {
                var t = [];
                return this.chart.series.forEach(function (e) {
                    var n = e && e.options;
                    e && c(n.showInLegend, !i(n.linkedTo) && void 0, !0) && (t = t.concat(e.legendItems || ("point" === n.legendType ? e.data : e)))
                }), s(this, "afterGetAllItems", {allItems: t}), t
            }, getAlignment: function () {
                var t = this.options;
                return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0)
            }, adjustMargins: function (t, e) {
                var n = this.chart, r = this.options, o = this.getAlignment();
                o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (a, s) {
                    a.test(o) && !i(t[s]) && (n[l[s]] = Math.max(n[l[s]], n.legend[(s + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][s] * r[s % 2 ? "x" : "y"] + c(r.margin, 12) + e[s] + (n.titleOffset[s] || 0)))
                })
            }, proximatePositions: function () {
                var e = this.chart, i = [], r = "left" === this.options.align;
                this.allItems.forEach(function (o) {
                    var a = r;
                    if (o.yAxis && o.points) {
                        o.xAxis.options.reversed && (a = !a);
                        var s = t.find(a ? o.points : o.points.slice(0).reverse(), function (t) {
                            return n(t.plotY)
                        });
                        a = o.legendGroup.getBBox().height;
                        var l = o.yAxis.top - e.plotTop;
                        o.visible ? (s = s ? s.plotY : o.yAxis.height, s += l - .3 * a) : s = l + o.yAxis.height, i.push({
                            target: s,
                            size: a,
                            item: o
                        })
                    }
                }, this), t.distribute(i, e.plotHeight), i.forEach(function (t) {
                    t.item._legendItemPos[1] = e.plotTop - e.spacing[0] + t.pos
                })
            }, render: function () {
                var e, i = this.chart, n = i.renderer, r = this.group, o = this.box, a = this.options, l = this.padding;
                this.itemX = l, this.itemY = this.initialItemY, this.lastItemY = this.offsetWidth = 0, this.widthOption = t.relativeLength(a.width, i.spacingBox.width - l);
                var c = i.spacingBox.width - 2 * l - a.x;
                -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (c /= 2), this.maxLegendWidth = this.widthOption || c, r || (this.group = r = n.g("legend").attr({zIndex: 7}).add(), this.contentGroup = n.g().attr({zIndex: 1}).add(r), this.scrollGroup = n.g().add(this.contentGroup)), this.renderTitle(), c = this.getAllItems(), d(c, function (t, e) {
                    return (t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)
                }), a.reversed && c.reverse(), this.allItems = c, this.display = e = !!c.length, this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0, c.forEach(this.renderItem, this), c.forEach(this.layoutItem, this), c = (this.widthOption || this.offsetWidth) + l;
                var u = this.lastItemY + this.lastLineHeight + this.titleHeight;
                u = this.handleOverflow(u), u += l, o || (this.box = o = n.rect().addClass("highcharts-legend-box").attr({r: a.borderRadius}).add(r), o.isNew = !0), i.styledMode || o.attr({
                    stroke: a.borderColor,
                    "stroke-width": a.borderWidth || 0,
                    fill: a.backgroundColor || "none"
                }).shadow(a.shadow), 0 < c && 0 < u && (o[o.isNew ? "attr" : "animate"](o.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: c,
                    height: u
                }, o.strokeWidth())), o.isNew = !1), o[e ? "show" : "hide"](), i.styledMode && "none" === r.getStyle("display") && (c = u = 0), this.legendWidth = c, this.legendHeight = u, e && (o = (n = i.spacingBox).y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < i.titleOffset[0] ? o += i.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < i.titleOffset[2] && (o -= i.titleOffset[2]), o !== n.y && (n = h(n, {y: o})), r.align(h(a, {
                    width: c,
                    height: u,
                    verticalAlign: this.proximate ? "top" : a.verticalAlign
                }), !0, n)), this.proximate || this.positionItems(), s(this, "afterRender")
            }, handleOverflow: function (t) {
                var e = this, i = this.chart, n = i.renderer, r = this.options, o = r.y, a = this.padding;
                o = i.spacingBox.height + ("top" === r.verticalAlign ? -o : o) - a;
                var s, l, h = r.maxHeight, u = this.clipRect, d = r.navigation, f = c(d.animation, !0),
                    p = d.arrowSize || 12, g = this.nav, m = this.pages, v = this.allItems, y = function (t) {
                        "number" == typeof t ? u.attr({height: t}) : u && (e.clipRect = u.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? "rect(" + a + "px,9999px," + (a + t) + "px,0)" : "auto")
                    }, x = function (t) {
                        return e[t] = n.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(g), i.styledMode || e[t].attr("fill", "rgba(0,0,0,0.0001)"), e[t]
                    };
                return "horizontal" !== r.layout || "middle" === r.verticalAlign || r.floating || (o /= 2), h && (o = Math.min(o, h)), m.length = 0, t > o && !1 !== d.enabled ? (this.clipHeight = s = Math.max(o - 20 - this.titleHeight - a, 0), this.currentPage = c(this.currentPage, 1), this.fullHeight = t, v.forEach(function (t, e) {
                    var i = t._legendItemPos[1], n = Math.round(t.legendItem.getBBox().height), r = m.length;
                    (!r || i - m[r - 1] > s && (l || i) !== m[r - 1]) && (m.push(l || i), r++), t.pageIx = r - 1, l && (v[e - 1].pageIx = r - 1), e === v.length - 1 && i + n - m[r - 1] > s && i !== l && (m.push(i), t.pageIx = r), i !== l && (l = i)
                }), u || (u = e.clipRect = n.clipRect(0, a, 9999, 0), e.contentGroup.clip(u)), y(s), g || (this.nav = g = n.g().attr({zIndex: 1}).add(this.group), this.up = n.symbol("triangle", 0, 0, p, p).add(g), x("upTracker").on("click", function () {
                    e.scroll(-1, f)
                }), this.pager = n.text("", 15, 10).addClass("highcharts-legend-navigation"), i.styledMode || this.pager.css(d.style), this.pager.add(g), this.down = n.symbol("triangle-down", 0, 0, p, p).add(g), x("downTracker").on("click", function () {
                    e.scroll(1, f)
                })), e.scroll(0), t = o) : g && (y(), this.nav = g.destroy(), this.scrollGroup.attr({translateY: 1}), this.clipHeight = 0), t
            }, scroll: function (t, e) {
                var i = this.pages, n = i.length, r = this.currentPage + t;
                t = this.clipHeight;
                var o = this.options.navigation, a = this.pager, s = this.padding;
                r > n && (r = n), 0 < r && (void 0 !== e && u(e, this.chart), this.nav.attr({
                    translateX: s,
                    translateY: t + this.padding + 7 + this.titleHeight,
                    visibility: "visible"
                }), [this.up, this.upTracker].forEach(function (t) {
                    t.attr({class: 1 === r ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"})
                }), a.attr({text: r + "/" + n}), [this.down, this.downTracker].forEach(function (t) {
                    t.attr({
                        x: 18 + this.pager.getBBox().width,
                        class: r === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    })
                }, this), this.chart.styledMode || (this.up.attr({fill: 1 === r ? o.inactiveColor : o.activeColor}), this.upTracker.css({cursor: 1 === r ? "default" : "pointer"}), this.down.attr({fill: r === n ? o.inactiveColor : o.activeColor}), this.downTracker.css({cursor: r === n ? "default" : "pointer"})), this.scrollOffset = -i[r - 1] + this.initialItemY, this.scrollGroup.animate({translateY: this.scrollOffset}), this.currentPage = r, this.positionCheckboxes())
            }
        }, t.LegendSymbolMixin = {
            drawRectangle: function (t, e) {
                var i = t.symbolHeight, n = t.options.squareSymbol;
                e.legendSymbol = this.chart.renderer.rect(n ? (t.symbolWidth - i) / 2 : 0, t.baseline - i + 1, n ? i : t.symbolWidth, i, c(t.options.symbolRadius, i / 2)).addClass("highcharts-point").attr({zIndex: 3}).add(e.legendGroup)
            }, drawLineMarker: function (t) {
                var e = this.options, i = e.marker, n = t.symbolWidth, r = t.symbolHeight, o = r / 2,
                    a = this.chart.renderer, s = this.legendGroup;
                t = t.baseline - Math.round(.3 * t.fontMetrics.b);
                var l = {};
                this.chart.styledMode || (l = {"stroke-width": e.lineWidth || 0}, e.dashStyle && (l.dashstyle = e.dashStyle)), this.legendLine = a.path(["M", 0, t, "L", n, t]).addClass("highcharts-graph").attr(l).add(s), i && !1 !== i.enabled && n && (e = Math.min(c(i.radius, o), o), 0 === this.symbol.indexOf("url") && (i = h(i, {
                    width: r,
                    height: r
                }), e = 0), this.legendSymbol = i = a.symbol(this.symbol, n / 2 - e, t - e, 2 * e, 2 * e, i).addClass("highcharts-point").add(s), i.isMarker = !0)
            }
        }, (/Trident\/7\.0/.test(f.navigator && f.navigator.userAgent) || e) && p(t.Legend.prototype, "positionItem", function (t, e) {
            var i = this, n = function () {
                e._legendItemPos && t.call(i, e)
            };
            n(), i.bubbleLegend || setTimeout(n)
        })
    }), e(i, "parts/Chart.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.attr, n = e.defined, r = e.erase, o = e.isArray, a = e.isNumber, s = e.isObject, l = e.isString,
            h = e.objectEach, c = e.pInt, u = e.splat, d = t.addEvent, f = t.animate, p = t.animObject, g = t.doc,
            m = t.Axis, v = t.createElement, y = t.defaultOptions, x = t.discardElement, b = t.charts, M = t.css,
            A = t.extend, w = t.find, k = t.fireEvent, S = t.Legend, T = t.marginNames, E = t.merge, C = t.Pointer,
            D = t.pick, P = t.removeEvent, _ = t.seriesTypes, O = t.syncTimeout, L = t.win, N = t.Chart = function () {
                this.getArgs.apply(this, arguments)
            };
        t.chart = function (t, e, i) {
            return new N(t, e, i)
        }, A(N.prototype, {
            callbacks: [], getArgs: function () {
                var t = [].slice.call(arguments);
                (l(t[0]) || t[0].nodeName) && (this.renderTo = t.shift()), this.init(t[0], t[1])
            }, init: function (e, i) {
                var n, r = e.series, o = e.plotOptions || {};
                k(this, "init", {args: arguments}, function () {
                    e.series = null, n = E(y, e), h(n.plotOptions, function (t, e) {
                        s(t) && (t.tooltip = o[e] && E(o[e].tooltip) || void 0)
                    }), n.tooltip.userOptions = e.chart && e.chart.forExport && e.tooltip.userOptions || e.tooltip, n.series = e.series = r, this.userOptions = e;
                    var a = n.chart, l = a.events;
                    this.margin = [], this.spacing = [], this.bounds = {
                        h: {},
                        v: {}
                    }, this.labelCollectors = [], this.callback = i, this.isResizing = 0, this.options = n, this.axes = [], this.series = [], this.time = e.time && Object.keys(e.time).length ? new t.Time(e.time) : t.time, this.styledMode = a.styledMode, this.hasCartesianSeries = a.showAxes;
                    var c = this;
                    c.index = b.length, b.push(c), t.chartCount++, l && h(l, function (e, i) {
                        t.isFunction(e) && d(c, i, e)
                    }), c.xAxis = [], c.yAxis = [], c.pointCount = c.colorCounter = c.symbolCounter = 0, k(c, "afterInit"), c.firstRender()
                })
            }, initSeries: function (e) {
                var i = this.options.chart;
                return (i = _[e.type || i.type || i.defaultSeriesType]) || t.error(17, !0, this), (i = new i).init(this, e), i
            }, orderSeries: function (t) {
                var e = this.series;
                for (t = t || 0; t < e.length; t++) e[t] && (e[t].index = t, e[t].name = e[t].getName())
            }, isInsidePlot: function (t, e, i) {
                var n = i ? e : t;
                return t = i ? t : e, 0 <= n && n <= this.plotWidth && 0 <= t && t <= this.plotHeight
            }, redraw: function (e) {
                k(this, "beforeRedraw");
                var i = this.axes, n = this.series, r = this.pointer, o = this.legend, a = this.userOptions.legend,
                    s = this.isDirtyLegend, l = this.hasCartesianSeries, h = this.isDirtyBox, c = this.renderer,
                    u = c.isHidden(), d = [];
                for (this.setResponsive && this.setResponsive(!1), t.setAnimation(e, this), u && this.temporaryDisplay(), this.layOutTitles(), e = n.length; e--;) {
                    var f = n[e];
                    if (f.options.stacking) {
                        var p = !0;
                        if (f.isDirty) {
                            var g = !0;
                            break
                        }
                    }
                }
                if (g) for (e = n.length; e--;) (f = n[e]).options.stacking && (f.isDirty = !0);
                n.forEach(function (t) {
                    t.isDirty && ("point" === t.options.legendType ? (t.updateTotals && t.updateTotals(), s = !0) : a && (a.labelFormatter || a.labelFormat) && (s = !0)), t.isDirtyData && k(t, "updatedData")
                }), s && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), p && this.getStacks(), l && i.forEach(function (t) {
                    t.updateNames(), t.setScale()
                }), this.getMargins(), l && (i.forEach(function (t) {
                    t.isDirty && (h = !0)
                }), i.forEach(function (t) {
                    var e = t.min + "," + t.max;
                    t.extKey !== e && (t.extKey = e, d.push(function () {
                        k(t, "afterSetExtremes", A(t.eventArgs, t.getExtremes())), delete t.eventArgs
                    })), (h || p) && t.redraw()
                })), h && this.drawChartBox(), k(this, "predraw"), n.forEach(function (t) {
                    (h || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1
                }), r && r.reset(!0), c.draw(), k(this, "redraw"), k(this, "render"), u && this.temporaryDisplay(!0), d.forEach(function (t) {
                    t.call()
                })
            }, get: function (t) {
                function e(e) {
                    return e.id === t || e.options && e.options.id === t
                }

                var i, n = this.series, r = w(this.axes, e) || w(this.series, e);
                for (i = 0; !r && i < n.length; i++) r = w(n[i].points || [], e);
                return r
            }, getAxes: function () {
                var t = this, e = this.options, i = e.xAxis = u(e.xAxis || {});
                e = e.yAxis = u(e.yAxis || {}), k(this, "getAxes"), i.forEach(function (t, e) {
                    t.index = e, t.isX = !0
                }), e.forEach(function (t, e) {
                    t.index = e
                }), i.concat(e).forEach(function (e) {
                    new m(t, e)
                }), k(this, "afterGetAxes")
            }, getSelectedPoints: function () {
                var t = [];
                return this.series.forEach(function (e) {
                    t = t.concat((e[e.hasGroupedData ? "points" : "data"] || []).filter(function (t) {
                        return D(t.selectedStaging, t.selected)
                    }))
                }), t
            }, getSelectedSeries: function () {
                return this.series.filter(function (t) {
                    return t.selected
                })
            }, setTitle: function (t, e, i) {
                this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i)
            }, applyDescription: function (t, e) {
                var i = this, n = "title" === t ? {
                    color: "#333333",
                    fontSize: this.options.isStock ? "16px" : "18px"
                } : {color: "#666666"};
                n = this.options[t] = E(!this.styledMode && {style: n}, this.options[t], e);
                var r = this[t];
                r && e && (this[t] = r = r.destroy()), n && !r && ((r = this.renderer.text(n.text, 0, 0, n.useHTML).attr({
                    align: n.align,
                    class: "highcharts-" + t,
                    zIndex: n.zIndex || 4
                }).add()).update = function (e) {
                    i[{title: "setTitle", subtitle: "setSubtitle", caption: "setCaption"}[t]](e)
                }, this.styledMode || r.css(n.style), this[t] = r)
            }, layOutTitles: function (t) {
                var e = [0, 0, 0], i = this.renderer, n = this.spacingBox;
                ["title", "subtitle", "caption"].forEach(function (t) {
                    var r = this[t], o = this.options[t], a = o.verticalAlign || "top";
                    if (t = "title" === t ? -3 : "top" === a ? e[0] + 2 : 0, r) {
                        if (!this.styledMode) var s = o.style.fontSize;
                        s = i.fontMetrics(s, r).b, r.css({width: (o.width || n.width + (o.widthAdjust || 0)) + "px"});
                        var l = r.getBBox(o.useHTML).height;
                        r.align(A({
                            y: "bottom" === a ? s : t + s,
                            height: l
                        }, o), !1, "spacingBox"), o.floating || ("top" === a ? e[0] = Math.ceil(e[0] + l) : "bottom" === a && (e[2] = Math.ceil(e[2] + l)))
                    }
                }, this), e[0] && "top" === (this.options.title.verticalAlign || "top") && (e[0] += this.options.title.margin), e[2] && "bottom" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);
                var r = !this.titleOffset || this.titleOffset.join(",") !== e.join(",");
                this.titleOffset = e, !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && D(t, !0) && this.isDirtyBox && this.redraw())
            }, getChartSize: function () {
                var e = this.options.chart, i = e.width;
                e = e.height;
                var r = this.renderTo;
                n(i) || (this.containerWidth = t.getStyle(r, "width")), n(e) || (this.containerHeight = t.getStyle(r, "height")), this.chartWidth = Math.max(0, i || this.containerWidth || 600), this.chartHeight = Math.max(0, t.relativeLength(e, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400))
            }, temporaryDisplay: function (e) {
                var i = this.renderTo;
                if (e) for (; i && i.style;) i.hcOrigStyle && (t.css(i, i.hcOrigStyle), delete i.hcOrigStyle), i.hcOrigDetached && (g.body.removeChild(i), i.hcOrigDetached = !1), i = i.parentNode; else for (; i && i.style && (g.body.contains(i) || i.parentNode || (i.hcOrigDetached = !0, g.body.appendChild(i)), ("none" === t.getStyle(i, "display", !1) || i.hcOricDetached) && (i.hcOrigStyle = {
                    display: i.style.display,
                    height: i.style.height,
                    overflow: i.style.overflow
                }, e = {
                    display: "block",
                    overflow: "hidden"
                }, i !== this.renderTo && (e.height = 0), t.css(i, e), i.offsetWidth || i.style.setProperty("display", "block", "important")), (i = i.parentNode) !== g.body);) ;
            }, setClassName: function (t) {
                this.container.className = "highcharts-container " + (t || "")
            }, getContainer: function () {
                var e, n, r = this.options, o = r.chart, s = this.renderTo, h = t.uniqueKey();
                s || (this.renderTo = s = o.renderTo), l(s) && (this.renderTo = s = g.getElementById(s)), s || t.error(13, !0, this);
                var u = c(i(s, "data-highcharts-chart"));
                a(u) && b[u] && b[u].hasRendered && b[u].destroy(), i(s, "data-highcharts-chart", this.index), s.innerHTML = "", o.skipClone || s.offsetWidth || this.temporaryDisplay(), this.getChartSize(), u = this.chartWidth;
                var d = this.chartHeight;
                if (M(s, {overflow: "hidden"}), this.styledMode || (e = A({
                    position: "relative",
                    overflow: "hidden",
                    width: u + "px",
                    height: d + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
                }, o.style)), this.container = s = v("div", {id: h}, e, s), this._cursor = s.style.cursor, this.renderer = new (t[o.renderer] || t.Renderer)(s, u, d, null, o.forExport, r.exporting && r.exporting.allowHTML, this.styledMode), this.setClassName(o.className), this.styledMode) for (n in r.defs) this.renderer.definition(r.defs[n]); else this.renderer.setStyle(o.style);
                this.renderer.chartIndex = this.index, k(this, "afterGetContainer")
            }, getMargins: function (t) {
                var e = this.spacing, i = this.margin, r = this.titleOffset;
                this.resetMargins(), r[0] && !n(i[0]) && (this.plotTop = Math.max(this.plotTop, r[0] + e[0])), r[2] && !n(i[2]) && (this.marginBottom = Math.max(this.marginBottom, r[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), k(this, "getMargins"), t || this.getAxisMargins()
            }, getAxisMargins: function () {
                var t = this, e = t.axisOffset = [0, 0, 0, 0], i = t.colorAxis, r = t.margin, o = function (t) {
                    t.forEach(function (t) {
                        t.visible && t.getOffset()
                    })
                };
                t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), T.forEach(function (i, o) {
                    n(r[o]) || (t[i] += e[o])
                }), t.setChartSize()
            }, reflow: function (e) {
                var i = this, r = i.options.chart, o = i.renderTo, a = n(r.width) && n(r.height),
                    s = r.width || t.getStyle(o, "width");
                r = r.height || t.getStyle(o, "height"), o = e ? e.target : L, a || i.isPrinting || !s || !r || o !== L && o !== g || (s === i.containerWidth && r === i.containerHeight || (t.clearTimeout(i.reflowTimeout), i.reflowTimeout = O(function () {
                    i.container && i.setSize(void 0, void 0, !1)
                }, e ? 100 : 0)), i.containerWidth = s, i.containerHeight = r)
            }, setReflow: function (t) {
                var e = this;
                !1 === t || this.unbindReflow ? !1 === t && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = d(L, "resize", function (t) {
                    e.options && e.reflow(t)
                }), d(this, "destroy", this.unbindReflow))
            }, setSize: function (e, i, n) {
                var r = this, o = r.renderer;
                if (r.isResizing += 1, t.setAnimation(n, r), r.oldChartHeight = r.chartHeight, r.oldChartWidth = r.chartWidth, void 0 !== e && (r.options.chart.width = e), void 0 !== i && (r.options.chart.height = i), r.getChartSize(), !r.styledMode) {
                    var a = o.globalAnimation;
                    (a ? f : M)(r.container, {width: r.chartWidth + "px", height: r.chartHeight + "px"}, a)
                }
                r.setChartSize(!0), o.setSize(r.chartWidth, r.chartHeight, n), r.axes.forEach(function (t) {
                    t.isDirty = !0, t.setScale()
                }), r.isDirtyLegend = !0, r.isDirtyBox = !0, r.layOutTitles(), r.getMargins(), r.redraw(n), r.oldChartHeight = null, k(r, "resize"), O(function () {
                    r && k(r, "endResize", null, function () {
                        --r.isResizing
                    })
                }, p(a).duration)
            }, setChartSize: function (t) {
                var e, i, n, r, o = this.inverted, a = this.renderer, s = this.chartWidth, l = this.chartHeight,
                    h = this.options.chart, c = this.spacing, u = this.clipOffset;
                this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = n = Math.max(0, Math.round(s - e - this.marginRight)), this.plotHeight = r = Math.max(0, Math.round(l - i - this.marginBottom)), this.plotSizeX = o ? r : n, this.plotSizeY = o ? n : r, this.plotBorderWidth = h.plotBorderWidth || 0, this.spacingBox = a.spacingBox = {
                    x: c[3],
                    y: c[0],
                    width: s - c[3] - c[1],
                    height: l - c[0] - c[2]
                }, this.plotBox = a.plotBox = {
                    x: e,
                    y: i,
                    width: n,
                    height: r
                }, s = 2 * Math.floor(this.plotBorderWidth / 2), o = Math.ceil(Math.max(s, u[3]) / 2), a = Math.ceil(Math.max(s, u[0]) / 2), this.clipBox = {
                    x: o,
                    y: a,
                    width: Math.floor(this.plotSizeX - Math.max(s, u[1]) / 2 - o),
                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(s, u[2]) / 2 - a))
                }, t || this.axes.forEach(function (t) {
                    t.setAxisSize(), t.setAxisTranslation()
                }), k(this, "afterSetChartSize", {skipAxes: t})
            }, resetMargins: function () {
                k(this, "resetMargins");
                var t = this, e = t.options.chart;
                ["margin", "spacing"].forEach(function (i) {
                    var n = e[i], r = s(n) ? n : [n, n, n, n];
                    ["Top", "Right", "Bottom", "Left"].forEach(function (n, o) {
                        t[i][o] = D(e[i + n], r[o])
                    })
                }), T.forEach(function (e, i) {
                    t[e] = D(t.margin[i], t.spacing[i])
                }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [0, 0, 0, 0]
            }, drawChartBox: function () {
                var t, e = this.options.chart, i = this.renderer, n = this.chartWidth, r = this.chartHeight,
                    o = this.chartBackground, a = this.plotBackground, s = this.plotBorder, l = this.styledMode,
                    h = this.plotBGImage, c = e.backgroundColor, u = e.plotBackgroundColor, d = e.plotBackgroundImage,
                    f = this.plotLeft, p = this.plotTop, g = this.plotWidth, m = this.plotHeight, v = this.plotBox,
                    y = this.clipRect, x = this.clipBox, b = "animate";
                if (o || (this.chartBackground = o = i.rect().addClass("highcharts-background").add(), b = "attr"), l) var M = t = o.strokeWidth(); else t = (M = e.borderWidth || 0) + (e.shadow ? 8 : 0), c = {fill: c || "none"}, (M || o["stroke-width"]) && (c.stroke = e.borderColor, c["stroke-width"] = M), o.attr(c).shadow(e.shadow);
                o[b]({
                    x: t / 2,
                    y: t / 2,
                    width: n - t - M % 2,
                    height: r - t - M % 2,
                    r: e.borderRadius
                }), b = "animate", a || (b = "attr", this.plotBackground = a = i.rect().addClass("highcharts-plot-background").add()), a[b](v), l || (a.attr({fill: u || "none"}).shadow(e.plotShadow), d && (h ? h.animate(v) : this.plotBGImage = i.image(d, f, p, g, m).add())), y ? y.animate({
                    width: x.width,
                    height: x.height
                }) : this.clipRect = i.clipRect(x), b = "animate", s || (b = "attr", this.plotBorder = s = i.rect().addClass("highcharts-plot-border").attr({zIndex: 1}).add()), l || s.attr({
                    stroke: e.plotBorderColor,
                    "stroke-width": e.plotBorderWidth || 0,
                    fill: "none"
                }), s[b](s.crisp({
                    x: f,
                    y: p,
                    width: g,
                    height: m
                }, -s.strokeWidth())), this.isDirtyBox = !1, k(this, "afterDrawChartBox")
            }, propFromSeries: function () {
                var t, e, i, n = this, r = n.options.chart, o = n.options.series;
                ["inverted", "angular", "polar"].forEach(function (a) {
                    for (t = _[r.type || r.defaultSeriesType], i = r[a] || t && t.prototype[a], e = o && o.length; !i && e--;) (t = _[o[e].type]) && t.prototype[a] && (i = !0);
                    n[a] = i
                })
            }, linkSeries: function () {
                var t = this, e = t.series;
                e.forEach(function (t) {
                    t.linkedSeries.length = 0
                }), e.forEach(function (e) {
                    var i = e.options.linkedTo;
                    l(i) && (i = ":previous" === i ? t.series[e.index - 1] : t.get(i)) && i.linkedParent !== e && (i.linkedSeries.push(e), e.linkedParent = i, e.visible = D(e.options.visible, i.options.visible, e.visible))
                }), k(this, "afterLinkSeries")
            }, renderSeries: function () {
                this.series.forEach(function (t) {
                    t.translate(), t.render()
                })
            }, renderLabels: function () {
                var t = this, e = t.options.labels;
                e.items && e.items.forEach(function (i) {
                    var n = A(e.style, i.style), r = c(n.left) + t.plotLeft, o = c(n.top) + t.plotTop + 12;
                    delete n.left, delete n.top, t.renderer.text(i.html, r, o).attr({zIndex: 2}).css(n).add()
                })
            }, render: function () {
                var t = this.axes, e = this.colorAxis, i = this.renderer, n = this.options, r = 0, o = function (t) {
                    t.forEach(function (t) {
                        t.visible && t.render()
                    })
                };
                this.setTitle(), this.legend = new S(this, n.legend), this.getStacks && this.getStacks(), this.getMargins(!0), this.setChartSize(), n = this.plotWidth, t.some(function (t) {
                    if (t.horiz && t.visible && t.options.labels.enabled && t.series.length) return r = 21, !0
                });
                var a = this.plotHeight = Math.max(this.plotHeight - r, 0);
                t.forEach(function (t) {
                    t.setScale()
                }), this.getAxisMargins();
                var s = 1.1 < n / this.plotWidth, l = 1.05 < a / this.plotHeight;
                (s || l) && (t.forEach(function (t) {
                    (t.horiz && s || !t.horiz && l) && t.setTickInterval(!0)
                }), this.getMargins()), this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({zIndex: 3}).add()), this.renderSeries(), this.renderLabels(), this.addCredits(), this.setResponsive && this.setResponsive(), this.updateContainerScaling(), this.hasRendered = !0
            }, addCredits: function (t) {
                var e = this;
                (t = E(!0, this.options.credits, t)).enabled && !this.credits && (this.credits = this.renderer.text(t.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                    t.href && (L.location.href = t.href)
                }).attr({
                    align: t.position.align,
                    zIndex: 8
                }), e.styledMode || this.credits.css(t.style), this.credits.add().align(t.position), this.credits.update = function (t) {
                    e.credits = e.credits.destroy(), e.addCredits(t)
                })
            }, updateContainerScaling: function () {
                var t = this.container;
                if (t.offsetWidth && t.offsetHeight && t.getBoundingClientRect) {
                    var e = t.getBoundingClientRect(), i = e.width / t.offsetWidth;
                    t = e.height / t.offsetHeight, 1 !== i || 1 !== t ? this.containerScaling = {
                        scaleX: i,
                        scaleY: t
                    } : delete this.containerScaling
                }
            }, destroy: function () {
                var e, i = this, n = i.axes, o = i.series, a = i.container, s = a && a.parentNode;
                for (k(i, "destroy"), i.renderer.forExport ? r(b, i) : b[i.index] = void 0, t.chartCount--, i.renderTo.removeAttribute("data-highcharts-chart"), P(i), e = n.length; e--;) n[e] = n[e].destroy();
                for (this.scroller && this.scroller.destroy && this.scroller.destroy(), e = o.length; e--;) o[e] = o[e].destroy();
                "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (t) {
                    var e = i[t];
                    e && e.destroy && (i[t] = e.destroy())
                }), a && (a.innerHTML = "", P(a), s && x(a)), h(i, function (t, e) {
                    delete i[e]
                })
            }, firstRender: function () {
                var t = this, e = t.options;
                t.isReadyToRender && !t.isReadyToRender() || (t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes(), (o(e.series) ? e.series : []).forEach(function (e) {
                    t.initSeries(e)
                }), t.linkSeries(), k(t, "beforeRender"), C && (t.pointer = new C(t, e)), t.render(), !t.renderer.imgCount && t.onload && t.onload(), t.temporaryDisplay(!0))
            }, onload: function () {
                this.callbacks.concat([this.callback]).forEach(function (t) {
                    t && void 0 !== this.index && t.apply(this, [this])
                }, this), k(this, "load"), k(this, "render"), n(this.index) && this.setReflow(this.options.chart.reflow), this.onload = null
            }
        })
    }), e(i, "parts/ScrollablePlotArea.js", [i["parts/Globals.js"]], function (t) {
        var e = t.addEvent, i = t.Chart;
        e(i, "afterSetChartSize", function (e) {
            var i = this.options.chart.scrollablePlotArea, n = i && i.minWidth;
            if (i = i && i.minHeight, !this.renderer.forExport) {
                if (n) {
                    if (this.scrollablePixelsX = n = Math.max(0, n - this.chartWidth)) {
                        this.plotWidth += n, this.inverted ? (this.clipBox.height += n, this.plotBox.height += n) : (this.clipBox.width += n, this.plotBox.width += n);
                        var r = {1: {name: "right", value: n}}
                    }
                } else i && (this.scrollablePixelsY = n = Math.max(0, i - this.chartHeight)) && (this.plotHeight += n, this.inverted ? (this.clipBox.width += n, this.plotBox.width += n) : (this.clipBox.height += n, this.plotBox.height += n), r = {
                    2: {
                        name: "bottom",
                        value: n
                    }
                });
                r && !e.skipAxes && this.axes.forEach(function (e) {
                    r[e.side] ? e.getPlotLinePath = function () {
                        var i = r[e.side].name, n = this[i];
                        this[i] = n - r[e.side].value;
                        var o = t.Axis.prototype.getPlotLinePath.apply(this, arguments);
                        return this[i] = n, o
                    } : (e.setAxisSize(), e.setAxisTranslation())
                })
            }
        }), e(i, "render", function () {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed()
        }), i.prototype.setUpScrolling = function () {
            var e = {WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden"};
            this.scrollablePixelsX && (e.overflowX = "auto"), this.scrollablePixelsY && (e.overflowY = "auto"), this.scrollingContainer = t.createElement("div", {className: "highcharts-scrolling"}, e, this.renderTo), this.innerContainer = t.createElement("div", {className: "highcharts-inner-container"}, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null
        }, i.prototype.moveFixedElements = function () {
            var t, e = this.container, i = this.fixedRenderer,
                n = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-reset-zoom .highcharts-subtitle .highcharts-title .highcharts-legend-checkbox".split(" ");
            this.scrollablePixelsX && !this.inverted ? t = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? t = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (t = ".highcharts-yaxis"), n.push(t, t + "-labels"), n.forEach(function (t) {
                [].forEach.call(e.querySelectorAll(t), function (t) {
                    (t.namespaceURI === i.SVG_NS ? i.box : i.box.parentNode).appendChild(t), t.style.pointerEvents = "auto"
                })
            })
        }, i.prototype.applyFixed = function () {
            var i, n = !this.fixedDiv, r = this.options.chart.scrollablePlotArea;
            n ? (this.fixedDiv = t.createElement("div", {className: "highcharts-fixed"}, {
                position: "absolute",
                overflow: "hidden",
                pointerEvents: "none",
                zIndex: 2
            }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = "visible", this.fixedRenderer = i = new t.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = i.path().attr({
                fill: t.color(this.options.chart.backgroundColor || "#fff").setOpacity(t.pick(r.opacity, .85)).get(),
                zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), e(this, "afterShowResetZoom", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight), i = this.chartWidth + (this.scrollablePixelsX || 0);
            var o = this.chartHeight + (this.scrollablePixelsY || 0);
            t.stop(this.container), this.container.style.width = i + "px", this.container.style.height = o + "px", this.renderer.boxWrapper.attr({
                width: i,
                height: o,
                viewBox: [0, 0, i, o].join(" ")
            }), this.chartBackground.attr({
                width: i,
                height: o
            }), this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + "px"), n && (r.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * r.scrollPositionX), r.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * r.scrollPositionY)), o = this.axisOffset, n = this.plotTop - o[0] - 1, r = this.plotLeft - o[3] - 1, i = this.plotTop + this.plotHeight + o[2] + 1, o = this.plotLeft + this.plotWidth + o[1] + 1;
            var a = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                s = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            n = this.scrollablePixelsX ? ["M", 0, n, "L", this.plotLeft - 1, n, "L", this.plotLeft - 1, i, "L", 0, i, "Z", "M", a, n, "L", this.chartWidth, n, "L", this.chartWidth, i, "L", a, i, "Z"] : this.scrollablePixelsY ? ["M", r, 0, "L", r, this.plotTop - 1, "L", o, this.plotTop - 1, "L", o, 0, "Z", "M", r, s, "L", r, this.chartHeight, "L", o, this.chartHeight, "L", o, s, "Z"] : ["M", 0, 0], "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({d: n})
        }
    }), e(i, "parts/Point.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i, n = e.defined, r = e.erase, o = e.isArray, a = e.isNumber, s = e.isObject, l = t.extend, h = t.fireEvent,
            c = t.format, u = t.pick, d = t.uniqueKey, f = t.removeEvent;
        t.Point = i = function () {
        }, t.Point.prototype = {
            init: function (t, e, i) {
                return this.series = t, this.applyOptions(e, i), this.id = n(this.id) ? this.id : d(), this.resolveColor(), t.chart.pointCount++, h(this, "afterInit"), this
            }, resolveColor: function () {
                var t = this.series, e = t.chart.options.chart.colorCount, i = t.chart.styledMode;
                i || this.options.color || (this.color = t.color), t.options.colorByPoint ? (i || (e = t.options.colors || t.chart.options.colors, this.color = this.color || e[t.colorCounter], e = e.length), i = t.colorCounter, t.colorCounter++, t.colorCounter === e && (t.colorCounter = 0)) : i = t.colorIndex, this.colorIndex = u(this.colorIndex, i)
            }, applyOptions: function (t, e) {
                var n = this.series, r = n.options.pointValKey || n.pointValKey;
                return t = i.prototype.optionsToObject.call(this, t), l(this, t), this.options = this.options ? l(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, r && (this.y = this[r]), this.formatPrefix = (this.isNull = u(this.isValid && !this.isValid(), null === this.x || !a(this.y))) ? "null" : "point", this.selected && (this.state = "select"), "name" in this && void 0 === e && n.xAxis && n.xAxis.hasNames && (this.x = n.xAxis.nameToX(this)), void 0 === this.x && n && (this.x = void 0 === e ? n.autoIncrement(this) : e), this
            }, setNestedProperty: function (t, e, i) {
                return i.split(".").reduce(function (t, i, n, r) {
                    return t[i] = r.length - 1 === n ? e : s(t[i], !0) ? t[i] : {}, t[i]
                }, t), t
            }, optionsToObject: function (e) {
                var i = {}, n = this.series, r = n.options.keys, s = r || n.pointArrayMap || ["y"], l = s.length, h = 0,
                    c = 0;
                if (a(e) || null === e) i[s[0]] = e; else if (o(e)) for (!r && e.length > l && ("string" === (n = typeof e[0]) ? i.name = e[0] : "number" === n && (i.x = e[0]), h++); c < l;) r && void 0 === e[h] || (0 < s[c].indexOf(".") ? t.Point.prototype.setNestedProperty(i, e[h], s[c]) : i[s[c]] = e[h]), h++, c++; else "object" == typeof e && (i = e, e.dataLabels && (n._hasPointLabels = !0), e.marker && (n._hasPointMarkers = !0));
                return i
            }, getClassName: function () {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "")
            }, getZone: function () {
                var t = this.series, e = t.zones;
                t = t.zoneAxis || "y";
                var i, n = 0;
                for (i = e[n]; this[t] >= i.value;) i = e[++n];
                return this.nonZonedColor || (this.nonZonedColor = this.color), this.color = i && i.color && !this.options.color ? i.color : this.nonZonedColor, i
            }, destroy: function () {
                var t, e = this.series.chart, i = e.hoverPoints;
                for (t in e.pointCount--, i && (this.setState(), r(i, this), i.length || (e.hoverPoints = null)), this === e.hoverPoint && this.onMouseOut(), (this.graphic || this.dataLabel || this.dataLabels) && (f(this), this.destroyElements()), this.legendItem && e.legend.destroyItem(this), this) this[t] = null
            }, destroyElements: function (t) {
                var e, i = this, n = [];
                for ((t = t || {
                    graphic: 1,
                    dataLabel: 1
                }).graphic && n.push("graphic", "shadowGroup"), t.dataLabel && n.push("dataLabel", "dataLabelUpper", "connector"), e = n.length; e--;) {
                    var r = n[e];
                    i[r] && (i[r] = i[r].destroy())
                }
                ["dataLabel", "connector"].forEach(function (e) {
                    var n = e + "s";
                    t[e] && i[n] && (i[n].forEach(function (t) {
                        t.element && t.destroy()
                    }), delete i[n])
                })
            }, getLabelConfig: function () {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                }
            }, tooltipFormatter: function (t) {
                var e = this.series, i = e.tooltipOptions, n = u(i.valueDecimals, ""), r = i.valuePrefix || "",
                    o = i.valueSuffix || "";
                return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || ["y"]).forEach(function (e) {
                    e = "{point." + e, (r || o) && (t = t.replace(RegExp(e + "}", "g"), r + e + "}" + o)), t = t.replace(RegExp(e + "}", "g"), e + ":,." + n + "f}")
                }), c(t, {point: this, series: this.series}, e.chart.time)
            }, firePointEvent: function (t, e, i) {
                var n = this, r = this.series.options;
                (r.point.events[t] || n.options && n.options.events && n.options.events[t]) && this.importEvents(), "click" === t && r.allowPointSelect && (i = function (t) {
                    n.select && n.select(null, t.ctrlKey || t.metaKey || t.shiftKey)
                }), h(this, t, e, i)
            }, visible: !0
        }
    }), e(i, "parts/Series.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.erase, r = e.isArray, o = e.isNumber, a = e.isString, s = e.objectEach, l = e.splat,
            h = t.addEvent, c = t.animObject, u = t.arrayMax, d = t.arrayMin, f = t.correctFloat, p = t.defaultOptions,
            g = t.defaultPlotOptions, m = t.extend, v = t.fireEvent, y = t.merge, x = t.pick, b = t.removeEvent,
            M = t.SVGElement, A = t.syncTimeout, w = t.win;
        t.Series = t.seriesType("line", null, {
            lineWidth: 2,
            allowPointSelect: !1,
            showCheckbox: !1,
            animation: {duration: 1e3},
            events: {},
            marker: {
                lineWidth: 0,
                lineColor: "#ffffff",
                enabledThreshold: 2,
                radius: 4,
                states: {
                    normal: {animation: !0},
                    hover: {animation: {duration: 50}, enabled: !0, radiusPlus: 2, lineWidthPlus: 1},
                    select: {fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2}
                }
            },
            point: {events: {}},
            dataLabels: {
                align: "center",
                formatter: function () {
                    return null === this.y ? "" : t.numberFormat(this.y, -1)
                },
                padding: 5,
                style: {fontSize: "11px", fontWeight: "bold", color: "contrast", textOutline: "1px contrast"},
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {animation: !0},
                hover: {animation: {duration: 50}, lineWidthPlus: 1, marker: {}, halo: {size: 10, opacity: .25}},
                select: {animation: {duration: 0}},
                inactive: {animation: {duration: 50}, opacity: .2}
            },
            stickyTracking: !0,
            turboThreshold: 1e3,
            findNearestPointBy: "x"
        }, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: !1,
            isCartesian: !0,
            parallelArrays: ["x", "y"],
            pointClass: t.Point,
            requireSorting: !0,
            sorted: !0,
            init: function (e, i) {
                v(this, "init", {options: i});
                var n, r = this, o = e.series;
                this.eventOptions = this.eventOptions || {}, r.chart = e, r.options = i = r.setOptions(i), r.linkedSeries = [], r.bindAxes(), m(r, {
                    name: i.name,
                    state: "",
                    visible: !1 !== i.visible,
                    selected: !0 === i.selected
                });
                var a = i.events;
                s(a, function (e, i) {
                    t.isFunction(e) && r.eventOptions[i] !== e && (t.isFunction(r.eventOptions[i]) && b(r, i, r.eventOptions[i]), r.eventOptions[i] = e, h(r, i, e))
                }), (a && a.click || i.point && i.point.events && i.point.events.click || i.allowPointSelect) && (e.runTrackerClick = !0), r.getColor(), r.getSymbol(), r.parallelArrays.forEach(function (t) {
                    r[t + "Data"] || (r[t + "Data"] = [])
                }), r.points || r.data || r.setData(i.data, !1), r.isCartesian && (e.hasCartesianSeries = !0), o.length && (n = o[o.length - 1]), r._i = x(n && n._i, -1) + 1, e.orderSeries(this.insert(o)), v(this, "afterInit")
            },
            insert: function (t) {
                var e, i = this.options.index;
                if (o(i)) {
                    for (e = t.length; e--;) if (i >= x(t[e].options.index, t[e]._i)) {
                        t.splice(e + 1, 0, this);
                        break
                    }
                    -1 === e && t.unshift(this), e += 1
                } else t.push(this);
                return x(e, t.length - 1)
            },
            bindAxes: function () {
                var e, i = this, n = i.options, r = i.chart;
                v(this, "bindAxes", null, function () {
                    (i.axisTypes || []).forEach(function (o) {
                        r[o].forEach(function (t) {
                            e = t.options, (n[o] === e.index || void 0 !== n[o] && n[o] === e.id || void 0 === n[o] && 0 === e.index) && (i.insert(t.series), i[o] = t, t.isDirty = !0)
                        }), i[o] || i.optionalAxis === o || t.error(18, !0, r)
                    })
                })
            },
            updateParallelArrays: function (t, e) {
                var i = t.series, n = arguments, r = o(e) ? function (n) {
                    var r = "y" === n && i.toYData ? i.toYData(t) : t[n];
                    i[n + "Data"][e] = r
                } : function (t) {
                    Array.prototype[e].apply(i[t + "Data"], Array.prototype.slice.call(n, 2))
                };
                i.parallelArrays.forEach(r)
            },
            hasData: function () {
                return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && 0 < this.yData.length
            },
            autoIncrement: function () {
                var t, e = this.options, i = this.xIncrement, n = e.pointIntervalUnit, r = this.chart.time;
                return i = x(i, e.pointStart, 0), this.pointInterval = t = x(this.pointInterval, e.pointInterval, 1), n && (e = new r.Date(i), "day" === n ? r.set("Date", e, r.get("Date", e) + t) : "month" === n ? r.set("Month", e, r.get("Month", e) + t) : "year" === n && r.set("FullYear", e, r.get("FullYear", e) + t), t = e.getTime() - i), this.xIncrement = i + t, i
            },
            setOptions: function (t) {
                var e = this.chart, n = e.options, r = n.plotOptions, o = e.userOptions || {};
                t = y(t), e = e.styledMode;
                var a = {plotOptions: r, userOptions: t};
                v(this, "setOptions", a);
                var s = a.plotOptions[this.type], l = o.plotOptions || {};
                return this.userOptions = a.userOptions, o = y(s, r.series, o.plotOptions && o.plotOptions[this.type], t), this.tooltipOptions = y(p.tooltip, p.plotOptions.series && p.plotOptions.series.tooltip, p.plotOptions[this.type].tooltip, n.tooltip.userOptions, r.series && r.series.tooltip, r[this.type].tooltip, t.tooltip), this.stickyTracking = x(t.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, !(!this.tooltipOptions.shared || this.noSharedTooltip) || o.stickyTracking), null === s.marker && delete o.marker, this.zoneAxis = o.zoneAxis, n = this.zones = (o.zones || []).slice(), !o.negativeColor && !o.negativeFillColor || o.zones || (r = {
                    value: o[this.zoneAxis + "Threshold"] || o.threshold || 0,
                    className: "highcharts-negative"
                }, e || (r.color = o.negativeColor, r.fillColor = o.negativeFillColor), n.push(r)), n.length && i(n[n.length - 1].value) && n.push(e ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                }), v(this, "afterSetOptions", {options: o}), o
            },
            getName: function () {
                return x(this.options.name, "Series " + (this.index + 1))
            },
            getCyclic: function (t, e, n) {
                var r = this.chart, o = this.userOptions, a = t + "Index", s = t + "Counter",
                    l = n ? n.length : x(r.options.chart[t + "Count"], r[t + "Count"]);
                if (!e) {
                    var h = x(o[a], o["_" + a]);
                    i(h) || (r.series.length || (r[s] = 0), o["_" + a] = h = r[s] % l, r[s] += 1), n && (e = n[h])
                }
                void 0 !== h && (this[a] = h), this[t] = e
            },
            getColor: function () {
                this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || g[this.type].color, this.chart.options.colors)
            },
            getSymbol: function () {
                this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols)
            },
            findPointIndex: function (t, e) {
                var i = t.id;
                t = t.x;
                var n, r = this.points;
                if (i) {
                    var a = (i = this.chart.get(i)) && i.index;
                    void 0 !== a && (n = !0)
                }
                return void 0 === a && o(t) && (a = this.xData.indexOf(t, e)), -1 !== a && void 0 !== a && this.cropped && (a = a >= this.cropStart ? a - this.cropStart : a), !n && r[a] && r[a].touched && (a = void 0), a
            },
            drawLegendSymbol: t.LegendSymbolMixin.drawLineMarker,
            updateData: function (t) {
                var e, n, r, a = this.options, s = this.points, l = [], h = this.requireSorting,
                    c = t.length === s.length, u = !0;
                if (this.xIncrement = null, t.forEach(function (t, n) {
                    var u = i(t) && this.pointClass.prototype.optionsToObject.call({series: this}, t) || {}, d = u.x;
                    (u.id || o(d)) && (-1 === (d = this.findPointIndex(u, r)) || void 0 === d ? l.push(t) : s[d] && t !== a.data[d] ? (s[d].update(t, !1, null, !1), s[d].touched = !0, h && (r = d + 1)) : s[d] && (s[d].touched = !0), (!c || n !== d || this.hasDerivedData) && (e = !0))
                }, this), e) for (t = s.length; t--;) (n = s[t]) && !n.touched && n.remove(!1); else c ? t.forEach(function (t, e) {
                    s[e].update && t !== s[e].y && s[e].update(t, !1, null, !1)
                }) : u = !1;
                return s.forEach(function (t) {
                    t && (t.touched = !1)
                }), !!u && (l.forEach(function (t) {
                    this.addPoint(t, !1, null, null, !1)
                }, this), !0)
            },
            setData: function (e, i, n, s) {
                var l, h, c = this, u = c.points, d = u && u.length || 0, f = c.options, p = c.chart, g = null,
                    m = c.xAxis, v = f.turboThreshold, y = this.xData, b = this.yData,
                    M = (l = c.pointArrayMap) && l.length, A = f.keys, w = 0, k = 1;
                if (l = (e = e || []).length, i = x(i, !0), !1 !== s && l && d && !c.cropped && !c.hasGroupedData && c.visible && !c.isSeriesBoosting && (h = this.updateData(e)), !h) {
                    if (c.xIncrement = null, c.colorCounter = 0, this.parallelArrays.forEach(function (t) {
                        c[t + "Data"].length = 0
                    }), v && l > v) {
                        for (n = 0; null === g && n < l;) g = e[n], n++;
                        if (o(g)) for (n = 0; n < l; n++) y[n] = this.autoIncrement(), b[n] = e[n]; else if (r(g)) if (M) for (n = 0; n < l; n++) g = e[n], y[n] = g[0], b[n] = g.slice(1, M + 1); else for (A && (w = 0 <= (w = A.indexOf("x")) ? w : 0, k = 0 <= (k = A.indexOf("y")) ? k : 1), n = 0; n < l; n++) g = e[n], y[n] = g[w], b[n] = g[k]; else t.error(12, !1, p)
                    } else for (n = 0; n < l; n++) void 0 !== e[n] && (g = {series: c}, c.pointClass.prototype.applyOptions.apply(g, [e[n]]), c.updateParallelArrays(g, n));
                    for (b && a(b[0]) && t.error(14, !0, p), c.data = [], c.options.data = c.userOptions.data = e, n = d; n--;) u[n] && u[n].destroy && u[n].destroy();
                    m && (m.minRange = m.userMinRange), c.isDirty = p.isDirtyBox = !0, c.isDirtyData = !!u, n = !1
                }
                "point" === f.legendType && (this.processData(), this.generatePoints()), i && p.redraw(n)
            },
            processData: function (e) {
                var i = this.xData, n = this.yData, r = i.length, o = 0, a = this.xAxis, s = this.options,
                    l = s.cropThreshold, h = this.getExtremesFromAll || s.getExtremesFromAll, c = this.isCartesian;
                s = a && a.val2lin;
                var u = a && a.isLog, d = this.requireSorting;
                if (c && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !e) return !1;
                if (a) var f = (e = a.getExtremes()).min, p = e.max;
                if (c && this.sorted && !h && (!l || r > l || this.forceCrop)) if (i[r - 1] < f || i[0] > p) i = [], n = []; else if (this.yData && (i[0] < f || i[r - 1] > p)) {
                    i = (o = this.cropData(this.xData, this.yData, f, p)).xData, n = o.yData, o = o.start;
                    var g = !0
                }
                for (l = i.length || 1; --l;) if (0 < (r = u ? s(i[l]) - s(i[l - 1]) : i[l] - i[l - 1]) && (void 0 === m || r < m)) var m = r; else 0 > r && d && (t.error(15, !1, this.chart), d = !1);
                this.cropped = g, this.cropStart = o, this.processedXData = i, this.processedYData = n, this.closestPointRange = this.basePointRange = m
            },
            cropData: function (t, e, i, n, r) {
                var o, a = t.length, s = 0, l = a;
                for (r = x(r, this.cropShoulder), o = 0; o < a; o++) if (t[o] >= i) {
                    s = Math.max(0, o - r);
                    break
                }
                for (i = o; i < a; i++) if (t[i] > n) {
                    l = i + r;
                    break
                }
                return {xData: t.slice(s, l), yData: e.slice(s, l), start: s, end: l}
            },
            generatePoints: function () {
                var t, e = this.options, i = e.data, n = this.data, r = this.processedXData, o = this.processedYData,
                    a = this.pointClass, s = r.length, h = this.cropStart || 0, c = this.hasGroupedData;
                e = e.keys;
                var u, d = [];
                for (n || c || ((n = []).length = i.length, n = this.data = n), e && c && (this.options.keys = !1), u = 0; u < s; u++) {
                    var f = h + u;
                    if (c) {
                        var p = (new a).init(this, [r[u]].concat(l(o[u])));
                        p.dataGroup = this.groupMap[u], p.dataGroup.options && (p.options = p.dataGroup.options, m(p, p.dataGroup.options), delete p.dataLabels)
                    } else (p = n[f]) || void 0 === i[f] || (n[f] = p = (new a).init(this, i[f], r[u]));
                    p && (p.index = f, d[u] = p)
                }
                if (this.options.keys = e, n && (s !== (t = n.length) || c)) for (u = 0; u < t; u++) u !== h || c || (u += s), n[u] && (n[u].destroyElements(), n[u].plotX = void 0);
                this.data = n, this.points = d, v(this, "afterGeneratePoints")
            },
            getXExtremes: function (t) {
                return {min: d(t), max: u(t)}
            },
            getExtremes: function (t) {
                var e, i = this.xAxis, n = this.yAxis, a = this.processedXData || this.xData, s = [], l = 0, h = 0,
                    c = 0, f = this.requireSorting ? this.cropShoulder : 0, p = !!n && n.positiveValuesOnly;
                for (n = (t = t || this.stackedYData || this.processedYData || []).length, i && (h = (c = i.getExtremes()).min, c = c.max), e = 0; e < n; e++) {
                    var g = a[e], m = t[e], y = (o(m) || r(m)) && (m.length || 0 < m || !p);
                    if (g = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (a[e + f] || g) >= h && (a[e - f] || g) <= c, y && g) if (y = m.length) for (; y--;) o(m[y]) && (s[l++] = m[y]); else s[l++] = m
                }
                this.dataMin = d(s), this.dataMax = u(s), v(this, "afterGetExtremes")
            },
            translate: function () {
                this.processedXData || this.processData(), this.generatePoints();
                var t, e, n = this.options, a = n.stacking, s = this.xAxis, l = s.categories, h = this.yAxis,
                    c = this.points, u = c.length, d = !!this.modifyValue, p = this.pointPlacementToXValue(), g = o(p),
                    m = n.threshold, y = n.startFromThreshold ? m : 0, b = this.zoneAxis || "y", M = Number.MAX_VALUE;
                for (t = 0; t < u; t++) {
                    var A = c[t], w = A.x, k = A.y, S = A.low,
                        T = a && h.stacks[(this.negStacks && k < (y ? 0 : m) ? "-" : "") + this.stackKey];
                    if (h.positiveValuesOnly && null !== k && 0 >= k && (A.isNull = !0), A.plotX = e = f(Math.min(Math.max(-1e5, s.translate(w, 0, 0, 0, 1, p, "flags" === this.type)), 1e5)), a && this.visible && T && T[w]) {
                        var E = this.getStackIndicator(E, w, this.index);
                        if (!A.isNull) var C = T[w], D = C.points[E.key]
                    }
                    if (r(D) && (S = D[0], k = D[1], S === y && E.key === T[w].base && (S = x(o(m) && m, h.min)), h.positiveValuesOnly && 0 >= S && (S = null), A.total = A.stackTotal = C.total, A.percentage = C.total && A.y / C.total * 100, A.stackY = k, this.irregularWidths || C.setOffset(this.pointXOffset || 0, this.barW || 0)), A.yBottom = i(S) ? Math.min(Math.max(-1e5, h.translate(S, 0, 1, 0, 1)), 1e5) : null, d && (k = this.modifyValue(k, A)), A.plotY = k = "number" == typeof k && 1 / 0 !== k ? Math.min(Math.max(-1e5, h.translate(k, 0, 1, 0, 1)), 1e5) : void 0, A.isInside = void 0 !== k && 0 <= k && k <= h.len && 0 <= e && e <= s.len, A.clientX = g ? f(s.translate(w, 0, 0, 0, 1, p)) : e, A.negative = A[b] < (n[b + "Threshold"] || m || 0), A.category = l && void 0 !== l[A.x] ? l[A.x] : A.x, !A.isNull) {
                        void 0 !== P && (M = Math.min(M, Math.abs(e - P)));
                        var P = e
                    }
                    A.zone = this.zones.length && A.getZone()
                }
                this.closestPointRangePx = M, v(this, "afterTranslate")
            },
            getValidPoints: function (t, e, i) {
                var n = this.chart;
                return (t || this.points || []).filter(function (t) {
                    return !(e && !n.isInsidePlot(t.plotX, t.plotY, n.inverted)) && (i || !t.isNull)
                })
            },
            getClipBox: function (t, e) {
                var i = this.options, n = this.chart, r = n.inverted, o = this.xAxis, a = o && this.yAxis;
                return t && !1 === i.clip && a ? t = r ? {
                    y: -n.chartWidth + a.len + a.pos,
                    height: n.chartWidth,
                    width: n.chartHeight,
                    x: -n.chartHeight + o.len + o.pos
                } : {
                    y: -a.pos,
                    height: n.chartHeight,
                    width: n.chartWidth,
                    x: -o.pos
                } : (t = this.clipBox || n.clipBox, e && (t.width = n.plotSizeX, t.x = 0)), e ? {
                    width: t.width,
                    x: t.x
                } : t
            },
            setClip: function (t) {
                var e = this.chart, i = this.options, n = e.renderer, r = e.inverted, o = this.clipBox,
                    a = this.getClipBox(t),
                    s = this.sharedClipKey || ["_sharedClip", t && t.duration, t && t.easing, a.height, i.xAxis, i.yAxis].join(),
                    l = e[s], h = e[s + "m"];
                l || (t && (a.width = 0, r && (a.x = e.plotSizeX + (!1 !== i.clip ? 0 : e.plotTop)), e[s + "m"] = h = n.clipRect(r ? e.plotSizeX + 99 : -99, r ? -e.plotLeft : -e.plotTop, 99, r ? e.chartWidth : e.chartHeight)), e[s] = l = n.clipRect(a), l.count = {length: 0}), t && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1), (!1 !== i.clip || t) && (this.group.clip(t || o ? l : e.clipRect), this.markerGroup.clip(h), this.sharedClipKey = s), t || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && s && e[s] && (o || (e[s] = e[s].destroy()), e[s + "m"] && (e[s + "m"] = e[s + "m"].destroy())))
            },
            animate: function (t) {
                var e = this.chart, i = c(this.options.animation);
                if (t) this.setClip(i); else {
                    var n = this.sharedClipKey;
                    t = e[n];
                    var r = this.getClipBox(i, !0);
                    t && t.animate(r, i), e[n + "m"] && e[n + "m"].animate({
                        width: r.width + 99,
                        x: r.x - (e.inverted ? 0 : 99)
                    }, i), this.animate = null
                }
            },
            afterAnimate: function () {
                this.setClip(), v(this, "afterAnimate"), this.finishedAnimating = !0
            },
            drawPoints: function () {
                var t, e = this.points, i = this.chart, n = this.options.marker,
                    r = this[this.specialGroup] || this.markerGroup, o = this.xAxis,
                    a = x(n.enabled, !(o && !o.isRadial) || null, this.closestPointRangePx >= n.enabledThreshold * n.radius);
                if (!1 !== n.enabled || this._hasPointMarkers) for (o = 0; o < e.length; o++) {
                    var s = e[o], l = (t = s.graphic) ? "animate" : "attr", h = s.marker || {}, c = !!s.marker,
                        u = a && void 0 === h.enabled || h.enabled, d = !1 !== s.isInside;
                    if (u && !s.isNull) {
                        u = x(h.symbol, this.symbol);
                        var f = this.markerAttribs(s, s.selected && "select");
                        t ? t[d ? "show" : "hide"](d).animate(f) : d && (0 < f.width || s.hasImage) && (s.graphic = t = i.renderer.symbol(u, f.x, f.y, f.width, f.height, c ? h : n).add(r)), t && !i.styledMode && t[l](this.pointAttribs(s, s.selected && "select")), t && t.addClass(s.getClassName(), !0)
                    } else t && (s.graphic = t.destroy())
                }
            },
            markerAttribs: function (t, e) {
                var i = this.options.marker, n = t.marker || {}, r = n.symbol || i.symbol, o = x(n.radius, i.radius);
                return e && (i = i.states[e], e = n.states && n.states[e], o = x(e && e.radius, i && i.radius, o + (i && i.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf("url"), t.hasImage && (o = 0), t = {
                    x: Math.floor(t.plotX) - o,
                    y: t.plotY - o
                }, o && (t.width = t.height = 2 * o), t
            },
            pointAttribs: function (t, e) {
                var i = this.options.marker, n = t && t.options, r = n && n.marker || {}, o = this.color,
                    a = n && n.color, s = t && t.color;
                n = x(r.lineWidth, i.lineWidth);
                var l = t && t.zone && t.zone.color;
                return t = 1, o = a || l || s || o, a = r.fillColor || i.fillColor || o, o = r.lineColor || i.lineColor || o, e = e || "normal", i = i.states[e], e = r.states && r.states[e] || {}, n = x(e.lineWidth, i.lineWidth, n + x(e.lineWidthPlus, i.lineWidthPlus, 0)), a = e.fillColor || i.fillColor || a, {
                    stroke: o = e.lineColor || i.lineColor || o,
                    "stroke-width": n,
                    fill: a,
                    opacity: t = x(e.opacity, i.opacity, t)
                }
            },
            destroy: function (e) {
                var i, r, o, a = this, l = a.chart, h = /AppleWebKit\/533/.test(w.navigator.userAgent),
                    c = a.data || [];
                for (v(a, "destroy"), e || b(a), (a.axisTypes || []).forEach(function (t) {
                    (o = a[t]) && o.series && (n(o.series, a), o.isDirty = o.forceRedraw = !0)
                }), a.legendItem && a.chart.legend.destroyItem(a), i = c.length; i--;) (r = c[i]) && r.destroy && r.destroy();
                a.points = null, t.clearTimeout(a.animationTimeout), s(a, function (t, e) {
                    t instanceof M && !t.survive && t[h && "group" === e ? "hide" : "destroy"]()
                }), l.hoverSeries === a && (l.hoverSeries = null), n(l.series, a), l.orderSeries(), s(a, function (t, i) {
                    e && "hcEvents" === i || delete a[i]
                })
            },
            getGraphPath: function (t, e, n) {
                var r, o, a = this, s = a.options, l = s.step, h = [], c = [];
                return (r = (t = t || a.points).reversed) && t.reverse(), (l = {
                    right: 1,
                    center: 2
                }[l] || l && 3) && r && (l = 4 - l), !s.connectNulls || e || n || (t = this.getValidPoints(t)), t.forEach(function (r, u) {
                    var d = r.plotX, f = r.plotY, p = t[u - 1];
                    (r.leftCliff || p && p.rightCliff) && !n && (o = !0), r.isNull && !i(e) && 0 < u ? o = !s.connectNulls : r.isNull && !e ? o = !0 : (0 === u || o ? u = ["M", r.plotX, r.plotY] : a.getPointSpline ? u = a.getPointSpline(t, r, u) : l ? (u = 1 === l ? ["L", p.plotX, f] : 2 === l ? ["L", (p.plotX + d) / 2, p.plotY, "L", (p.plotX + d) / 2, f] : ["L", d, p.plotY]).push("L", d, f) : u = ["L", d, f], c.push(r.x), l && (c.push(r.x), 2 === l && c.push(r.x)), h.push.apply(h, u), o = !1)
                }), h.xMap = c, a.graphPath = h
            },
            drawGraph: function () {
                var t = this, e = this.options, i = (this.gappedPath || this.getGraphPath).call(this),
                    n = this.chart.styledMode, r = [["graph", "highcharts-graph"]];
                n || r[0].push(e.lineColor || this.color || "#cccccc", e.dashStyle), (r = t.getZonesGraphs(r)).forEach(function (r, o) {
                    var a = r[0], s = t[a], l = s ? "animate" : "attr";
                    s ? (s.endX = t.preventGraphAnimation ? null : i.xMap, s.animate({d: i})) : i.length && (t[a] = s = t.chart.renderer.path(i).addClass(r[1]).attr({zIndex: 1}).add(t.group)), s && !n && (a = {
                        stroke: r[2],
                        "stroke-width": e.lineWidth,
                        fill: t.fillGraph && t.color || "none"
                    }, r[3] ? a.dashstyle = r[3] : "square" !== e.linecap && (a["stroke-linecap"] = a["stroke-linejoin"] = "round"), s[l](a).shadow(2 > o && e.shadow)), s && (s.startX = i.xMap, s.isArea = i.isArea)
                })
            },
            getZonesGraphs: function (t) {
                return this.zones.forEach(function (e, i) {
                    i = ["zone-graph-" + i, "highcharts-graph highcharts-zone-graph-" + i + " " + (e.className || "")], this.chart.styledMode || i.push(e.color || this.color, e.dashStyle || this.options.dashStyle), t.push(i)
                }, this), t
            },
            applyZones: function () {
                var t, e, i, n, r, o, a = this, s = this.chart, l = s.renderer, h = this.zones, c = this.clips || [],
                    u = this.graph, d = this.area, f = Math.max(s.chartWidth, s.chartHeight),
                    p = this[(this.zoneAxis || "y") + "Axis"], g = s.inverted, m = !1;
                if (h.length && (u || d) && p && void 0 !== p.min) {
                    var v = p.reversed, y = p.horiz;
                    u && !this.showLine && u.hide(), d && d.hide();
                    var b = p.getExtremes();
                    h.forEach(function (h, M) {
                        t = v ? y ? s.plotWidth : 0 : y ? 0 : p.toPixels(b.min) || 0, t = Math.min(Math.max(x(e, t), 0), f), e = Math.min(Math.max(Math.round(p.toPixels(x(h.value, b.max), !0) || 0), 0), f), m && (t = e = p.toPixels(b.max)), n = Math.abs(t - e), r = Math.min(t, e), o = Math.max(t, e), p.isXAxis ? (i = {
                            x: g ? o : r,
                            y: 0,
                            width: n,
                            height: f
                        }, y || (i.x = s.plotHeight - i.x)) : (i = {
                            x: 0,
                            y: g ? o : r,
                            width: f,
                            height: n
                        }, y && (i.y = s.plotWidth - i.y)), g && l.isVML && (i = p.isXAxis ? {
                            x: 0,
                            y: v ? r : o,
                            height: i.width,
                            width: s.chartWidth
                        } : {
                            x: i.y - s.plotLeft - s.spacingBox.x,
                            y: 0,
                            width: i.height,
                            height: s.chartHeight
                        }), c[M] ? c[M].animate(i) : c[M] = l.clipRect(i), u && a["zone-graph-" + M].clip(c[M]), d && a["zone-area-" + M].clip(c[M]), m = h.value > b.max, a.resetZones && 0 === e && (e = void 0)
                    }), this.clips = c
                } else a.visible && (u && u.show(!0), d && d.show(!0))
            },
            invertGroups: function (t) {
                function e() {
                    ["group", "markerGroup"].forEach(function (e) {
                        i[e] && (n.renderer.isVML && i[e].attr({
                            width: i.yAxis.len,
                            height: i.xAxis.len
                        }), i[e].width = i.yAxis.len, i[e].height = i.xAxis.len, i[e].invert(t))
                    })
                }

                var i = this, n = i.chart;
                if (i.xAxis) {
                    var r = h(n, "resize", e);
                    h(i, "destroy", r), e(), i.invertGroups = e
                }
            },
            plotGroup: function (t, e, n, r, o) {
                var a = this[t], s = !a;
                return s && (this[t] = a = this.chart.renderer.g().attr({zIndex: r || .1}).add(o)), a.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (i(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (a.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), a.attr({visibility: n})[s ? "attr" : "animate"](this.getPlotBox()), a
            },
            getPlotBox: function () {
                var t = this.chart, e = this.xAxis, i = this.yAxis;
                return t.inverted && (e = i, i = this.xAxis), {
                    translateX: e ? e.left : t.plotLeft,
                    translateY: i ? i.top : t.plotTop,
                    scaleX: 1,
                    scaleY: 1
                }
            },
            render: function () {
                var t = this, e = t.chart, i = t.options,
                    n = !!t.animate && e.renderer.isSVG && c(i.animation).duration,
                    r = t.visible ? "inherit" : "hidden", o = i.zIndex, a = t.hasRendered, s = e.seriesGroup,
                    l = e.inverted;
                v(this, "render");
                var h = t.plotGroup("group", "series", r, o, s);
                t.markerGroup = t.plotGroup("markerGroup", "markers", r, o, s), n && t.animate(!0), h.inverted = !(!t.isCartesian && !t.invertable) && l, t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels && t.drawDataLabels(), t.redrawPoints && t.redrawPoints(), t.drawTracker && !1 !== t.options.enableMouseTracking && t.drawTracker(), t.invertGroups(l), !1 === i.clip || t.sharedClipKey || a || h.clip(e.clipRect), n && t.animate(), a || (t.animationTimeout = A(function () {
                    t.afterAnimate()
                }, n)), t.isDirty = !1, t.hasRendered = !0, v(t, "afterRender")
            },
            redraw: function () {
                var t = this.chart, e = this.isDirty || this.isDirtyData, i = this.group, n = this.xAxis,
                    r = this.yAxis;
                i && (t.inverted && i.attr({
                    width: t.plotWidth,
                    height: t.plotHeight
                }), i.animate({
                    translateX: x(n && n.left, t.plotLeft),
                    translateY: x(r && r.top, t.plotTop)
                })), this.translate(), this.render(), e && delete this.kdTree
            },
            kdAxisArray: ["clientX", "plotY"],
            searchPoint: function (t, e) {
                var i = this.xAxis, n = this.yAxis, r = this.chart.inverted;
                return this.searchKDTree({
                    clientX: r ? i.len - t.chartY + i.pos : t.chartX - i.pos,
                    plotY: r ? n.len - t.chartX + n.pos : t.chartY - n.pos
                }, e, t)
            },
            buildKDTree: function (t) {
                this.buildingKdTree = !0;
                var e = this, i = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                delete e.kdTree, A(function () {
                    e.kdTree = function t(i, n, r) {
                        var o;
                        if (o = i && i.length) {
                            var a = e.kdAxisArray[n % r];
                            return i.sort(function (t, e) {
                                return t[a] - e[a]
                            }), {
                                point: i[o = Math.floor(o / 2)],
                                left: t(i.slice(0, o), n + 1, r),
                                right: t(i.slice(o + 1), n + 1, r)
                            }
                        }
                    }(e.getValidPoints(null, !e.directTouch), i, i), e.buildingKdTree = !1
                }, e.options.kdNow || t && "touchstart" === t.type ? 0 : 1)
            },
            searchKDTree: function (t, e, n) {
                var r = this, o = this.kdAxisArray[0], a = this.kdAxisArray[1], s = e ? "distX" : "dist";
                if (e = -1 < r.options.findNearestPointBy.indexOf("y") ? 2 : 1, this.kdTree || this.buildingKdTree || this.buildKDTree(n), this.kdTree) return function t(e, n, l, h) {
                    var c = n.point, u = r.kdAxisArray[l % h], d = c,
                        f = i(e[o]) && i(c[o]) ? Math.pow(e[o] - c[o], 2) : null,
                        p = i(e[a]) && i(c[a]) ? Math.pow(e[a] - c[a], 2) : null;
                    return p = (f || 0) + (p || 0), c.dist = i(p) ? Math.sqrt(p) : Number.MAX_VALUE, c.distX = i(f) ? Math.sqrt(f) : Number.MAX_VALUE, f = 0 > (u = e[u] - c[u]) ? "right" : "left", n[p = 0 > u ? "left" : "right"] && (d = (p = t(e, n[p], l + 1, h))[s] < d[s] ? p : c), n[f] && Math.sqrt(u * u) < d[s] && (d = (e = t(e, n[f], l + 1, h))[s] < d[s] ? e : d), d
                }(t, this.kdTree, e, e)
            },
            pointPlacementToXValue: function () {
                var t = this.options.pointPlacement;
                return "between" === t && (t = .5), o(t) && (t *= x(this.options.pointRange || this.xAxis.pointRange)), t
            }
        })
    }), e(i, "parts/Stacking.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.objectEach;
        e = t.Axis;
        var r = t.Chart, o = t.correctFloat, a = t.destroyObjectProperties, s = t.format, l = t.pick, h = t.Series;
        t.StackItem = function (t, e, i, n, r) {
            var o = t.chart.inverted;
            this.axis = t, this.isNegative = i, this.options = e = e || {}, this.x = n, this.total = null, this.points = {}, this.stack = r, this.rightCliff = this.leftCliff = 0, this.alignOptions = {
                align: e.align || (o ? i ? "left" : "right" : "center"),
                verticalAlign: e.verticalAlign || (o ? "middle" : i ? "bottom" : "top"),
                y: e.y,
                x: e.x
            }, this.textAlign = e.textAlign || (o ? i ? "right" : "left" : "center")
        }, t.StackItem.prototype = {
            destroy: function () {
                a(this, this.axis)
            }, render: function (t) {
                var e = this.axis.chart, i = this.options, n = i.format;
                n = n ? s(n, this, e.time) : i.formatter.call(this), this.label ? this.label.attr({
                    text: n,
                    visibility: "hidden"
                }) : (this.label = e.renderer.label(n, null, null, i.shape, null, null, i.useHTML, !1, "stack-labels"), n = {
                    text: n,
                    align: this.textAlign,
                    rotation: i.rotation,
                    padding: l(i.padding, 0),
                    visibility: "hidden"
                }, this.label.attr(n), e.styledMode || this.label.css(i.style), this.label.added || this.label.add(t)), this.label.labelrank = e.plotHeight
            }, setOffset: function (t, e, n, r, o) {
                var a = this.axis, s = a.chart;
                if (r = a.translate(a.usePercentage ? 100 : r || this.total, 0, 0, 0, 1), n = a.translate(n || 0), n = i(r) && Math.abs(r - n), t = l(o, s.xAxis[0].translate(this.x)) + t, a = i(r) && this.getStackBox(s, this, t, r, e, n, a), e = this.label, t = this.isNegative, o = "justify" === l(this.options.overflow, "justify"), e && a) {
                    n = e.getBBox();
                    var c = s.inverted ? t ? n.width : 0 : n.width / 2,
                        u = s.inverted ? n.height / 2 : t ? -4 : n.height + 4;
                    this.alignOptions.x = l(this.options.x, 0), e.align(this.alignOptions, null, a), r = e.alignAttr, e.show(), r.y -= u, o && (r.x -= c, h.prototype.justifyDataLabel.call(this.axis, e, this.alignOptions, r, n, a), r.x += c), r.x = e.alignAttr.x, e.attr({
                        x: r.x,
                        y: r.y
                    }), l(!o && this.options.crop, !0) && ((s = s.isInsidePlot(e.x + (s.inverted ? 0 : -n.width / 2), e.y) && s.isInsidePlot(e.x + (s.inverted ? t ? -n.width : n.width : n.width / 2), e.y + n.height)) || e.hide())
                }
            }, getStackBox: function (t, e, i, n, r, o, a) {
                var s = e.axis.reversed, l = t.inverted;
                return t = a.height + a.pos - (l ? t.plotLeft : t.plotTop), e = e.isNegative && !s || !e.isNegative && s, {
                    x: l ? e ? n : n - o : i,
                    y: l ? t - i - r : e ? t - n - o : t - n,
                    width: l ? o : r,
                    height: l ? r : o
                }
            }
        }, r.prototype.getStacks = function () {
            var t = this, e = t.inverted;
            t.yAxis.forEach(function (t) {
                t.stacks && t.hasVisibleSeries && (t.oldStacks = t.stacks)
            }), t.series.forEach(function (i) {
                var n = i.xAxis && i.xAxis.options || {};
                !i.options.stacking || !0 !== i.visible && !1 !== t.options.chart.ignoreHiddenSeries || (i.stackKey = [i.type, l(i.options.stack, ""), e ? n.top : n.left, e ? n.height : n.width].join())
            })
        }, e.prototype.buildStacks = function () {
            var t, e = this.series, i = l(this.options.reversedStacks, !0), n = e.length;
            if (!this.isXAxis) {
                for (this.usePercentage = !1, t = n; t--;) e[i ? t : n - t - 1].setStackedPoints();
                for (t = 0; t < n; t++) e[t].modifyStacks()
            }
        }, e.prototype.renderStackTotals = function () {
            var t = this.chart, e = t.renderer, i = this.stacks, r = this.stackTotalGroup;
            r || (this.stackTotalGroup = r = e.g("stack-labels").attr({
                visibility: "visible",
                zIndex: 6
            }).add()), r.translate(t.plotLeft, t.plotTop), n(i, function (t) {
                n(t, function (t) {
                    t.render(r)
                })
            })
        }, e.prototype.resetStacks = function () {
            var t = this, e = t.stacks;
            t.isXAxis || n(e, function (e) {
                n(e, function (i, n) {
                    i.touched < t.stacksTouched ? (i.destroy(), delete e[n]) : (i.total = null, i.cumulative = null)
                })
            })
        }, e.prototype.cleanStacks = function () {
            if (!this.isXAxis) {
                if (this.oldStacks) var t = this.stacks = this.oldStacks;
                n(t, function (t) {
                    n(t, function (t) {
                        t.cumulative = t.total
                    })
                })
            }
        }, h.prototype.setStackedPoints = function () {
            if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
                var e = this.processedXData, n = this.processedYData, r = [], a = n.length, s = this.options,
                    h = s.threshold, c = l(s.startFromThreshold && h, 0), u = s.stack;
                s = s.stacking;
                var d, f, p = this.stackKey, g = "-" + p, m = this.negStacks, v = this.yAxis, y = v.stacks,
                    x = v.oldStacks;
                for (v.stacksTouched += 1, f = 0; f < a; f++) {
                    var b = e[f], M = n[f], A = this.getStackIndicator(A, b, this.index), w = A.key,
                        k = (d = m && M < (c ? 0 : h)) ? g : p;
                    y[k] || (y[k] = {}), y[k][b] || (x[k] && x[k][b] ? (y[k][b] = x[k][b], y[k][b].total = null) : y[k][b] = new t.StackItem(v, v.options.stackLabels, d, b, u)), k = y[k][b], null !== M ? (k.points[w] = k.points[this.index] = [l(k.cumulative, c)], i(k.cumulative) || (k.base = w), k.touched = v.stacksTouched, 0 < A.index && !1 === this.singleStacks && (k.points[w][0] = k.points[this.index + "," + b + ",0"][0])) : k.points[w] = k.points[this.index] = null, "percent" === s ? (d = d ? p : g, m && y[d] && y[d][b] ? (d = y[d][b], k.total = d.total = Math.max(d.total, k.total) + Math.abs(M) || 0) : k.total = o(k.total + (Math.abs(M) || 0))) : k.total = o(k.total + (M || 0)), k.cumulative = l(k.cumulative, c) + (M || 0), null !== M && (k.points[w].push(k.cumulative), r[f] = k.cumulative)
                }
                "percent" === s && (v.usePercentage = !0), this.stackedYData = r, v.oldStacks = {}
            }
        }, h.prototype.modifyStacks = function () {
            var t, e = this, i = e.stackKey, n = e.yAxis.stacks, r = e.processedXData, o = e.options.stacking;
            e[o + "Stacker"] && [i, "-" + i].forEach(function (i) {
                for (var a, s, l = r.length; l--;) a = r[l], t = e.getStackIndicator(t, a, e.index, i), (s = (a = n[i] && n[i][a]) && a.points[t.key]) && e[o + "Stacker"](s, a, l)
            })
        }, h.prototype.percentStacker = function (t, e, i) {
            e = e.total ? 100 / e.total : 0, t[0] = o(t[0] * e), t[1] = o(t[1] * e), this.stackedYData[i] = t[1]
        }, h.prototype.getStackIndicator = function (t, e, n, r) {
            return !i(t) || t.x !== e || r && t.key !== r ? t = {
                x: e,
                index: 0,
                key: r
            } : t.index++, t.key = [n, e, t.index].join(), t
        }
    }), e(i, "parts/Dynamics.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.erase, r = e.isArray, o = e.isNumber, a = e.isObject, s = e.isString, l = e.objectEach,
            h = e.splat, c = t.addEvent, u = t.animate, d = t.Axis;
        e = t.Chart;
        var f = t.createElement, p = t.css, g = t.extend, m = t.fireEvent, v = t.merge, y = t.pick, x = t.Point,
            b = t.Series, M = t.seriesTypes, A = t.setAnimation;
        t.cleanRecursively = function (e, i) {
            var n = {};
            return l(e, function (r, o) {
                a(e[o], !0) && !e.nodeType && i[o] ? (r = t.cleanRecursively(e[o], i[o]), Object.keys(r).length && (n[o] = r)) : (a(e[o]) || e[o] !== i[o]) && (n[o] = e[o])
            }), n
        }, g(e.prototype, {
            addSeries: function (t, e, i) {
                var n, r = this;
                return t && (e = y(e, !0), m(r, "addSeries", {options: t}, function () {
                    n = r.initSeries(t), r.isDirtyLegend = !0, r.linkSeries(), m(r, "afterAddSeries", {series: n}), e && r.redraw(i)
                })), n
            },
            addAxis: function (t, e, i, n) {
                return this.createAxis(e ? "xAxis" : "yAxis", {axis: t, redraw: i, animation: n})
            },
            addColorAxis: function (t, e, i) {
                return this.createAxis("colorAxis", {axis: t, redraw: e, animation: i})
            },
            createAxis: function (e, i) {
                var n = this.options, r = "colorAxis" === e, o = i.redraw, a = i.animation;
                i = v(i.axis, {index: this[e].length, isX: "xAxis" === e});
                var s = r ? new t.ColorAxis(this, i) : new d(this, i);
                return n[e] = h(n[e] || {}), n[e].push(i), r && (this.isDirtyLegend = !0), y(o, !0) && this.redraw(a), s
            },
            showLoading: function (t) {
                var e = this, i = e.options, n = e.loadingDiv, r = i.loading, o = function () {
                    n && p(n, {
                        left: e.plotLeft + "px",
                        top: e.plotTop + "px",
                        width: e.plotWidth + "px",
                        height: e.plotHeight + "px"
                    })
                };
                n || (e.loadingDiv = n = f("div", {className: "highcharts-loading highcharts-loading-hidden"}, null, e.container), e.loadingSpan = f("span", {className: "highcharts-loading-inner"}, null, n), c(e, "redraw", o)), n.className = "highcharts-loading", e.loadingSpan.innerHTML = y(t, i.lang.loading, ""), e.styledMode || (p(n, g(r.style, {zIndex: 10})), p(e.loadingSpan, r.labelStyle), e.loadingShown || (p(n, {
                    opacity: 0,
                    display: ""
                }), u(n, {opacity: r.style.opacity || .5}, {duration: r.showDuration || 0}))), e.loadingShown = !0, o()
            },
            hideLoading: function () {
                var t = this.options, e = this.loadingDiv;
                e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || u(e, {opacity: 0}, {
                    duration: t.loading.hideDuration || 100,
                    complete: function () {
                        p(e, {display: "none"})
                    }
                })), this.loadingShown = !1
            },
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
            collectionsWithUpdate: "xAxis yAxis zAxis series colorAxis pane".split(" "),
            update: function (e, n, r, a) {
                var c, u, d, f = this,
                    p = {credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption"},
                    g = e.isResponsiveOptions, x = [];
                if (m(f, "update", {options: e}), g || f.setResponsive(!1, !0), e = t.cleanRecursively(e, f.options), v(!0, f.userOptions, e), c = e.chart) {
                    if (v(!0, f.options.chart, c), "className" in c && f.setClassName(c.className), "reflow" in c && f.setReflow(c.reflow), "inverted" in c || "polar" in c || "type" in c) {
                        f.propFromSeries();
                        var b = !0
                    }
                    "alignTicks" in c && (b = !0), l(c, function (t, e) {
                        -1 !== f.propsRequireUpdateSeries.indexOf("chart." + e) && (u = !0), -1 !== f.propsRequireDirtyBox.indexOf(e) && (f.isDirtyBox = !0), g || -1 === f.propsRequireReflow.indexOf(e) || (d = !0)
                    }), !f.styledMode && "style" in c && f.renderer.setStyle(c.style)
                }
                !f.styledMode && e.colors && (this.options.colors = e.colors), e.plotOptions && v(!0, this.options.plotOptions, e.plotOptions), e.time && this.time === t.time && (this.time = new t.Time(e.time)), l(e, function (t, e) {
                    f[e] && "function" == typeof f[e].update ? f[e].update(t, !1) : "function" == typeof f[p[e]] && f[p[e]](t), "chart" !== e && -1 !== f.propsRequireUpdateSeries.indexOf(e) && (u = !0)
                }), this.collectionsWithUpdate.forEach(function (t) {
                    if (e[t]) {
                        if ("series" === t) {
                            var n = [];
                            f[t].forEach(function (t, e) {
                                t.options.isInternal || n.push(y(t.options.index, e))
                            })
                        }
                        h(e[t]).forEach(function (e, o) {
                            (o = i(e.id) && f.get(e.id) || f[t][n ? n[o] : o]) && o.coll === t && (o.update(e, !1), r && (o.touched = !0)), !o && r && f.collectionsWithInit[t] && (f.collectionsWithInit[t][0].apply(f, [e].concat(f.collectionsWithInit[t][1] || []).concat([!1])).touched = !0)
                        }), r && f[t].forEach(function (t) {
                            t.touched || t.options.isInternal ? delete t.touched : x.push(t)
                        })
                    }
                }), x.forEach(function (t) {
                    t.remove && t.remove(!1)
                }), b && f.axes.forEach(function (t) {
                    t.update({}, !1)
                }), u && f.series.forEach(function (t) {
                    t.update({}, !1)
                }), e.loading && v(!0, f.options.loading, e.loading), b = c && c.width, c = c && c.height, s(c) && (c = t.relativeLength(c, b || f.chartWidth)), d || o(b) && b !== f.chartWidth || o(c) && c !== f.chartHeight ? f.setSize(b, c, a) : y(n, !0) && f.redraw(a), m(f, "afterUpdate", {
                    options: e,
                    redraw: n,
                    animation: a
                })
            },
            setSubtitle: function (t, e) {
                this.applyDescription("subtitle", t), this.layOutTitles(e)
            },
            setCaption: function (t, e) {
                this.applyDescription("caption", t), this.layOutTitles(e)
            }
        }), e.prototype.collectionsWithInit = {
            xAxis: [e.prototype.addAxis, [!0]],
            yAxis: [e.prototype.addAxis, [!1]],
            colorAxis: [e.prototype.addColorAxis, [!1]],
            series: [e.prototype.addSeries]
        }, g(x.prototype, {
            update: function (t, e, i, n) {
                function r() {
                    s.applyOptions(t), null === s.y && h && (s.graphic = h.destroy()), a(t, !0) && (h && h.element && t && t.marker && void 0 !== t.marker.symbol && (s.graphic = h.destroy()), t && t.dataLabels && s.dataLabel && (s.dataLabel = s.dataLabel.destroy()), s.connector && (s.connector = s.connector.destroy())), o = s.index, l.updateParallelArrays(s, o), u.data[o] = a(u.data[o], !0) || a(t, !0) ? s.options : y(t, u.data[o]), l.isDirty = l.isDirtyData = !0, !l.fixedBox && l.hasCartesianSeries && (c.isDirtyBox = !0), "point" === u.legendType && (c.isDirtyLegend = !0), e && c.redraw(i)
                }

                var o, s = this, l = s.series, h = s.graphic, c = l.chart, u = l.options;
                e = y(e, !0), !1 === n ? r() : s.firePointEvent("update", {options: t}, r)
            }, remove: function (t, e) {
                this.series.removePoint(this.series.data.indexOf(this), t, e)
            }
        }), g(b.prototype, {
            addPoint: function (t, e, i, n, r) {
                var o = this.options, a = this.data, s = this.chart, l = this.xAxis;
                l = l && l.hasNames && l.names;
                var h, c = o.data, u = this.xData;
                e = y(e, !0);
                var d = {series: this};
                this.pointClass.prototype.applyOptions.apply(d, [t]);
                var f = d.x, p = u.length;
                if (this.requireSorting && f < u[p - 1]) for (h = !0; p && u[p - 1] > f;) p--;
                this.updateParallelArrays(d, "splice", p, 0, 0), this.updateParallelArrays(d, p), l && d.name && (l[f] = d.name), c.splice(p, 0, t), h && (this.data.splice(p, 0, null), this.processData()), "point" === o.legendType && this.generatePoints(), i && (a[0] && a[0].remove ? a[0].remove(!1) : (a.shift(), this.updateParallelArrays(d, "shift"), c.shift())), !1 !== r && m(this, "addPoint", {point: d}), this.isDirtyData = this.isDirty = !0, e && s.redraw(n)
            }, removePoint: function (t, e, i) {
                var n = this, r = n.data, o = r[t], a = n.points, s = n.chart, l = function () {
                    a && a.length === r.length && a.splice(t, 1), r.splice(t, 1), n.options.data.splice(t, 1), n.updateParallelArrays(o || {series: n}, "splice", t, 1), o && o.destroy(), n.isDirty = !0, n.isDirtyData = !0, e && s.redraw()
                };
                A(i, s), e = y(e, !0), o ? o.firePointEvent("remove", null, l) : l()
            }, remove: function (t, e, i, n) {
                function r() {
                    o.destroy(n), o.remove = null, a.isDirtyLegend = a.isDirtyBox = !0, a.linkSeries(), y(t, !0) && a.redraw(e)
                }

                var o = this, a = o.chart;
                !1 !== i ? m(o, "remove", null, r) : r()
            }, update: function (e, i) {
                e = t.cleanRecursively(e, this.userOptions), m(this, "update", {options: e});
                var n, r = this, o = r.chart, a = r.userOptions, s = r.initialType || r.type,
                    l = e.type || a.type || o.options.chart.type,
                    h = !(this.hasDerivedData || e.dataGrouping || l && l !== this.type || void 0 !== e.pointStart || e.pointInterval || e.pointIntervalUnit || e.keys),
                    c = M[s].prototype, u = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"],
                    d = ["eventOptions", "navigatorSeries", "baseSeries"], f = r.finishedAnimating && {animation: !1},
                    p = {};
                for (n in h && (d.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== e.visible && d.push("area", "graph"), r.parallelArrays.forEach(function (t) {
                    d.push(t + "Data")
                }), e.data && this.setData(e.data, !1)), e = v(a, f, {
                    index: void 0 === a.index ? r.index : a.index,
                    pointStart: y(a.pointStart, r.xData[0])
                }, !h && {data: r.options.data}, e), h && e.data && (e.data = r.options.data), (d = u.concat(d)).forEach(function (t) {
                    d[t] = r[t], delete r[t]
                }), r.remove(!1, null, !1, !0), c) r[n] = void 0;
                if (M[l || s] ? g(r, M[l || s].prototype) : t.error(17, !0, o), d.forEach(function (t) {
                    r[t] = d[t]
                }), r.init(o, e), h && this.points) {
                    var x = r.options;
                    !1 === x.visible ? (p.graphic = 1, p.dataLabel = 1) : r._hasPointLabels || (l = x.marker, c = x.dataLabels, l && (!1 === l.enabled || "symbol" in l) && (p.graphic = 1), c && !1 === c.enabled && (p.dataLabel = 1)), this.points.forEach(function (t) {
                        t && t.series && (t.resolveColor(), Object.keys(p).length && t.destroyElements(p), !1 === x.showInLegend && t.legendItem && o.legend.destroyItem(t))
                    }, this)
                }
                e.zIndex !== a.zIndex && u.forEach(function (t) {
                    r[t] && r[t].attr({zIndex: e.zIndex})
                }), r.initialType = s, o.linkSeries(), m(this, "afterUpdate"), y(i, !0) && o.redraw(!!h && void 0)
            }, setName: function (t) {
                this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0
            }
        }), g(d.prototype, {
            update: function (t, e) {
                var i = this.chart, n = t && t.events || {};
                t = v(this.userOptions, t), i.options[this.coll].indexOf && (i.options[this.coll][i.options[this.coll].indexOf(this.userOptions)] = t), l(i.options[this.coll].events, function (t, e) {
                    void 0 === n[e] && (n[e] = void 0)
                }), this.destroy(!0), this.init(i, g(t, {events: n})), i.isDirtyBox = !0, y(e, !0) && i.redraw()
            }, remove: function (t) {
                for (var e = this.chart, i = this.coll, o = this.series, a = o.length; a--;) o[a] && o[a].remove(!1);
                n(e.axes, this), n(e[i], this), r(e.options[i]) ? e.options[i].splice(this.options.index, 1) : delete e.options[i], e[i].forEach(function (t, e) {
                    t.options.index = t.userOptions.index = e
                }), this.destroy(), e.isDirtyBox = !0, y(t, !0) && e.redraw()
            }, setTitle: function (t, e) {
                this.update({title: t}, e)
            }, setCategories: function (t, e) {
                this.update({categories: t}, e)
            }
        })
    }), e(i, "parts/AreaSeries.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.objectEach, n = t.color, r = t.pick, o = t.Series;
        (e = t.seriesType)("area", "line", {softThreshold: !1, threshold: 0}, {
            singleStacks: !1, getStackPoints: function (t) {
                var e, n = [], o = [], a = this.xAxis, s = this.yAxis, l = s.stacks[this.stackKey], h = {},
                    c = this.index, u = s.series, d = u.length, f = r(s.options.reversedStacks, !0) ? 1 : -1;
                if (t = t || this.points, this.options.stacking) {
                    for (e = 0; e < t.length; e++) t[e].leftNull = t[e].rightNull = null, h[t[e].x] = t[e];
                    i(l, function (t, e) {
                        null !== t.total && o.push(e)
                    }), o.sort(function (t, e) {
                        return t - e
                    });
                    var p = u.map(function (t) {
                        return t.visible
                    });
                    o.forEach(function (t, i) {
                        var r, u, g = 0;
                        if (h[t] && !h[t].isNull) n.push(h[t]), [-1, 1].forEach(function (n) {
                            var a = 1 === n ? "rightNull" : "leftNull", s = 0, g = l[o[i + n]];
                            if (g) for (e = c; 0 <= e && e < d;) (r = g.points[e]) || (e === c ? h[t][a] = !0 : p[e] && (u = l[t].points[e]) && (s -= u[1] - u[0])), e += f;
                            h[t][1 === n ? "rightCliff" : "leftCliff"] = s
                        }); else {
                            for (e = c; 0 <= e && e < d;) {
                                if (r = l[t].points[e]) {
                                    g = r[1];
                                    break
                                }
                                e += f
                            }
                            g = s.translate(g, 0, 1, 0, 1), n.push({
                                isNull: !0,
                                plotX: a.translate(t, 0, 0, 0, 1),
                                x: t,
                                plotY: g,
                                yBottom: g
                            })
                        }
                    })
                }
                return n
            }, getGraphPath: function (e) {
                var i, n = o.prototype.getGraphPath, a = this.options, s = a.stacking, l = this.yAxis, h = [], c = [],
                    u = this.index, d = l.stacks[this.stackKey], f = a.threshold,
                    p = Math.round(l.getThreshold(a.threshold));
                a = t.pick(a.connectNulls, "percent" === s);
                var g = function (t, i, n) {
                    var r = e[t];
                    t = s && d[r.x].points[u];
                    var o = r[n + "Null"] || 0;
                    if (n = r[n + "Cliff"] || 0, r = !0, n || o) {
                        var a = (o ? t[0] : t[1]) + n, g = t[0] + n;
                        r = !!o
                    } else !s && e[i] && e[i].isNull && (a = g = f);
                    void 0 !== a && (c.push({
                        plotX: v,
                        plotY: null === a ? p : l.getThreshold(a),
                        isNull: r,
                        isCliff: !0
                    }), h.push({plotX: v, plotY: null === g ? p : l.getThreshold(g), doCurve: !1}))
                };
                for (e = e || this.points, s && (e = this.getStackPoints(e)), i = 0; i < e.length; i++) {
                    var m = e[i].isNull, v = r(e[i].rectPlotX, e[i].plotX), y = r(e[i].yBottom, p);
                    m && !a || (a || g(i, i - 1, "left"), m && !s && a || (c.push(e[i]), h.push({
                        x: i,
                        plotX: v,
                        plotY: y
                    })), a || g(i, i + 1, "right"))
                }
                return i = n.call(this, c, !0, !0), h.reversed = !0, (m = n.call(this, h, !0, !0)).length && (m[0] = "L"), m = i.concat(m), n = n.call(this, c, !1, a), m.xMap = i.xMap, this.areaPath = m, n
            }, drawGraph: function () {
                this.areaPath = [], o.prototype.drawGraph.apply(this);
                var t = this, e = this.areaPath, i = this.options,
                    a = [["area", "highcharts-area", this.color, i.fillColor]];
                this.zones.forEach(function (e, n) {
                    a.push(["zone-area-" + n, "highcharts-area highcharts-zone-area-" + n + " " + e.className, e.color || t.color, e.fillColor || i.fillColor])
                }), a.forEach(function (o) {
                    var a = o[0], s = t[a], l = s ? "animate" : "attr", h = {};
                    s ? (s.endX = t.preventGraphAnimation ? null : e.xMap, s.animate({d: e})) : (h.zIndex = 0, (s = t[a] = t.chart.renderer.path(e).addClass(o[1]).add(t.group)).isArea = !0), t.chart.styledMode || (h.fill = r(o[3], n(o[2]).setOpacity(r(i.fillOpacity, .75)).get())), s[l](h), s.startX = e.xMap, s.shiftUnit = i.step ? 2 : 1
                })
            }, drawLegendSymbol: t.LegendSymbolMixin.drawRectangle
        })
    }), e(i, "parts/SplineSeries.js", [i["parts/Globals.js"]], function (t) {
        var e = t.pick;
        (t = t.seriesType)("spline", "line", {}, {
            getPointSpline: function (t, i, n) {
                var r = i.plotX, o = i.plotY, a = t[n - 1];
                if (n = t[n + 1], a && !a.isNull && !1 !== a.doCurve && !i.isCliff && n && !n.isNull && !1 !== n.doCurve && !i.isCliff) {
                    t = a.plotY;
                    var s = n.plotX;
                    n = n.plotY;
                    var l = 0, h = (1.5 * r + a.plotX) / 2.5, c = (1.5 * o + t) / 2.5, u = (1.5 * o + n) / 2.5;
                    (s = (1.5 * r + s) / 2.5) !== h && (l = (u - c) * (s - r) / (s - h) + o - u), u += l, (c += l) > t && c > o ? u = 2 * o - (c = Math.max(t, o)) : c < t && c < o && (u = 2 * o - (c = Math.min(t, o))), u > n && u > o ? c = 2 * o - (u = Math.max(n, o)) : u < n && u < o && (c = 2 * o - (u = Math.min(n, o))), i.rightContX = s, i.rightContY = u
                }
                return i = ["C", e(a.rightContX, a.plotX), e(a.rightContY, a.plotY), e(h, r), e(c, o), r, o], a.rightContX = a.rightContY = null, i
            }
        })
    }), e(i, "parts/AreaSplineSeries.js", [i["parts/Globals.js"]], function (t) {
        var e = t.seriesTypes.area.prototype;
        (0, t.seriesType)("areaspline", "spline", t.defaultPlotOptions.area, {
            getStackPoints: e.getStackPoints,
            getGraphPath: e.getGraphPath,
            drawGraph: e.drawGraph,
            drawLegendSymbol: t.LegendSymbolMixin.drawRectangle
        })
    }), e(i, "parts/ColumnSeries.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = t.animObject, o = t.color, a = t.extend, s = t.merge, l = t.pick,
            h = t.Series;
        e = t.seriesType;
        var c = t.svg;
        e("column", "line", {
            borderRadius: 0,
            crisp: !0,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {hover: {halo: !1, brightness: .1}, select: {color: "#cccccc", borderColor: "#000000"}},
            dataLabels: {align: null, verticalAlign: null, y: null},
            softThreshold: !1,
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {distance: 6},
            threshold: 0,
            borderColor: "#ffffff"
        }, {
            cropShoulder: 0,
            directTouch: !0,
            trackerGroups: ["group", "dataLabelsGroup"],
            negStacks: !0,
            init: function () {
                h.prototype.init.apply(this, arguments);
                var t = this, e = t.chart;
                e.hasRendered && e.series.forEach(function (e) {
                    e.type === t.type && (e.isDirty = !0)
                })
            },
            getColumnMetrics: function () {
                var t = this, e = t.options, i = t.xAxis, n = t.yAxis, r = i.options.reversedStacks;
                r = i.reversed && !r || !i.reversed && r;
                var o, a = {}, s = 0;
                !1 === e.grouping ? s = 1 : t.chart.series.forEach(function (e) {
                    var i = e.yAxis, r = e.options;
                    if (e.type === t.type && (e.visible || !t.chart.options.chart.ignoreHiddenSeries) && n.len === i.len && n.pos === i.pos) {
                        if (r.stacking) {
                            o = e.stackKey, void 0 === a[o] && (a[o] = s++);
                            var l = a[o]
                        } else !1 !== r.grouping && (l = s++);
                        e.columnIndex = l
                    }
                });
                var h = Math.min(Math.abs(i.transA) * (i.ordinalSlope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len),
                    c = h * e.groupPadding, u = (h - 2 * c) / (s || 1);
                return e = Math.min(e.maxPointWidth || i.len, l(e.pointWidth, u * (1 - 2 * e.pointPadding))), t.columnMetrics = {
                    width: e,
                    offset: (u - e) / 2 + (c + ((t.columnIndex || 0) + (r ? 1 : 0)) * u - h / 2) * (r ? -1 : 1)
                }, t.columnMetrics
            },
            crispCol: function (t, e, i, n) {
                var r = this.chart, o = this.borderWidth, a = -(o % 2 ? .5 : 0);
                return o = o % 2 ? .5 : 1, r.inverted && r.renderer.isVML && (o += 1), this.options.crisp && (i = Math.round(t + i) + a, i -= t = Math.round(t) + a), n = Math.round(e + n) + o, a = .5 >= Math.abs(e) && .5 < n, n -= e = Math.round(e) + o, a && n && (--e, n += 1), {
                    x: t,
                    y: e,
                    width: i,
                    height: n
                }
            },
            translate: function () {
                var t = this, e = t.chart, n = t.options, r = t.dense = 2 > t.closestPointRange * t.xAxis.transA;
                r = t.borderWidth = l(n.borderWidth, r ? 0 : 1);
                var o = t.yAxis, a = n.threshold, s = t.translatedThreshold = o.getThreshold(a),
                    c = l(n.minPointLength, 5), u = t.getColumnMetrics(), d = u.width,
                    f = t.barW = Math.max(d, 1 + 2 * r), p = t.pointXOffset = u.offset, g = t.dataMin, m = t.dataMax;
                e.inverted && (s -= .5), n.pointPadding && (f = Math.ceil(f)), h.prototype.translate.apply(t), t.points.forEach(function (n) {
                    var r = l(n.yBottom, s), h = 999 + Math.abs(r), u = d;
                    h = Math.min(Math.max(-h, n.plotY), o.len + h);
                    var v = n.plotX + p, y = f, x = Math.min(h, r), b = Math.max(h, r) - x;
                    if (c && Math.abs(b) < c) {
                        b = c;
                        var M = !o.reversed && !n.negative || o.reversed && n.negative;
                        n.y === a && t.dataMax <= a && o.min < a && g !== m && (M = !M), x = Math.abs(x - s) > c ? r - c : s - (M ? c : 0)
                    }
                    i(n.options.pointWidth) && (u = y = Math.ceil(n.options.pointWidth), v -= Math.round((u - d) / 2)), n.barX = v, n.pointWidth = u, n.tooltipPos = e.inverted ? [o.len + o.pos - e.plotLeft - h, t.xAxis.len - v - y / 2, b] : [v + y / 2, h + o.pos - e.plotTop, b], n.shapeType = t.pointClass.prototype.shapeType || "rect", n.shapeArgs = t.crispCol.apply(t, n.isNull ? [v, s, y, 0] : [v, x, y, b])
                })
            },
            getSymbol: t.noop,
            drawLegendSymbol: t.LegendSymbolMixin.drawRectangle,
            drawGraph: function () {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data")
            },
            pointAttribs: function (t, e) {
                var i = this.options, n = this.pointAttrToOptions || {}, r = n.stroke || "borderColor",
                    a = n["stroke-width"] || "borderWidth", h = t && t.color || this.color,
                    c = t && t[r] || i[r] || this.color || h, u = t && t[a] || i[a] || this[a] || 0;
                n = t && t.options.dashStyle || i.dashStyle;
                var d = l(i.opacity, 1);
                if (t && this.zones.length) {
                    var f = t.getZone();
                    h = t.options.color || f && (f.color || t.nonZonedColor) || this.color, f && (c = f.borderColor || c, n = f.dashStyle || n, u = f.borderWidth || u)
                }
                return e && (e = (t = s(i.states[e], t.options.states && t.options.states[e] || {})).brightness, h = t.color || void 0 !== e && o(h).brighten(t.brightness).get() || h, c = t[r] || c, u = t[a] || u, n = t.dashStyle || n, d = l(t.opacity, d)), r = {
                    fill: h,
                    stroke: c,
                    "stroke-width": u,
                    opacity: d
                }, n && (r.dashstyle = n), r
            },
            drawPoints: function () {
                var t, e = this, i = this.chart, r = e.options, o = i.renderer, a = r.animationLimit || 250;
                e.points.forEach(function (l) {
                    var h = l.graphic, c = h && i.pointCount < a ? "animate" : "attr";
                    n(l.plotY) && null !== l.y ? (t = l.shapeArgs, h && h.element.nodeName !== l.shapeType && (h = h.destroy()), h ? h[c](s(t)) : l.graphic = h = o[l.shapeType](t).add(l.group || e.group), r.borderRadius && h[c]({r: r.borderRadius}), i.styledMode || h[c](e.pointAttribs(l, l.selected && "select")).shadow(!1 !== l.allowShadow && r.shadow, null, r.stacking && !r.borderRadius), h.addClass(l.getClassName(), !0)) : h && (l.graphic = h.destroy())
                })
            },
            animate: function (t) {
                var e = this, i = this.yAxis, n = e.options, o = this.chart.inverted, s = {},
                    l = o ? "translateX" : "translateY";
                if (c) if (t) s.scaleY = .001, t = Math.min(i.pos + i.len, Math.max(i.pos, i.toPixels(n.threshold))), o ? s.translateX = t - i.len : s.translateY = t, e.clipBox && e.setClip(), e.group.attr(s); else {
                    var h = e.group.attr(l);
                    e.group.animate({scaleY: 1}, a(r(e.options.animation), {
                        step: function (t, n) {
                            s[l] = h + n.pos * (i.pos - h), e.group.attr(s)
                        }
                    })), e.animate = null
                }
            },
            remove: function () {
                var t = this, e = t.chart;
                e.hasRendered && e.series.forEach(function (e) {
                    e.type === t.type && (e.isDirty = !0)
                }), h.prototype.remove.apply(t, arguments)
            }
        })
    }), e(i, "parts/BarSeries.js", [i["parts/Globals.js"]], function (t) {
        (t = t.seriesType)("bar", "column", null, {inverted: !0})
    }), e(i, "parts/ScatterSeries.js", [i["parts/Globals.js"]], function (t) {
        var e = t.Series;
        (0, t.seriesType)("scatter", "line", {
            lineWidth: 0,
            findNearestPointBy: "xy",
            jitter: {x: 0, y: 0},
            marker: {enabled: !0},
            tooltip: {
                headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }, {
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: !1,
            drawGraph: function () {
                this.options.lineWidth && e.prototype.drawGraph.call(this)
            },
            applyJitter: function () {
                var t = this, e = this.options.jitter, i = this.points.length;
                e && this.points.forEach(function (n, r) {
                    ["x", "y"].forEach(function (o, a) {
                        var s = "plot" + o.toUpperCase();
                        if (e[o] && !n.isNull) {
                            var l = t[o + "Axis"], h = e[o] * l.transA;
                            if (l && !l.isLog) {
                                var c = Math.max(0, n[s] - h);
                                l = Math.min(l.len, n[s] + h), a = 1e4 * Math.sin(r + a * i), n[s] = c + (l - c) * (a - Math.floor(a)), "x" === o && (n.clientX = n.plotX)
                            }
                        }
                    })
                })
            }
        }), t.addEvent(e, "afterTranslate", function () {
            this.applyJitter && this.applyJitter()
        })
    }), e(i, "mixins/centered-series.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.isNumber, n = t.deg2rad, r = t.pick, o = t.relativeLength;
        t.CenteredSeriesMixin = {
            getCenter: function () {
                var t = this.options, e = this.chart, i = 2 * (t.slicedOffset || 0), n = e.plotWidth - 2 * i;
                e = e.plotHeight - 2 * i;
                var a = t.center;
                a = [r(a[0], "50%"), r(a[1], "50%"), t.size || "100%", t.innerSize || 0];
                var s, l = Math.min(n, e);
                for (s = 0; 4 > s; ++s) {
                    var h = a[s];
                    t = 2 > s || 2 === s && /%$/.test(h), a[s] = o(h, [n, e, l, a[2]][s]) + (t ? i : 0)
                }
                return a[3] > a[2] && (a[3] = a[2]), a
            }, getStartAndEndRadians: function (t, e) {
                return t = i(t) ? t : 0, e = i(e) && e > t && 360 > e - t ? e : t + 360, {
                    start: n * (t + -90),
                    end: n * (e + -90)
                }
            }
        }
    }), e(i, "parts/PieSeries.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = t.addEvent, o = (e = t.CenteredSeriesMixin).getStartAndEndRadians,
            a = t.merge, s = t.noop, l = t.pick, h = t.Point, c = t.Series, u = t.seriesType, d = t.fireEvent,
            f = t.setAnimation;
        u("pie", "line", {
            center: [null, null],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                allowOverlap: !0, connectorPadding: 5, distance: 30, enabled: !0, formatter: function () {
                    return this.point.isNull ? void 0 : this.point.name
                }, softConnector: !0, x: 0, connectorShape: "fixedOffset", crookDistance: "70%"
            },
            fillColor: void 0,
            ignoreHiddenPoint: !0,
            inactiveOtherPoints: !0,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {followPointer: !0},
            borderColor: "#ffffff",
            borderWidth: 1,
            states: {hover: {brightness: .1}}
        }, {
            isCartesian: !1,
            requireSorting: !1,
            directTouch: !0,
            noSharedTooltip: !0,
            trackerGroups: ["group", "dataLabelsGroup"],
            axisTypes: [],
            pointAttribs: t.seriesTypes.column.prototype.pointAttribs,
            animate: function (t) {
                var e = this, i = e.points, n = e.startAngleRad;
                t || (i.forEach(function (t) {
                    var i = t.graphic, r = t.shapeArgs;
                    i && (i.attr({r: t.startR || e.center[3] / 2, start: n, end: n}), i.animate({
                        r: r.r,
                        start: r.start,
                        end: r.end
                    }, e.options.animation))
                }), e.animate = null)
            },
            hasData: function () {
                return !!this.processedXData.length
            },
            updateTotals: function () {
                var t, e = 0, i = this.points, n = i.length, r = this.options.ignoreHiddenPoint;
                for (t = 0; t < n; t++) {
                    var o = i[t];
                    e += r && !o.visible ? 0 : o.isNull ? 0 : o.y
                }
                for (this.total = e, t = 0; t < n; t++) (o = i[t]).percentage = 0 < e && (o.visible || !r) ? o.y / e * 100 : 0, o.total = e
            },
            generatePoints: function () {
                c.prototype.generatePoints.call(this), this.updateTotals()
            },
            getX: function (t, e, i) {
                var n = this.center, r = this.radii ? this.radii[i.index] : n[2] / 2;
                return n[0] + (e ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((t - n[1]) / (r + i.labelDistance), 1), -1))) * (r + i.labelDistance) + (0 < i.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0)
            },
            translate: function (e) {
                this.generatePoints();
                var i = 0, n = this.options, r = n.slicedOffset, a = r + (n.borderWidth || 0),
                    s = o(n.startAngle, n.endAngle), h = this.startAngleRad = s.start;
                s = (this.endAngleRad = s.end) - h;
                var c = this.points, u = n.dataLabels.distance;
                n = n.ignoreHiddenPoint;
                var f, p = c.length;
                for (e || (this.center = e = this.getCenter()), f = 0; f < p; f++) {
                    var g = c[f], m = h + i * s;
                    n && !g.visible || (i += g.percentage / 100);
                    var v = h + i * s;
                    g.shapeType = "arc", g.shapeArgs = {
                        x: e[0],
                        y: e[1],
                        r: e[2] / 2,
                        innerR: e[3] / 2,
                        start: Math.round(1e3 * m) / 1e3,
                        end: Math.round(1e3 * v) / 1e3
                    }, g.labelDistance = l(g.options.dataLabels && g.options.dataLabels.distance, u), g.labelDistance = t.relativeLength(g.labelDistance, g.shapeArgs.r), this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, g.labelDistance), (v = (v + m) / 2) > 1.5 * Math.PI ? v -= 2 * Math.PI : v < -Math.PI / 2 && (v += 2 * Math.PI), g.slicedTranslation = {
                        translateX: Math.round(Math.cos(v) * r),
                        translateY: Math.round(Math.sin(v) * r)
                    };
                    var y = Math.cos(v) * e[2] / 2, x = Math.sin(v) * e[2] / 2;
                    g.tooltipPos = [e[0] + .7 * y, e[1] + .7 * x], g.half = v < -Math.PI / 2 || v > Math.PI / 2 ? 1 : 0, g.angle = v, m = Math.min(a, g.labelDistance / 5), g.labelPosition = {
                        natural: {
                            x: e[0] + y + Math.cos(v) * g.labelDistance,
                            y: e[1] + x + Math.sin(v) * g.labelDistance
                        },
                        final: {},
                        alignment: 0 > g.labelDistance ? "center" : g.half ? "right" : "left",
                        connectorPosition: {
                            breakAt: {x: e[0] + y + Math.cos(v) * m, y: e[1] + x + Math.sin(v) * m},
                            touchingSliceAt: {x: e[0] + y, y: e[1] + x}
                        }
                    }
                }
                d(this, "afterTranslate")
            },
            drawEmpty: function () {
                var t = this.options;
                if (0 === this.total) {
                    var e = this.center[0], i = this.center[1];
                    this.graph || (this.graph = this.chart.renderer.circle(e, i, 0).addClass("highcharts-graph").add(this.group)), this.graph.animate({
                        "stroke-width": t.borderWidth,
                        cx: e,
                        cy: i,
                        r: this.center[2] / 2,
                        fill: t.fillColor || "none",
                        stroke: t.color || "#cccccc"
                    })
                } else this.graph && (this.graph = this.graph.destroy())
            },
            redrawPoints: function () {
                var t, e, i, n, r = this, o = r.chart, s = o.renderer, l = r.options.shadow;
                this.drawEmpty(), !l || r.shadowGroup || o.styledMode || (r.shadowGroup = s.g("shadow").attr({zIndex: -1}).add(r.group)), r.points.forEach(function (h) {
                    var c = {};
                    if (e = h.graphic, !h.isNull && e) {
                        if (n = h.shapeArgs, t = h.getTranslate(), !o.styledMode) {
                            var u = h.shadowGroup;
                            l && !u && (u = h.shadowGroup = s.g("shadow").add(r.shadowGroup)), u && u.attr(t), i = r.pointAttribs(h, h.selected && "select")
                        }
                        h.delayedRendering ? (e.setRadialReference(r.center).attr(n).attr(t), o.styledMode || e.attr(i).attr({"stroke-linejoin": "round"}).shadow(l, u), h.delayedRendering = !1) : (e.setRadialReference(r.center), o.styledMode || a(!0, c, i), a(!0, c, n, t), e.animate(c)), e.attr({visibility: h.visible ? "inherit" : "hidden"}), e.addClass(h.getClassName())
                    } else e && (h.graphic = e.destroy())
                })
            },
            drawPoints: function () {
                var t = this.chart.renderer;
                this.points.forEach(function (e) {
                    e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0)
                })
            },
            searchPoint: s,
            sortByAngle: function (t, e) {
                t.sort(function (t, i) {
                    return void 0 !== t.angle && (i.angle - t.angle) * e
                })
            },
            drawLegendSymbol: t.LegendSymbolMixin.drawRectangle,
            getCenter: e.getCenter,
            getSymbol: s,
            drawGraph: null
        }, {
            init: function () {
                h.prototype.init.apply(this, arguments);
                var t = this;
                t.name = l(t.name, "Slice");
                var e = function (e) {
                    t.slice("select" === e.type)
                };
                return r(t, "select", e), r(t, "unselect", e), t
            }, isValid: function () {
                return n(this.y) && 0 <= this.y
            }, setVisible: function (t, e) {
                var i = this, n = i.series, r = n.chart, o = n.options.ignoreHiddenPoint;
                e = l(e, o), t !== i.visible && (i.visible = i.options.visible = t = void 0 === t ? !i.visible : t, n.options.data[n.data.indexOf(i)] = i.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (e) {
                    i[e] && i[e][t ? "show" : "hide"](!0)
                }), i.legendItem && r.legend.colorizeItem(i, t), t || "hover" !== i.state || i.setState(""), o && (n.isDirty = !0), e && r.redraw())
            }, slice: function (t, e, n) {
                var r = this.series;
                f(n, r.chart), l(e, !0), this.sliced = this.options.sliced = i(t) ? t : !this.sliced, r.options.data[r.data.indexOf(this)] = this.options, this.graphic.animate(this.getTranslate()), this.shadowGroup && this.shadowGroup.animate(this.getTranslate())
            }, getTranslate: function () {
                return this.sliced ? this.slicedTranslation : {translateX: 0, translateY: 0}
            }, haloPath: function (t) {
                var e = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {
                    innerR: e.r - 1,
                    start: e.start,
                    end: e.end
                })
            }, connectorShapes: {
                fixedOffset: function (t, e, i) {
                    var n = e.breakAt;
                    return e = e.touchingSliceAt, ["M", t.x, t.y].concat(i.softConnector ? ["C", t.x + ("left" === t.alignment ? -5 : 5), t.y, 2 * n.x - e.x, 2 * n.y - e.y, n.x, n.y] : ["L", n.x, n.y]).concat(["L", e.x, e.y])
                }, straight: function (t, e) {
                    return e = e.touchingSliceAt, ["M", t.x, t.y, "L", e.x, e.y]
                }, crookedLine: function (e, i, n) {
                    i = i.touchingSliceAt;
                    var r = this.series, o = r.center[0], a = r.chart.plotWidth, s = r.chart.plotLeft;
                    r = e.alignment;
                    var l = this.shapeArgs.r;
                    return n = t.relativeLength(n.crookDistance, 1), o = ["L", n = "left" === r ? o + l + (a + s - o - l) * (1 - n) : s + (o - l) * n, e.y], ("left" === r ? n > e.x || n < i.x : n < e.x || n > i.x) && (o = []), ["M", e.x, e.y].concat(o).concat(["L", i.x, i.y])
                }
            }, getConnectorPath: function () {
                var t = this.labelPosition, e = this.series.options.dataLabels, i = e.connectorShape,
                    n = this.connectorShapes;
                return n[i] && (i = n[i]), i.call(this, {
                    x: t.final.x,
                    y: t.final.y,
                    alignment: t.alignment
                }, t.connectorPosition, e)
            }
        })
    }), e(i, "parts/DataLabels.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isArray, r = e.objectEach, o = e.splat, a = t.arrayMax, s = t.extend, l = t.format,
            h = t.merge;
        e = t.noop;
        var c = t.pick, u = t.relativeLength, d = t.Series, f = t.seriesTypes, p = t.stableSort;
        t.distribute = function (e, i, n) {
            function r(t, e) {
                return t.target - e.target
            }

            var o, a = !0, s = e, l = [], h = 0, u = s.reducedLen || i;
            for (o = e.length; o--;) h += e[o].size;
            if (h > u) {
                for (p(e, function (t, e) {
                    return (e.rank || 0) - (t.rank || 0)
                }), h = o = 0; h <= u;) h += e[o].size, o++;
                l = e.splice(o - 1, e.length)
            }
            for (p(e, r), e = e.map(function (t) {
                return {size: t.size, targets: [t.target], align: c(t.align, .5)}
            }); a;) {
                for (o = e.length; o--;) a = e[o], h = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = Math.min(Math.max(0, h - a.size * a.align), i - a.size);
                for (o = e.length, a = !1; o--;) 0 < o && e[o - 1].pos + e[o - 1].size > e[o].pos && (e[o - 1].size += e[o].size, e[o - 1].targets = e[o - 1].targets.concat(e[o].targets), e[o - 1].align = .5, e[o - 1].pos + e[o - 1].size > i && (e[o - 1].pos = i - e[o - 1].size), e.splice(o, 1), a = !0)
            }
            s.push.apply(s, l), o = 0, e.some(function (e) {
                var r = 0;
                if (e.targets.some(function () {
                    if (s[o].pos = e.pos + r, Math.abs(s[o].pos - s[o].target) > n) return s.slice(0, o + 1).forEach(function (t) {
                        delete t.pos
                    }), s.reducedLen = (s.reducedLen || i) - .1 * i, s.reducedLen > .1 * i && t.distribute(s, i, n), !0;
                    r += s[o].size, o++
                })) return !0
            }), p(s, r)
        }, d.prototype.drawDataLabels = function () {
            function e(t, e) {
                var i, r = [];
                if (n(t) && !n(e)) r = t.map(function (t) {
                    return h(t, e)
                }); else if (n(e) && !n(t)) r = e.map(function (e) {
                    return h(t, e)
                }); else if (n(t) || n(e)) for (i = Math.max(t.length, e.length); i--;) r[i] = h(t[i], e[i]); else r = h(t, e);
                return r
            }

            var a = this, s = a.chart, u = a.options, d = u.dataLabels, f = a.points, p = a.hasRendered || 0,
                g = t.animObject(u.animation).duration, m = Math.min(g, 200),
                v = !s.renderer.forExport && c(d.defer, 0 < m), y = s.renderer;
            if (d = e(e(s.options.plotOptions && s.options.plotOptions.series && s.options.plotOptions.series.dataLabels, s.options.plotOptions && s.options.plotOptions[a.type] && s.options.plotOptions[a.type].dataLabels), d), t.fireEvent(this, "drawDataLabels"), n(d) || d.enabled || a._hasPointLabels) {
                var x = a.plotGroup("dataLabelsGroup", "data-labels", v && !p ? "hidden" : "inherit", d.zIndex || 6);
                v && (x.attr({opacity: +p}), p || setTimeout(function () {
                    var t = a.dataLabelsGroup;
                    t && (a.visible && x.show(!0), t[u.animation ? "animate" : "attr"]({opacity: 1}, {duration: m}))
                }, g - m)), f.forEach(function (t) {
                    o(e(d, t.dlOptions || t.options && t.options.dataLabels)).forEach(function (e, n) {
                        var o = e.enabled && (!t.isNull || t.dataLabelOnNull) && function (t, e) {
                                var i = e.filter;
                                return !i || (e = i.operator, t = t[i.property], i = i.value, ">" === e && t > i || "<" === e && t < i || ">=" === e && t >= i || "<=" === e && t <= i || "==" === e && t == i || "===" === e && t === i)
                            }(t, e), h = t.dataLabels ? t.dataLabels[n] : t.dataLabel,
                            d = t.connectors ? t.connectors[n] : t.connector, f = c(e.distance, t.labelDistance),
                            p = !h;
                        if (o) {
                            var g = t.getLabelConfig(), m = c(e[t.formatPrefix + "Format"], e.format);
                            g = i(m) ? l(m, g, s.time) : (e[t.formatPrefix + "Formatter"] || e.formatter).call(g, e), m = e.style;
                            var v = e.rotation;
                            s.styledMode || (m.color = c(e.color, m.color, a.color, "#000000"), "contrast" === m.color && (t.contrastColor = y.getContrast(t.color || a.color), m.color = !i(f) && e.inside || 0 > f || u.stacking ? t.contrastColor : "#000000"), u.cursor && (m.cursor = u.cursor));
                            var b = {r: e.borderRadius || 0, rotation: v, padding: e.padding, zIndex: 1};
                            s.styledMode || (b.fill = e.backgroundColor, b.stroke = e.borderColor, b["stroke-width"] = e.borderWidth), r(b, function (t, e) {
                                void 0 === t && delete b[e]
                            })
                        }
                        !h || o && i(g) ? o && i(g) && (h ? b.text = g : (t.dataLabels = t.dataLabels || [], h = t.dataLabels[n] = v ? y.text(g, 0, -9999).addClass("highcharts-data-label") : y.label(g, 0, -9999, e.shape, null, null, e.useHTML, null, "data-label"), n || (t.dataLabel = h), h.addClass(" highcharts-data-label-color-" + t.colorIndex + " " + (e.className || "") + (e.useHTML ? " highcharts-tracker" : ""))), h.options = e, h.attr(b), s.styledMode || h.css(m).shadow(e.shadow), h.added || h.add(x), e.textPath && !e.useHTML && h.setTextPath(t.getDataLabelPath && t.getDataLabelPath(h) || t.graphic, e.textPath), a.alignDataLabel(t, h, e, null, p)) : (t.dataLabel = t.dataLabel && t.dataLabel.destroy(), t.dataLabels && (1 === t.dataLabels.length ? delete t.dataLabels : delete t.dataLabels[n]), n || delete t.dataLabel, d && (t.connector = t.connector.destroy(), t.connectors && (1 === t.connectors.length ? delete t.connectors : delete t.connectors[n])))
                    })
                })
            }
            t.fireEvent(this, "afterDrawDataLabels")
        }, d.prototype.alignDataLabel = function (t, e, i, n, r) {
            var o = this.chart, a = this.isCartesian && o.inverted, l = c(t.dlBox && t.dlBox.centerX, t.plotX, -9999),
                h = c(t.plotY, -9999), u = e.getBBox(), d = i.rotation, f = i.align,
                p = this.visible && (t.series.forceDL || o.isInsidePlot(l, Math.round(h), a) || n && o.isInsidePlot(l, a ? n.x + 1 : n.y + n.height - 1, a)),
                g = "justify" === c(i.overflow, "justify");
            if (p) {
                var m = o.renderer.fontMetrics(o.styledMode ? void 0 : i.style.fontSize, e).b;
                n = s({
                    x: a ? this.yAxis.len - h : l,
                    y: Math.round(a ? this.xAxis.len - l : h),
                    width: 0,
                    height: 0
                }, n), s(i, {
                    width: u.width,
                    height: u.height
                }), d ? (g = !1, l = o.renderer.rotCorr(m, d), l = {
                    x: n.x + i.x + n.width / 2 + l.x,
                    y: n.y + i.y + {top: 0, middle: .5, bottom: 1}[i.verticalAlign] * n.height
                }, e[r ? "attr" : "animate"](l).attr({align: f}), h = 180 < (h = (d + 720) % 360) && 360 > h, "left" === f ? l.y -= h ? u.height : 0 : "center" === f ? (l.x -= u.width / 2, l.y -= u.height / 2) : "right" === f && (l.x -= u.width, l.y -= h ? 0 : u.height), e.placed = !0, e.alignAttr = l) : (e.align(i, null, n), l = e.alignAttr), g && 0 <= n.height ? this.justifyDataLabel(e, i, l, u, n, r) : c(i.crop, !0) && (p = o.isInsidePlot(l.x, l.y) && o.isInsidePlot(l.x + u.width, l.y + u.height)), i.shape && !d && e[r ? "attr" : "animate"]({
                    anchorX: a ? o.plotWidth - t.plotY : t.plotX,
                    anchorY: a ? o.plotHeight - t.plotX : t.plotY
                })
            }
            p || (e.hide(!0), e.placed = !1)
        }, d.prototype.justifyDataLabel = function (t, e, i, n, r, o) {
            var a = this.chart, s = e.align, l = e.verticalAlign, h = t.box ? 0 : t.padding || 0, c = i.x + h;
            if (0 > c) {
                "right" === s ? (e.align = "left", e.inside = !0) : e.x = -c;
                var u = !0
            }
            return (c = i.x + n.width - h) > a.plotWidth && ("left" === s ? (e.align = "right", e.inside = !0) : e.x = a.plotWidth - c, u = !0), 0 > (c = i.y + h) && ("bottom" === l ? (e.verticalAlign = "top", e.inside = !0) : e.y = -c, u = !0), (c = i.y + n.height - h) > a.plotHeight && ("top" === l ? (e.verticalAlign = "bottom", e.inside = !0) : e.y = a.plotHeight - c, u = !0), u && (t.placed = !o, t.align(e, null, r)), u
        }, f.pie && (f.pie.prototype.dataLabelPositioners = {
            radialDistributionY: function (t) {
                return t.top + t.distributeBox.pos
            }, radialDistributionX: function (t, e, i, n) {
                return t.getX(i < e.top + 2 || i > e.bottom - 2 ? n : i, e.half, e)
            }, justify: function (t, e, i) {
                return i[0] + (t.half ? -1 : 1) * (e + t.labelDistance)
            }, alignToPlotEdges: function (t, e, i, n) {
                return t = t.getBBox().width, e ? t + n : i - t - n
            }, alignToConnectors: function (t, e, i, n) {
                var r, o = 0;
                return t.forEach(function (t) {
                    (r = t.dataLabel.getBBox().width) > o && (o = r)
                }), e ? o + n : i - o - n
            }
        }, f.pie.prototype.drawDataLabels = function () {
            var e, n, r, o, s, l, u, f, p, g, m, v, y = this, x = y.data, b = y.chart, M = y.options.dataLabels,
                A = M.connectorPadding, w = b.plotWidth, k = b.plotHeight, S = b.plotLeft,
                T = Math.round(b.chartWidth / 3), E = y.center, C = E[2] / 2, D = E[1], P = [[], []], _ = [0, 0, 0, 0],
                O = y.dataLabelPositioners;
            y.visible && (M.enabled || y._hasPointLabels) && (x.forEach(function (t) {
                t.dataLabel && t.visible && t.dataLabel.shortened && (t.dataLabel.attr({width: "auto"}).css({
                    width: "auto",
                    textOverflow: "clip"
                }), t.dataLabel.shortened = !1)
            }), d.prototype.drawDataLabels.apply(y), x.forEach(function (t) {
                t.dataLabel && (t.visible ? (P[t.half].push(t), t.dataLabel._pos = null, !i(M.style.width) && !i(t.options.dataLabels && t.options.dataLabels.style && t.options.dataLabels.style.width) && t.dataLabel.getBBox().width > T && (t.dataLabel.css({width: .7 * T}), t.dataLabel.shortened = !0)) : (t.dataLabel = t.dataLabel.destroy(), t.dataLabels && 1 === t.dataLabels.length && delete t.dataLabels))
            }), P.forEach(function (n, r) {
                var a, h = n.length, d = [];
                if (h) {
                    if (y.sortByAngle(n, r - .5), 0 < y.maxLabelDistance) {
                        var v = Math.max(0, D - C - y.maxLabelDistance),
                            x = Math.min(D + C + y.maxLabelDistance, b.plotHeight);
                        n.forEach(function (t) {
                            0 < t.labelDistance && t.dataLabel && (t.top = Math.max(0, D - C - t.labelDistance), t.bottom = Math.min(D + C + t.labelDistance, b.plotHeight), a = t.dataLabel.getBBox().height || 21, t.distributeBox = {
                                target: t.labelPosition.natural.y - t.top + a / 2,
                                size: a,
                                rank: t.y
                            }, d.push(t.distributeBox))
                        }), v = x + a - v, t.distribute(d, v, v / 5)
                    }
                    for (m = 0; m < h; m++) {
                        if (e = n[m], l = e.labelPosition, o = e.dataLabel, g = !1 === e.visible ? "hidden" : "inherit", p = v = l.natural.y, d && i(e.distributeBox) && (void 0 === e.distributeBox.pos ? g = "hidden" : (u = e.distributeBox.size, p = O.radialDistributionY(e))), delete e.positionIndex, M.justify) f = O.justify(e, C, E); else switch (M.alignTo) {
                            case"connectors":
                                f = O.alignToConnectors(n, r, w, S);
                                break;
                            case"plotEdges":
                                f = O.alignToPlotEdges(o, r, w, S);
                                break;
                            default:
                                f = O.radialDistributionX(y, e, p, v)
                        }
                        o._attr = {visibility: g, align: l.alignment}, o._pos = {
                            x: f + M.x + ({
                                left: A,
                                right: -A
                            }[l.alignment] || 0), y: p + M.y - 10
                        }, l.final.x = f, l.final.y = p, c(M.crop, !0) && (s = o.getBBox().width, v = null, f - s < A && 1 === r ? (v = Math.round(s - f + A), _[3] = Math.max(v, _[3])) : f + s > w - A && 0 === r && (v = Math.round(f + s - w + A), _[1] = Math.max(v, _[1])), 0 > p - u / 2 ? _[0] = Math.max(Math.round(u / 2 - p), _[0]) : p + u / 2 > k && (_[2] = Math.max(Math.round(p + u / 2 - k), _[2])), o.sideOverflow = v)
                    }
                }
            }), 0 === a(_) || this.verifyDataLabelOverflow(_)) && (this.placeDataLabels(), this.points.forEach(function (t) {
                var e;
                (v = h(M, t.options.dataLabels), n = c(v.connectorWidth, 1)) && (r = t.connector, (o = t.dataLabel) && o._pos && t.visible && 0 < t.labelDistance ? (g = o._attr.visibility, (e = !r) && (t.connector = r = b.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + t.colorIndex + (t.className ? " " + t.className : "")).add(y.dataLabelsGroup), b.styledMode || r.attr({
                    "stroke-width": n,
                    stroke: v.connectorColor || t.color || "#666666"
                })), r[e ? "attr" : "animate"]({d: t.getConnectorPath()}), r.attr("visibility", g)) : r && (t.connector = r.destroy()))
            }))
        }, f.pie.prototype.placeDataLabels = function () {
            this.points.forEach(function (t) {
                var e, i = t.dataLabel;
                i && t.visible && ((e = i._pos) ? (i.sideOverflow && (i._attr.width = Math.max(i.getBBox().width - i.sideOverflow, 0), i.css({
                    width: i._attr.width + "px",
                    textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), i.shortened = !0), i.attr(i._attr), i[i.moved ? "animate" : "attr"](e), i.moved = !0) : i && i.attr({y: -9999})), delete t.distributeBox
            }, this)
        }, f.pie.prototype.alignDataLabel = e, f.pie.prototype.verifyDataLabelOverflow = function (t) {
            var e = this.center, i = this.options, n = i.center, r = i.minSize || 80, o = null !== i.size;
            if (!o) {
                if (null !== n[0]) var a = Math.max(e[2] - Math.max(t[1], t[3]), r); else a = Math.max(e[2] - t[1] - t[3], r), e[0] += (t[3] - t[1]) / 2;
                null !== n[1] ? a = Math.max(Math.min(a, e[2] - Math.max(t[0], t[2])), r) : (a = Math.max(Math.min(a, e[2] - t[0] - t[2]), r), e[1] += (t[0] - t[2]) / 2), a < e[2] ? (e[2] = a, e[3] = Math.min(u(i.innerSize || 0, a), a), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : o = !0
            }
            return o
        }), f.column && (f.column.prototype.alignDataLabel = function (t, e, i, n, r) {
            var o = this.chart.inverted, a = t.series, s = t.dlBox || t.shapeArgs,
                l = c(t.below, t.plotY > c(this.translatedThreshold, a.yAxis.len)),
                u = c(i.inside, !!this.options.stacking);
            s && (0 > (n = h(s)).y && (n.height += n.y, n.y = 0), 0 < (s = n.y + n.height - a.yAxis.len) && (n.height -= s), o && (n = {
                x: a.yAxis.len - n.y - n.height,
                y: a.xAxis.len - n.x - n.width,
                width: n.height,
                height: n.width
            }), u || (o ? (n.x += l ? 0 : n.width, n.width = 0) : (n.y += l ? n.height : 0, n.height = 0))), i.align = c(i.align, !o || u ? "center" : l ? "right" : "left"), i.verticalAlign = c(i.verticalAlign, o || u ? "middle" : l ? "top" : "bottom"), d.prototype.alignDataLabel.call(this, t, e, i, n, r), i.inside && t.contrastColor && e.css({color: t.contrastColor})
        })
    }), e(i, "modules/overlapping-datalabels.src.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.isArray, n = e.objectEach;
        e = t.Chart;
        var r = t.pick, o = t.addEvent, a = t.fireEvent;
        o(e, "render", function () {
            var t = [];
            (this.labelCollectors || []).forEach(function (e) {
                t = t.concat(e())
            }), (this.yAxis || []).forEach(function (e) {
                e.options.stackLabels && !e.options.stackLabels.allowOverlap && n(e.stacks, function (e) {
                    n(e, function (e) {
                        t.push(e.label)
                    })
                })
            }), (this.series || []).forEach(function (e) {
                var n = e.options.dataLabels;
                e.visible && (!1 !== n.enabled || e._hasPointLabels) && e.points.forEach(function (e) {
                    e.visible && (i(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : []).forEach(function (i) {
                        var n = i.options;
                        i.labelrank = r(n.labelrank, e.labelrank, e.shapeArgs && e.shapeArgs.height), n.allowOverlap || t.push(i)
                    })
                })
            }), this.hideOverlappingLabels(t)
        }), e.prototype.hideOverlappingLabels = function (t) {
            var e, i, n, r = this, o = t.length, s = r.renderer, l = function (t) {
                var e = t.box ? 0 : t.padding || 0, i = 0;
                if (t && (!t.alignAttr || t.placed)) {
                    var n = t.alignAttr || {x: t.attr("x"), y: t.attr("y")}, r = t.parentGroup;
                    return t.width || (i = t.getBBox(), t.width = i.width, t.height = i.height, i = s.fontMetrics(null, t.element).h), {
                        x: n.x + (r.translateX || 0) + e,
                        y: n.y + (r.translateY || 0) + e - i,
                        width: t.width - 2 * e,
                        height: t.height - 2 * e
                    }
                }
            };
            for (i = 0; i < o; i++) (e = t[i]) && (e.oldOpacity = e.opacity, e.newOpacity = 1, e.absoluteBox = l(e));
            for (t.sort(function (t, e) {
                return (e.labelrank || 0) - (t.labelrank || 0)
            }), i = 0; i < o; i++) {
                var h = (l = t[i]) && l.absoluteBox;
                for (e = i + 1; e < o; ++e) {
                    var c = (n = t[e]) && n.absoluteBox;
                    !h || !c || l === n || 0 === l.newOpacity || 0 === n.newOpacity || c.x > h.x + h.width || c.x + c.width < h.x || c.y > h.y + h.height || c.y + c.height < h.y || ((l.labelrank < n.labelrank ? l : n).newOpacity = 0)
                }
            }
            t.forEach(function (t) {
                var e;
                if (t) {
                    var i = t.newOpacity;
                    t.oldOpacity !== i && (t.alignAttr && t.placed ? (i ? t.show(!0) : e = function () {
                        t.hide(!0), t.placed = !1
                    }, t.alignAttr.opacity = i, t[t.isOld ? "animate" : "attr"](t.alignAttr, null, e), a(r, "afterHideOverlappingLabels")) : t.attr({opacity: i})), t.isOld = !0
                }
            })
        }
    }), e(i, "parts/Interaction.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isArray, r = e.isObject, o = e.objectEach, a = t.addEvent;
        e = t.Chart;
        var s = t.createElement, l = t.css, h = t.defaultOptions, c = t.defaultPlotOptions, u = t.extend,
            d = t.fireEvent, f = t.hasTouch, p = t.Legend, g = t.merge, m = t.pick, v = t.Point, y = t.Series,
            x = t.seriesTypes, b = t.svg, M = t.TrackerMixin = {
                drawTrackerPoint: function () {
                    var t, e = this, i = e.chart, r = i.pointer, o = function (t) {
                        var e = r.getPointFromEvent(t);
                        void 0 !== e && (r.isDirectTouch = !0, e.onMouseOver(t))
                    };
                    e.points.forEach(function (e) {
                        t = n(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : [], e.graphic && (e.graphic.element.point = e), t.forEach(function (t) {
                            t.div ? t.div.point = e : t.element.point = e
                        })
                    }), e._hasTracking || (e.trackerGroups.forEach(function (t) {
                        e[t] && (e[t].addClass("highcharts-tracker").on("mouseover", o).on("mouseout", function (t) {
                            r.onTrackerMouseOut(t)
                        }), f && e[t].on("touchstart", o), !i.styledMode && e.options.cursor && e[t].css(l).css({cursor: e.options.cursor}))
                    }), e._hasTracking = !0), d(this, "afterDrawTracker")
                }, drawTrackerGraph: function () {
                    var t, e = this, i = e.options, n = i.trackByArea, r = [].concat(n ? e.areaPath : e.graphPath),
                        o = r.length, a = e.chart, s = a.pointer, l = a.renderer, h = a.options.tooltip.snap, c = e.tracker,
                        u = function () {
                            a.hoverSeries !== e && e.onMouseOver()
                        }, p = "rgba(192,192,192," + (b ? 1e-4 : .002) + ")";
                    if (o && !n) for (t = o + 1; t--;) "M" === r[t] && r.splice(t + 1, 0, r[t + 1] - h, r[t + 2], "L"), (t && "M" === r[t] || t === o) && r.splice(t, 0, "L", r[t - 2] + h, r[t - 1]);
                    c ? c.attr({d: r}) : e.graph && (e.tracker = l.path(r).attr({
                        visibility: e.visible ? "visible" : "hidden",
                        zIndex: 2
                    }).addClass(n ? "highcharts-tracker-area" : "highcharts-tracker-line").add(e.group), a.styledMode || e.tracker.attr({
                        "stroke-linejoin": "round",
                        stroke: p,
                        fill: n ? p : "none",
                        "stroke-width": e.graph.strokeWidth() + (n ? 0 : 2 * h)
                    }), [e.tracker, e.markerGroup].forEach(function (t) {
                        t.addClass("highcharts-tracker").on("mouseover", u).on("mouseout", function (t) {
                            s.onTrackerMouseOut(t)
                        }), i.cursor && !a.styledMode && t.css({cursor: i.cursor}), f && t.on("touchstart", u)
                    })), d(this, "afterDrawTracker")
                }
            };
        x.column && (x.column.prototype.drawTracker = M.drawTrackerPoint), x.pie && (x.pie.prototype.drawTracker = M.drawTrackerPoint), x.scatter && (x.scatter.prototype.drawTracker = M.drawTrackerPoint), u(p.prototype, {
            setItemEvents: function (t, e, i) {
                var n = this, r = n.chart.renderer.boxWrapper, o = t instanceof v,
                    a = "highcharts-legend-" + (o ? "point" : "series") + "-active", s = n.chart.styledMode;
                (i ? e : t.legendGroup).on("mouseover", function () {
                    t.visible && n.allItems.forEach(function (e) {
                        t !== e && e.setState("inactive", !o)
                    }), t.setState("hover"), t.visible && r.addClass(a), s || e.css(n.options.itemHoverStyle)
                }).on("mouseout", function () {
                    n.chart.styledMode || e.css(g(t.visible ? n.itemStyle : n.itemHiddenStyle)), n.allItems.forEach(function (e) {
                        t !== e && e.setState("", !o)
                    }), r.removeClass(a), t.setState()
                }).on("click", function (e) {
                    var i = function () {
                        t.setVisible && t.setVisible(), n.allItems.forEach(function (e) {
                            t !== e && e.setState(t.visible ? "inactive" : "", !o)
                        })
                    };
                    r.removeClass(a), e = {browserEvent: e}, t.firePointEvent ? t.firePointEvent("legendItemClick", e, i) : d(t, "legendItemClick", e, i)
                })
            }, createCheckboxForItem: function (t) {
                t.checkbox = s("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: t.selected,
                    defaultChecked: t.selected
                }, this.options.itemCheckboxStyle, this.chart.container), a(t.checkbox, "click", function (e) {
                    d(t.series || t, "checkboxClick", {checked: e.target.checked, item: t}, function () {
                        t.select()
                    })
                })
            }
        }), u(e.prototype, {
            showResetZoom: function () {
                function t() {
                    e.zoomOut()
                }

                var e = this, i = h.lang, n = e.options.chart.resetZoomButton, r = n.theme, o = r.states,
                    a = "chart" === n.relativeTo || "spaceBox" === n.relativeTo ? null : "plotBox";
                d(this, "beforeShowResetZoom", null, function () {
                    e.resetZoomButton = e.renderer.button(i.resetZoom, null, null, t, r, o && o.hover).attr({
                        align: n.position.align,
                        title: i.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(n.position, !1, a)
                }), d(this, "afterShowResetZoom")
            }, zoomOut: function () {
                d(this, "selection", {resetSelection: !0}, this.zoom)
            }, zoom: function (t) {
                var e, n = this, o = n.pointer, a = !1, s = n.inverted ? o.mouseDownX : o.mouseDownY;
                !t || t.resetSelection ? (n.axes.forEach(function (t) {
                    e = t.zoom()
                }), o.initiated = !1) : t.xAxis.concat(t.yAxis).forEach(function (t) {
                    var r = t.axis, l = n.inverted ? r.left : r.top, h = n.inverted ? l + r.width : l + r.height,
                        c = r.isXAxis, u = !1;
                    (!c && s >= l && s <= h || c || !i(s)) && (u = !0), o[c ? "zoomX" : "zoomY"] && u && (e = r.zoom(t.min, t.max), r.displayBtn && (a = !0))
                });
                var l = n.resetZoomButton;
                a && !l ? n.showResetZoom() : !a && r(l) && (n.resetZoomButton = l.destroy()), e && n.redraw(m(n.options.chart.animation, t && t.animation, 100 > n.pointCount))
            }, pan: function (t, e) {
                var i, n = this, r = n.hoverPoints;
                d(this, "pan", {originalEvent: t}, function () {
                    r && r.forEach(function (t) {
                        t.setState()
                    }), ("xy" === e ? [1, 0] : [1]).forEach(function (e) {
                        var r = (e = n[e ? "xAxis" : "yAxis"][0]).horiz, o = t[r ? "chartX" : "chartY"],
                            a = n[r = r ? "mouseDownX" : "mouseDownY"], s = (e.pointRange || 0) / 2,
                            l = e.reversed && !n.inverted || !e.reversed && n.inverted ? -1 : 1, h = e.getExtremes(),
                            c = e.toValue(a - o, !0) + s * l, u = (l = e.toValue(a + e.len - o, !0) - s * l) < c;
                        a = u ? l : c, c = u ? c : l, 0 < (u = (l = Math.min(h.dataMin, s ? h.min : e.toValue(e.toPixels(h.min) - e.minPixelPadding))) - a) && (c += u, a = l), 0 < (u = c - (s = Math.max(h.dataMax, s ? h.max : e.toValue(e.toPixels(h.max) + e.minPixelPadding)))) && (c = s, a -= u), e.series.length && a !== h.min && c !== h.max && (e.setExtremes(a, c, !1, !1, {trigger: "pan"}), i = !0), n[r] = o
                    }), i && n.redraw(!1), l(n.container, {cursor: "move"})
                })
            }
        }), u(v.prototype, {
            select: function (t, e) {
                var i = this, n = i.series, r = n.chart;
                this.selectedStaging = t = m(t, !i.selected), i.firePointEvent(t ? "select" : "unselect", {accumulate: e}, function () {
                    i.selected = i.options.selected = t, n.options.data[n.data.indexOf(i)] = i.options, i.setState(t && "select"), e || r.getSelectedPoints().forEach(function (t) {
                        var e = t.series;
                        t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(r.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), t.firePointEvent("unselect"))
                    })
                }), delete this.selectedStaging
            }, onMouseOver: function (t) {
                var e = this.series.chart, i = e.pointer;
                t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e.inverted), i.runPointActions(t, this)
            }, onMouseOut: function () {
                var t = this.series.chart;
                this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (t) {
                    t.setState()
                }), t.hoverPoints = t.hoverPoint = null
            }, importEvents: function () {
                if (!this.hasImportedEvents) {
                    var e = this, i = g(e.series.options.point, e.options).events;
                    e.events = i, o(i, function (i, n) {
                        t.isFunction(i) && a(e, n, i)
                    }), this.hasImportedEvents = !0
                }
            }, setState: function (t, e) {
                var i, n = this.series, r = this.state, o = n.options.states[t || "normal"] || {},
                    a = c[n.type].marker && n.options.marker, s = a && !1 === a.enabled,
                    l = a && a.states && a.states[t || "normal"] || {}, h = !1 === l.enabled, f = n.stateMarkerGraphic,
                    p = this.marker || {}, g = n.chart, v = n.halo, y = a && n.markerAttribs;
                if (!((t = t || "") === this.state && !e || this.selected && "select" !== t || !1 === o.enabled || t && (h || s && !1 === l.enabled) || t && p.states && p.states[t] && !1 === p.states[t].enabled)) {
                    if (this.state = t, y && (i = n.markerAttribs(this, t)), this.graphic) {
                        if (r && this.graphic.removeClass("highcharts-point-" + r), t && this.graphic.addClass("highcharts-point-" + t), !g.styledMode) {
                            var x = n.pointAttribs(this, t), b = m(g.options.chart.animation, o.animation);
                            n.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (t) {
                                t && t.animate({opacity: x.opacity}, b)
                            }), this.connector && this.connector.animate({opacity: x.opacity}, b)), this.graphic.animate(x, b)
                        }
                        i && this.graphic.animate(i, m(g.options.chart.animation, l.animation, a.animation)), f && f.hide()
                    } else t && l && (r = p.symbol || n.symbol, f && f.currentSymbol !== r && (f = f.destroy()), i && (f ? f[e ? "animate" : "attr"]({
                        x: i.x,
                        y: i.y
                    }) : r && (n.stateMarkerGraphic = f = g.renderer.symbol(r, i.x, i.y, i.width, i.height).add(n.markerGroup), f.currentSymbol = r)), !g.styledMode && f && f.attr(n.pointAttribs(this, t))), f && (f[t && this.isInside ? "show" : "hide"](), f.element.point = this);
                    t = o.halo, o = (f = this.graphic || f) && f.visibility || "inherit", t && t.size && f && "hidden" !== o ? (v || (n.halo = v = g.renderer.path().add(f.parentGroup)), v.show()[e ? "animate" : "attr"]({d: this.haloPath(t.size)}), v.attr({
                        class: "highcharts-halo highcharts-color-" + m(this.colorIndex, n.colorIndex) + (this.className ? " " + this.className : ""),
                        visibility: o,
                        zIndex: -1
                    }), v.point = this, g.styledMode || v.attr(u({
                        fill: this.color || n.color,
                        "fill-opacity": t.opacity
                    }, t.attributes))) : v && v.point && v.point.haloPath && v.animate({d: v.point.haloPath(0)}, null, v.hide), d(this, "afterSetState")
                }
            }, haloPath: function (t) {
                return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - t, this.plotY - t, 2 * t, 2 * t)
            }
        }), u(y.prototype, {
            onMouseOver: function () {
                var t = this.chart, e = t.hoverSeries;
                e && e !== this && e.onMouseOut(), this.options.events.mouseOver && d(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this
            }, onMouseOut: function () {
                var t = this.options, e = this.chart, i = e.tooltip, n = e.hoverPoint;
                e.hoverSeries = null, n && n.onMouseOut(), this && t.events.mouseOut && d(this, "mouseOut"), !i || this.stickyTracking || i.shared && !this.noSharedTooltip || i.hide(), e.series.forEach(function (t) {
                    t.setState("", !0)
                })
            }, setState: function (t, e) {
                var i = this, n = i.options, r = i.graph, o = n.inactiveOtherPoints, a = n.states, s = n.lineWidth,
                    l = n.opacity,
                    h = m(a[t || "normal"] && a[t || "normal"].animation, i.chart.options.chart.animation);
                if (n = 0, t = t || "", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (e) {
                    e && (i.state && e.removeClass("highcharts-series-" + i.state), t && e.addClass("highcharts-series-" + t))
                }), i.state = t, !i.chart.styledMode)) {
                    if (a[t] && !1 === a[t].enabled) return;
                    if (t && (s = a[t].lineWidth || s + (a[t].lineWidthPlus || 0), l = m(a[t].opacity, l)), r && !r.dashstyle) for (a = {"stroke-width": s}, r.animate(a, h); i["zone-graph-" + n];) i["zone-graph-" + n].attr(a), n += 1;
                    o || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (t) {
                        t && t.animate({opacity: l}, h)
                    })
                }
                e && o && i.points && i.setAllPointsToState(t)
            }, setAllPointsToState: function (t) {
                this.points.forEach(function (e) {
                    e.setState && e.setState(t)
                })
            }, setVisible: function (t, e) {
                var i = this, n = i.chart, r = i.legendItem, o = n.options.chart.ignoreHiddenSeries, a = i.visible,
                    s = (i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !a : t) ? "show" : "hide";
                ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (t) {
                    i[t] && i[t][s]()
                }), n.hoverSeries !== i && (n.hoverPoint && n.hoverPoint.series) !== i || i.onMouseOut(), r && n.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && n.series.forEach(function (t) {
                    t.options.stacking && t.visible && (t.isDirty = !0)
                }), i.linkedSeries.forEach(function (e) {
                    e.setVisible(t, !1)
                }), o && (n.isDirtyBox = !0), d(i, s), !1 !== e && n.redraw()
            }, show: function () {
                this.setVisible(!0)
            }, hide: function () {
                this.setVisible(!1)
            }, select: function (t) {
                this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), d(this, t ? "select" : "unselect")
            }, drawTracker: M.drawTrackerGraph
        })
    }), e(i, "parts/Responsive.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.isArray, n = e.isObject, r = e.objectEach, o = e.splat;
        e = t.Chart;
        var a = t.pick;
        e.prototype.setResponsive = function (e, i) {
            var n = this.options.responsive, r = [], o = this.currentResponsive;
            !i && n && n.rules && n.rules.forEach(function (e) {
                void 0 === e._id && (e._id = t.uniqueKey()), this.matchResponsiveRule(e, r)
            }, this), (i = t.merge.apply(0, r.map(function (e) {
                return t.find(n.rules, function (t) {
                    return t._id === e
                }).chartOptions
            }))).isResponsiveOptions = !0, (r = r.toString() || void 0) !== (o && o.ruleIds) && (o && this.update(o.undoOptions, e, !0), r ? ((o = this.currentOptions(i)).isResponsiveOptions = !0, this.currentResponsive = {
                ruleIds: r,
                mergedOptions: i,
                undoOptions: o
            }, this.update(i, e, !0)) : this.currentResponsive = void 0)
        }, e.prototype.matchResponsiveRule = function (t, e) {
            var i = t.condition;
            (i.callback || function () {
                return this.chartWidth <= a(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= a(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= a(i.minWidth, 0) && this.chartHeight >= a(i.minHeight, 0)
            }).call(this) && e.push(t._id)
        }, e.prototype.currentOptions = function (t) {
            var e = this, a = {};
            return function t(a, s, l, h) {
                var c;
                r(a, function (r, a) {
                    if (!h && -1 < e.collectionsWithUpdate.indexOf(a)) for (r = o(r), l[a] = [], c = 0; c < r.length; c++) s[a][c] && (l[a][c] = {}, t(r[c], s[a][c], l[a][c], h + 1)); else n(r) ? (l[a] = i(r) ? [] : {}, t(r, s[a] || {}, l[a], h + 1)) : l[a] = void 0 === s[a] ? null : s[a]
                })
            }(t, this.options, a, 0), a
        }
    }), e(i, "masters/highcharts.src.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        return (0, t.extend)(t, {
            attr: e.attr,
            defined: e.defined,
            erase: e.erase,
            isArray: e.isArray,
            isClass: e.isClass,
            isDOMElement: e.isDOMElement,
            isNumber: e.isNumber,
            isObject: e.isObject,
            isString: e.isString,
            objectEach: e.objectEach,
            pInt: e.pInt,
            splat: e.splat
        }), t
    }), e(i, "parts/Scrollbar.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        function i(t, e, i) {
            this.init(t, e, i)
        }

        var n = e.defined, r = t.addEvent;
        e = t.Axis;
        var o, a = t.correctFloat, s = t.defaultOptions, l = t.destroyObjectProperties, h = t.fireEvent, c = t.hasTouch,
            u = t.merge, d = t.pick, f = t.removeEvent, p = {
                height: t.isTouchDevice ? 20 : 14,
                barBorderRadius: 0,
                buttonBorderRadius: 0,
                liveRedraw: void 0,
                margin: 10,
                minWidth: 6,
                step: .2,
                zIndex: 3,
                barBackgroundColor: "#cccccc",
                barBorderWidth: 1,
                barBorderColor: "#cccccc",
                buttonArrowColor: "#333333",
                buttonBackgroundColor: "#e6e6e6",
                buttonBorderColor: "#cccccc",
                buttonBorderWidth: 1,
                rifleColor: "#333333",
                trackBackgroundColor: "#f2f2f2",
                trackBorderColor: "#f2f2f2",
                trackBorderWidth: 1
            };
        s.scrollbar = u(!0, p, s.scrollbar), t.swapXY = o = function (t, e) {
            var i = t.length;
            if (e) for (e = 0; e < i; e += 3) {
                var n = t[e + 1];
                t[e + 1] = t[e + 2], t[e + 2] = n
            }
            return t
        }, i.prototype = {
            init: function (t, e, i) {
                this.scrollbarButtons = [], this.renderer = t, this.userOptions = e, this.options = u(p, e), this.chart = i, this.size = d(this.options.size, this.options.height), e.enabled && (this.render(), this.initEvents(), this.addEvents())
            }, render: function () {
                var t, e = this.renderer, i = this.options, n = this.size, r = this.chart.styledMode;
                this.group = t = e.g("scrollbar").attr({
                    zIndex: i.zIndex,
                    translateY: -99999
                }).add(), this.track = e.rect().addClass("highcharts-scrollbar-track").attr({
                    x: 0,
                    r: i.trackBorderRadius || 0,
                    height: n,
                    width: n
                }).add(t), r || this.track.attr({
                    fill: i.trackBackgroundColor,
                    stroke: i.trackBorderColor,
                    "stroke-width": i.trackBorderWidth
                }), this.trackBorderWidth = this.track.strokeWidth(), this.track.attr({y: -this.trackBorderWidth % 2 / 2}), this.scrollbarGroup = e.g().add(t), this.scrollbar = e.rect().addClass("highcharts-scrollbar-thumb").attr({
                    height: n,
                    width: n,
                    r: i.barBorderRadius || 0
                }).add(this.scrollbarGroup), this.scrollbarRifles = e.path(o(["M", -3, n / 4, "L", -3, 2 * n / 3, "M", 0, n / 4, "L", 0, 2 * n / 3, "M", 3, n / 4, "L", 3, 2 * n / 3], i.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), r || (this.scrollbar.attr({
                    fill: i.barBackgroundColor,
                    stroke: i.barBorderColor,
                    "stroke-width": i.barBorderWidth
                }), this.scrollbarRifles.attr({
                    stroke: i.rifleColor,
                    "stroke-width": 1
                })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2), this.drawScrollbarButton(0), this.drawScrollbarButton(1)
            }, position: function (t, e, i, n) {
                var r = this.options.vertical, o = 0, a = this.rendered ? "animate" : "attr";
                this.x = t, this.y = e + this.trackBorderWidth, this.width = i, this.xOffset = this.height = n, this.yOffset = o, r ? (this.width = this.yOffset = i = o = this.size, this.xOffset = e = 0, this.barWidth = n - 2 * i, this.x = t += this.options.margin) : (this.height = this.xOffset = n = e = this.size, this.barWidth = i - 2 * n, this.y += this.options.margin), this.group[a]({
                    translateX: t,
                    translateY: this.y
                }), this.track[a]({width: i, height: n}), this.scrollbarButtons[1][a]({
                    translateX: r ? 0 : i - e,
                    translateY: r ? n - o : 0
                })
            }, drawScrollbarButton: function (t) {
                var e = this.renderer, i = this.scrollbarButtons, n = this.options, r = this.size,
                    a = e.g().add(this.group);
                i.push(a), a = e.rect().addClass("highcharts-scrollbar-button").add(a), this.chart.styledMode || a.attr({
                    stroke: n.buttonBorderColor,
                    "stroke-width": n.buttonBorderWidth,
                    fill: n.buttonBackgroundColor
                }), a.attr(a.crisp({
                    x: -.5,
                    y: -.5,
                    width: r + 1,
                    height: r + 1,
                    r: n.buttonBorderRadius
                }, a.strokeWidth())), a = e.path(o(["M", r / 2 + (t ? -1 : 1), r / 2 - 3, "L", r / 2 + (t ? -1 : 1), r / 2 + 3, "L", r / 2 + (t ? 2 : -2), r / 2], n.vertical)).addClass("highcharts-scrollbar-arrow").add(i[t]), this.chart.styledMode || a.attr({fill: n.buttonArrowColor})
            }, setRange: function (t, e) {
                var i, r = this.options, o = r.vertical, s = r.minWidth, l = this.barWidth,
                    h = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
                if (n(l)) {
                    t = Math.max(t, 0);
                    var c = Math.ceil(l * t);
                    this.calculatedWidth = i = a(l * Math.min(e, 1) - c), i < s && (c = (l - s + i) * t, i = s), s = Math.floor(c + this.xOffset + this.yOffset), l = i / 2 - .5, this.from = t, this.to = e, o ? (this.scrollbarGroup[h]({translateY: s}), this.scrollbar[h]({height: i}), this.scrollbarRifles[h]({translateY: l}), this.scrollbarTop = s, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({translateX: s}), this.scrollbar[h]({width: i}), this.scrollbarRifles[h]({translateX: l}), this.scrollbarLeft = s, this.scrollbarTop = 0), 12 >= i ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), !1 === r.showFull && (0 >= t && 1 <= e ? this.group.hide() : this.group.show()), this.rendered = !0
                }
            }, initEvents: function () {
                var t = this;
                t.mouseMoveHandler = function (e) {
                    var i = t.chart.pointer.normalize(e), n = t.options.vertical ? "chartY" : "chartX",
                        r = t.initPositions;
                    !t.grabbedCenter || e.touches && 0 === e.touches[0][n] || (n = (i = t.cursorToScrollbarPosition(i)[n]) - (n = t[n]), t.hasDragged = !0, t.updatePosition(r[0] + n, r[1] + n), t.hasDragged && h(t, "changed", {
                        from: t.from,
                        to: t.to,
                        trigger: "scrollbar",
                        DOMType: e.type,
                        DOMEvent: e
                    }))
                }, t.mouseUpHandler = function (e) {
                    t.hasDragged && h(t, "changed", {
                        from: t.from,
                        to: t.to,
                        trigger: "scrollbar",
                        DOMType: e.type,
                        DOMEvent: e
                    }), t.grabbedCenter = t.hasDragged = t.chartX = t.chartY = null
                }, t.mouseDownHandler = function (e) {
                    e = t.chart.pointer.normalize(e), e = t.cursorToScrollbarPosition(e), t.chartX = e.chartX, t.chartY = e.chartY, t.initPositions = [t.from, t.to], t.grabbedCenter = !0
                }, t.buttonToMinClick = function (e) {
                    var i = a(t.to - t.from) * t.options.step;
                    t.updatePosition(a(t.from - i), a(t.to - i)), h(t, "changed", {
                        from: t.from,
                        to: t.to,
                        trigger: "scrollbar",
                        DOMEvent: e
                    })
                }, t.buttonToMaxClick = function (e) {
                    var i = (t.to - t.from) * t.options.step;
                    t.updatePosition(t.from + i, t.to + i), h(t, "changed", {
                        from: t.from,
                        to: t.to,
                        trigger: "scrollbar",
                        DOMEvent: e
                    })
                }, t.trackClick = function (e) {
                    var i = t.chart.pointer.normalize(e), n = t.to - t.from, r = t.y + t.scrollbarTop,
                        o = t.x + t.scrollbarLeft;
                    t.options.vertical && i.chartY > r || !t.options.vertical && i.chartX > o ? t.updatePosition(t.from + n, t.to + n) : t.updatePosition(t.from - n, t.to - n), h(t, "changed", {
                        from: t.from,
                        to: t.to,
                        trigger: "scrollbar",
                        DOMEvent: e
                    })
                }
            }, cursorToScrollbarPosition: function (t) {
                var e = this.options;
                return e = e.minWidth > this.calculatedWidth ? e.minWidth : 0, {
                    chartX: (t.chartX - this.x - this.xOffset) / (this.barWidth - e),
                    chartY: (t.chartY - this.y - this.yOffset) / (this.barWidth - e)
                }
            }, updatePosition: function (t, e) {
                1 < e && (t = a(1 - a(e - t)), e = 1), 0 > t && (e = a(e - t), t = 0), this.from = t, this.to = e
            }, update: function (t) {
                this.destroy(), this.init(this.chart.renderer, u(!0, this.options, t), this.chart)
            }, addEvents: function () {
                var t = this.options.inverted ? [1, 0] : [0, 1], e = this.scrollbarButtons,
                    i = this.scrollbarGroup.element, n = this.mouseDownHandler, o = this.mouseMoveHandler,
                    a = this.mouseUpHandler;
                t = [[e[t[0]].element, "click", this.buttonToMinClick], [e[t[1]].element, "click", this.buttonToMaxClick], [this.track.element, "click", this.trackClick], [i, "mousedown", n], [i.ownerDocument, "mousemove", o], [i.ownerDocument, "mouseup", a]], c && t.push([i, "touchstart", n], [i.ownerDocument, "touchmove", o], [i.ownerDocument, "touchend", a]), t.forEach(function (t) {
                    r.apply(null, t)
                }), this._events = t
            }, removeEvents: function () {
                this._events.forEach(function (t) {
                    f.apply(null, t)
                }), this._events.length = 0
            }, destroy: function () {
                var t = this.chart.scroller;
                this.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function (t) {
                    this[t] && this[t].destroy && (this[t] = this[t].destroy())
                }, this), t && this === t.scrollbar && (t.scrollbar = null, l(t.scrollbarButtons))
            }
        }, t.Scrollbar || (r(e, "afterInit", function () {
            var e = this;
            e.options && e.options.scrollbar && e.options.scrollbar.enabled && (e.options.scrollbar.vertical = !e.horiz, e.options.startOnTick = e.options.endOnTick = !1, e.scrollbar = new i(e.chart.renderer, e.options.scrollbar, e.chart), r(e.scrollbar, "changed", function (i) {
                var r = Math.min(d(e.options.min, e.min), e.min, e.dataMin),
                    o = Math.max(d(e.options.max, e.max), e.max, e.dataMax) - r;
                if (e.horiz && !e.reversed || !e.horiz && e.reversed) {
                    var a = r + o * this.to;
                    r += o * this.from
                } else a = r + o * (1 - this.from), r += o * (1 - this.to);
                d(this.options.liveRedraw, t.svg && !t.isTouchDevice && !this.chart.isBoosting) || "mouseup" === i.DOMType || !n(i.DOMType) ? e.setExtremes(r, a, !0, "mousemove" !== i.DOMType, i) : this.setRange(this.from, this.to)
            }))
        }), r(e, "afterRender", function () {
            var t = Math.min(d(this.options.min, this.min), this.min, d(this.dataMin, this.min)),
                e = Math.max(d(this.options.max, this.max), this.max, d(this.dataMax, this.max)), i = this.scrollbar,
                r = this.axisTitleMargin + (this.titleOffset || 0), o = this.chart.scrollbarsOffsets,
                a = this.options.margin || 0;
            i && (this.horiz ? (this.opposite || (o[1] += r), i.position(this.left, this.top + this.height + 2 + o[1] - (this.opposite ? a : 0), this.width, this.height), this.opposite || (o[1] += a), r = 1) : (this.opposite && (o[0] += r), i.position(this.left + this.width + 2 + o[0] - (this.opposite ? 0 : a), this.top, this.width, this.height), this.opposite && (o[0] += a), r = 0), o[r] += i.size + i.options.margin, isNaN(t) || isNaN(e) || !n(this.min) || !n(this.max) || this.min === this.max ? i.setRange(0, 1) : (o = (this.min - t) / (e - t), t = (this.max - t) / (e - t), this.horiz && !this.reversed || !this.horiz && this.reversed ? i.setRange(o, t) : i.setRange(1 - t, 1 - o)))
        }), r(e, "afterGetOffset", function () {
            var t = this.horiz ? 2 : 1, e = this.scrollbar;
            e && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[t] += e.size + e.options.margin)
        }), t.Scrollbar = i)
    }), e(i, "parts/Navigator.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        function i(t) {
            this.init(t)
        }

        var n = e.defined, r = e.erase, o = e.isArray, a = e.isNumber, s = e.splat, l = t.addEvent, h = t.Axis;
        e = t.Chart;
        var c = t.color, u = t.defaultOptions, d = t.destroyObjectProperties, f = t.extend, p = t.hasTouch,
            g = t.isTouchDevice, m = t.merge, v = t.pick, y = t.removeEvent, x = t.Scrollbar, b = t.Series,
            M = function (t) {
                for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
                if ((e = [].filter.call(e, a)).length) return Math[t].apply(0, e)
            }, A = void 0 === t.seriesTypes.areaspline ? "line" : "areaspline";
        f(u, {
            navigator: {
                height: 40,
                margin: 25,
                maskInside: !0,
                handles: {
                    width: 7,
                    height: 15,
                    symbols: ["navigator-handle", "navigator-handle"],
                    enabled: !0,
                    lineWidth: 1,
                    backgroundColor: "#f2f2f2",
                    borderColor: "#999999"
                },
                maskFill: c("#6685c2").setOpacity(.3).get(),
                outlineColor: "#cccccc",
                outlineWidth: 1,
                series: {
                    type: A,
                    fillOpacity: .05,
                    lineWidth: 1,
                    compare: null,
                    dataGrouping: {
                        approximation: "average",
                        enabled: !0,
                        groupPixelWidth: 2,
                        smoothed: !0,
                        units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]]
                    },
                    dataLabels: {enabled: !1, zIndex: 2},
                    id: "highcharts-navigator-series",
                    className: "highcharts-navigator-series",
                    lineColor: null,
                    marker: {enabled: !1},
                    pointRange: 0,
                    threshold: null
                },
                xAxis: {
                    overscroll: 0,
                    className: "highcharts-navigator-xaxis",
                    tickLength: 0,
                    lineWidth: 0,
                    gridLineColor: "#e6e6e6",
                    gridLineWidth: 1,
                    tickPixelInterval: 200,
                    labels: {align: "left", style: {color: "#999999"}, x: 3, y: -4},
                    crosshair: !1
                },
                yAxis: {
                    className: "highcharts-navigator-yaxis",
                    gridLineWidth: 0,
                    startOnTick: !1,
                    endOnTick: !1,
                    minPadding: .1,
                    maxPadding: .1,
                    labels: {enabled: !1},
                    crosshair: !1,
                    title: {text: null},
                    tickLength: 0,
                    tickWidth: 0
                }
            }
        }), t.Renderer.prototype.symbols["navigator-handle"] = function (t, e, i, n, r) {
            return t = r.width / 2, e = Math.round(t / 3) + .5, ["M", -t - 1, .5, "L", t, .5, "L", t, (r = r.height) + .5, "L", -t - 1, r + .5, "L", -t - 1, .5, "M", -e, 4, "L", -e, r - 3, "M", e - 1, 4, "L", e - 1, r - 3]
        }, h.prototype.toFixedRange = function (t, e, i, n) {
            var r = this.chart && this.chart.fixedRange;
            return t = v(i, this.translate(t, !0, !this.horiz)), e = v(n, this.translate(e, !0, !this.horiz)), .7 < (i = r && (e - t) / r) && 1.3 > i && (n ? t = e - r : e = t + r), a(t) && a(e) || (t = e = void 0), {
                min: t,
                max: e
            }
        }, i.prototype = {
            drawHandle: function (t, e, i, n) {
                var r = this.navigatorOptions.handles.height;
                this.handles[e][n](i ? {
                    translateX: Math.round(this.left + this.height / 2),
                    translateY: Math.round(this.top + parseInt(t, 10) + .5 - r)
                } : {
                    translateX: Math.round(this.left + parseInt(t, 10)),
                    translateY: Math.round(this.top + this.height / 2 - r / 2 - 1)
                })
            }, drawOutline: function (t, e, i, n) {
                var r = this.navigatorOptions.maskInside, o = this.outline.strokeWidth(), a = o / 2;
                o = o % 2 / 2;
                var s = this.outlineHeight, l = this.scrollbarHeight, h = this.size, c = this.left - l, u = this.top;
                i ? t = ["M", (c -= a) + s, u - l - o, "L", c + s, i = u + e + o, "L", c, i, "L", c, e = u + t + o, "L", c + s, e, "L", c + s, u + h + l].concat(r ? ["M", c + s, i - a, "L", c + s, e + a] : []) : t = ["M", c, u += a, "L", t += c + l - o, u, "L", t, u + s, "L", e += c + l - o, u + s, "L", e, u, "L", c + h + 2 * l, u].concat(r ? ["M", t - a, u, "L", e + a, u] : []), this.outline[n]({d: t})
            }, drawMasks: function (t, e, i, n) {
                var r = this.left, o = this.top, a = this.height;
                if (i) var s = [r, r, r], l = [o, o + t, o + e], h = [a, a, a],
                    c = [t, e - t, this.size - e]; else s = [r, r + t, r + e], l = [o, o, o], h = [t, e - t, this.size - e], c = [a, a, a];
                this.shades.forEach(function (t, e) {
                    t[n]({x: s[e], y: l[e], width: h[e], height: c[e]})
                })
            }, renderElements: function () {
                var t, e = this, i = e.navigatorOptions, n = i.maskInside, r = e.chart, o = r.renderer,
                    a = {cursor: r.inverted ? "ns-resize" : "ew-resize"};
                e.navigatorGroup = t = o.g("navigator").attr({
                    zIndex: 8,
                    visibility: "hidden"
                }).add(), [!n, n, !n].forEach(function (n, s) {
                    e.shades[s] = o.rect().addClass("highcharts-navigator-mask" + (1 === s ? "-inside" : "-outside")).add(t), r.styledMode || e.shades[s].attr({fill: n ? i.maskFill : "rgba(0,0,0,0)"}).css(1 === s && a)
                }), e.outline = o.path().addClass("highcharts-navigator-outline").add(t), r.styledMode || e.outline.attr({
                    "stroke-width": i.outlineWidth,
                    stroke: i.outlineColor
                }), i.handles.enabled && [0, 1].forEach(function (n) {
                    if (i.handles.inverted = r.inverted, e.handles[n] = o.symbol(i.handles.symbols[n], -i.handles.width / 2 - 1, 0, i.handles.width, i.handles.height, i.handles), e.handles[n].attr({zIndex: 7 - n}).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][n]).add(t), !r.styledMode) {
                        var s = i.handles;
                        e.handles[n].attr({
                            fill: s.backgroundColor,
                            stroke: s.borderColor,
                            "stroke-width": s.lineWidth
                        }).css(a)
                    }
                })
            }, update: function (t) {
                (this.series || []).forEach(function (t) {
                    t.baseSeries && delete t.baseSeries.navigatorSeries
                }), this.destroy(), m(!0, this.chart.options.navigator, this.options, t), this.init(this.chart)
            }, render: function (e, i, r, o) {
                var s, l, h = this.chart, c = this.scrollbarHeight, u = this.xAxis, d = u.fake ? h.xAxis[0] : u,
                    f = this.navigatorEnabled, p = this.rendered, g = h.inverted, m = h.xAxis[0].minRange,
                    y = h.xAxis[0].options.maxRange;
                if (!this.hasDragged || n(r)) {
                    if (!a(e) || !a(i)) {
                        if (!p) return;
                        r = 0, o = v(u.width, d.width)
                    }
                    this.left = v(u.left, h.plotLeft + c + (g ? h.plotWidth : 0)), this.size = l = s = v(u.len, (g ? h.plotHeight : h.plotWidth) - 2 * c), h = g ? c : s + 2 * c, r = v(r, u.toPixels(e, !0)), o = v(o, u.toPixels(i, !0)), a(r) && 1 / 0 !== Math.abs(r) || (r = 0, o = h), e = u.toValue(r, !0), i = u.toValue(o, !0);
                    var x = Math.abs(t.correctFloat(i - e));
                    x < m ? this.grabbedLeft ? r = u.toPixels(i - m, !0) : this.grabbedRight && (o = u.toPixels(e + m, !0)) : n(y) && x > y && (this.grabbedLeft ? r = u.toPixels(i - y, !0) : this.grabbedRight && (o = u.toPixels(e + y, !0))), this.zoomedMax = Math.min(Math.max(r, o, 0), l), this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(r, o), 0), l), this.range = this.zoomedMax - this.zoomedMin, l = Math.round(this.zoomedMax), r = Math.round(this.zoomedMin), f && (this.navigatorGroup.attr({visibility: "visible"}), p = p && !this.hasDragged ? "animate" : "attr", this.drawMasks(r, l, g, p), this.drawOutline(r, l, g, p), this.navigatorOptions.handles.enabled && (this.drawHandle(r, 0, g, p), this.drawHandle(l, 1, g, p))), this.scrollbar && (g ? (g = this.top - c, d = this.left - c + (f || !d.opposite ? 0 : (d.titleOffset || 0) + d.axisTitleMargin), c = s + 2 * c) : (g = this.top + (f ? this.height : -c), d = this.left - c), this.scrollbar.position(d, g, h, c), this.scrollbar.setRange(this.zoomedMin / (s || 1), this.zoomedMax / (s || 1))), this.rendered = !0
                }
            }, addMouseEvents: function () {
                var t, e, i = this, n = i.chart, r = n.container, o = [];
                i.mouseMoveHandler = t = function (t) {
                    i.onMouseMove(t)
                }, i.mouseUpHandler = e = function (t) {
                    i.onMouseUp(t)
                }, (o = i.getPartsEvents("mousedown")).push(l(r, "mousemove", t), l(r.ownerDocument, "mouseup", e)), p && (o.push(l(r, "touchmove", t), l(r.ownerDocument, "touchend", e)), o.concat(i.getPartsEvents("touchstart"))), i.eventsToUnbind = o, i.series && i.series[0] && o.push(l(i.series[0].xAxis, "foundExtremes", function () {
                    n.navigator.modifyNavigatorAxisExtremes()
                }))
            }, getPartsEvents: function (t) {
                var e = this, i = [];
                return ["shades", "handles"].forEach(function (n) {
                    e[n].forEach(function (r, o) {
                        i.push(l(r.element, t, function (t) {
                            e[n + "Mousedown"](t, o)
                        }))
                    })
                }), i
            }, shadesMousedown: function (t, e) {
                t = this.chart.pointer.normalize(t);
                var i = this.chart, r = this.xAxis, o = this.zoomedMin, a = this.left, s = this.size, l = this.range,
                    h = t.chartX;
                if (i.inverted && (h = t.chartY, a = this.top), 1 === e) this.grabbedCenter = h, this.fixedWidth = l, this.dragOffset = h - o; else {
                    if (t = h - a - l / 2, 0 === e) t = Math.max(0, t); else if (2 === e && t + l >= s) if (t = s - l, this.reversedExtremes) {
                        t -= l;
                        var c = this.getUnionExtremes().dataMin
                    } else var u = this.getUnionExtremes().dataMax;
                    t !== o && (this.fixedWidth = l, e = r.toFixedRange(t, t + l, c, u), n(e.min) && i.xAxis[0].setExtremes(Math.min(e.min, e.max), Math.max(e.min, e.max), !0, null, {trigger: "navigator"}))
                }
            }, handlesMousedown: function (t, e) {
                this.chart.pointer.normalize(t);
                var i = (t = this.chart).xAxis[0], n = this.reversedExtremes;
                0 === e ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = n ? i.min : i.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = n ? i.max : i.min), t.fixedRange = null
            }, onMouseMove: function (e) {
                var i = this, n = i.chart, r = i.left, o = i.navigatorSize, a = i.range, s = i.dragOffset,
                    l = n.inverted;
                e.touches && 0 === e.touches[0].pageX || (e = n.pointer.normalize(e), n = e.chartX, l && (r = i.top, n = e.chartY), i.grabbedLeft ? (i.hasDragged = !0, i.render(0, 0, n - r, i.otherHandlePos)) : i.grabbedRight ? (i.hasDragged = !0, i.render(0, 0, i.otherHandlePos, n - r)) : i.grabbedCenter && (i.hasDragged = !0, n < s ? n = s : n > o + s - a && (n = o + s - a), i.render(0, 0, n - s, n - s + a)), i.hasDragged && i.scrollbar && v(i.scrollbar.options.liveRedraw, t.svg && !g && !this.chart.isBoosting) && (e.DOMType = e.type, setTimeout(function () {
                    i.onMouseUp(e)
                }, 0)))
            }, onMouseUp: function (t) {
                var e = this.chart, i = this.xAxis, r = this.scrollbar, o = t.DOMEvent || t;
                if (this.hasDragged && (!r || !r.hasDragged) || "scrollbar" === t.trigger) {
                    if (r = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos) var a = this.fixedExtreme; else if (this.zoomedMax === this.otherHandlePos) var s = this.fixedExtreme;
                    this.zoomedMax === this.size && (s = this.reversedExtremes ? r.dataMin : r.dataMax), 0 === this.zoomedMin && (a = this.reversedExtremes ? r.dataMax : r.dataMin), i = i.toFixedRange(this.zoomedMin, this.zoomedMax, a, s), n(i.min) && e.xAxis[0].setExtremes(Math.min(i.min, i.max), Math.max(i.min, i.max), !0, !this.hasDragged && null, {
                        trigger: "navigator",
                        triggerOp: "navigator-drag",
                        DOMEvent: o
                    })
                }
                "mousemove" !== t.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null)
            }, removeEvents: function () {
                this.eventsToUnbind && (this.eventsToUnbind.forEach(function (t) {
                    t()
                }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents()
            }, removeBaseSeriesEvents: function () {
                var t = this.baseSeries || [];
                this.navigatorEnabled && t[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && t.forEach(function (t) {
                    y(t, "updatedData", this.updatedDataHandler)
                }, this), t[0].xAxis && y(t[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes))
            }, init: function (t) {
                var e = t.options, i = e.navigator, n = i.enabled, r = e.scrollbar, o = r.enabled;
                e = n ? i.height : 0;
                var a = o ? r.height : 0;
                this.handles = [], this.shades = [], this.chart = t, this.setBaseSeries(), this.height = e, this.scrollbarHeight = a, this.scrollbarEnabled = o, this.navigatorEnabled = n, this.navigatorOptions = i, this.scrollbarOptions = r, this.outlineHeight = e + a, this.opposite = v(i.opposite, !n && t.inverted);
                var s = this;
                n = s.baseSeries, r = t.xAxis.length, o = t.yAxis.length;
                var c = n && n[0] && n[0].xAxis || t.xAxis[0] || {options: {}};
                t.isDirtyBox = !0, s.navigatorEnabled ? (s.xAxis = new h(t, m({
                    breaks: c.options.breaks,
                    ordinal: c.options.ordinal
                }, i.xAxis, {
                    id: "navigator-x-axis",
                    yAxis: "navigator-y-axis",
                    isX: !0,
                    type: "datetime",
                    index: r,
                    isInternal: !0,
                    offset: 0,
                    keepOrdinalPadding: !0,
                    startOnTick: !1,
                    endOnTick: !1,
                    minPadding: 0,
                    maxPadding: 0,
                    zoomEnabled: !1
                }, t.inverted ? {offsets: [a, 0, -a, 0], width: e} : {
                    offsets: [0, -a, 0, a],
                    height: e
                })), s.yAxis = new h(t, m(i.yAxis, {
                    id: "navigator-y-axis",
                    alignTicks: !1,
                    offset: 0,
                    index: o,
                    isInternal: !0,
                    zoomEnabled: !1
                }, t.inverted ? {width: e} : {height: e})), n || i.series.data ? s.updateNavigatorSeries(!1) : 0 === t.series.length && (s.unbindRedraw = l(t, "beforeRedraw", function () {
                    0 < t.series.length && !s.series && (s.setBaseSeries(), s.unbindRedraw())
                })), s.reversedExtremes = t.inverted && !s.xAxis.reversed || !t.inverted && s.xAxis.reversed, s.renderElements(), s.addMouseEvents()) : s.xAxis = {
                    translate: function (e, i) {
                        var n = t.xAxis[0], r = n.getExtremes(), o = n.len - 2 * a,
                            s = M("min", n.options.min, r.dataMin);
                        return n = M("max", n.options.max, r.dataMax) - s, i ? e * n / o + s : o * (e - s) / n
                    }, toPixels: function (t) {
                        return this.translate(t)
                    }, toValue: function (t) {
                        return this.translate(t, !0)
                    }, toFixedRange: h.prototype.toFixedRange, fake: !0
                }, t.options.scrollbar.enabled && (t.scrollbar = s.scrollbar = new x(t.renderer, m(t.options.scrollbar, {
                    margin: s.navigatorEnabled ? 0 : 10,
                    vertical: t.inverted
                }), t), l(s.scrollbar, "changed", function (e) {
                    var i = s.size, n = i * this.to;
                    i *= this.from, s.hasDragged = s.scrollbar.hasDragged, s.render(0, 0, i, n), (t.options.scrollbar.liveRedraw || "mousemove" !== e.DOMType && "touchmove" !== e.DOMType) && setTimeout(function () {
                        s.onMouseUp(e)
                    })
                })), s.addBaseSeriesEvents(), s.addChartEvents()
            }, getUnionExtremes: function (t) {
                var e, i = this.chart.xAxis[0], n = this.xAxis, r = n.options, o = i.options;
                return t && null === i.dataMin || (e = {
                    dataMin: v(r && r.min, M("min", o.min, i.dataMin, n.dataMin, n.min)),
                    dataMax: v(r && r.max, M("max", o.max, i.dataMax, n.dataMax, n.max))
                }), e
            }, setBaseSeries: function (e, i) {
                var n = this.chart, r = this.baseSeries = [];
                e = e || n.options && n.options.navigator.baseSeries || (n.series.length ? t.find(n.series, function (t) {
                    return !t.options.isInternal
                }).index : 0), (n.series || []).forEach(function (t, i) {
                    t.options.isInternal || !t.options.showInNavigator && (i !== e && t.options.id !== e || !1 === t.options.showInNavigator) || r.push(t)
                }), this.xAxis && !this.xAxis.fake && this.updateNavigatorSeries(!0, i)
            }, updateNavigatorSeries: function (t, e) {
                var i, n, r, a = this, l = a.chart, h = a.baseSeries, c = a.navigatorOptions.series, d = {
                    enableMouseTracking: !1,
                    index: null,
                    linkedTo: null,
                    group: "nav",
                    padXAxis: !1,
                    xAxis: "navigator-x-axis",
                    yAxis: "navigator-y-axis",
                    showInLegend: !1,
                    stacking: !1,
                    isInternal: !0,
                    states: {inactive: {opacity: 1}}
                }, p = a.series = (a.series || []).filter(function (t) {
                    var e = t.baseSeries;
                    return !(0 > h.indexOf(e)) || (e && (y(e, "updatedData", a.updatedDataHandler), delete e.navigatorSeries), t.chart && t.destroy(), !1)
                });
                h && h.length && h.forEach(function (t) {
                    var s = t.navigatorSeries,
                        g = f({color: t.color, visible: t.visible}, o(c) ? u.navigator.series : c);
                    s && !1 === a.navigatorOptions.adaptToUpdatedData || (d.name = "Navigator " + h.length, i = t.options || {}, r = i.navigatorOptions || {}, n = m(i, d, g, r), g = r.data || g.data, a.hasNavigatorData = a.hasNavigatorData || !!g, n.data = g || i.data && i.data.slice(0), s && s.options ? s.update(n, e) : (t.navigatorSeries = l.initSeries(n), t.navigatorSeries.baseSeries = t, p.push(t.navigatorSeries)))
                }), (!c.data || h && h.length) && !o(c) || (a.hasNavigatorData = !1, (c = s(c)).forEach(function (t, e) {
                    d.name = "Navigator " + (p.length + 1), (n = m(u.navigator.series, {color: l.series[e] && !l.series[e].options.isInternal && l.series[e].color || l.options.colors[e] || l.options.colors[0]}, d, t)).data = t.data, n.data && (a.hasNavigatorData = !0, p.push(l.initSeries(n)))
                })), t && this.addBaseSeriesEvents()
            }, addBaseSeriesEvents: function () {
                var t = this, e = t.baseSeries || [];
                e[0] && e[0].xAxis && l(e[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes), e.forEach(function (e) {
                    l(e, "show", function () {
                        this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1)
                    }), l(e, "hide", function () {
                        this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1)
                    }), !1 !== this.navigatorOptions.adaptToUpdatedData && e.xAxis && l(e, "updatedData", this.updatedDataHandler), l(e, "remove", function () {
                        this.navigatorSeries && (r(t.series, this.navigatorSeries), n(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries)
                    })
                }, this)
            }, getBaseSeriesMin: function (t) {
                return this.baseSeries.reduce(function (t, e) {
                    return Math.min(t, e.xData ? e.xData[0] : t)
                }, t)
            }, modifyNavigatorAxisExtremes: function () {
                var t, e = this.xAxis;
                e.getExtremes && (!(t = this.getUnionExtremes(!0)) || t.dataMin === e.min && t.dataMax === e.max || (e.min = t.dataMin, e.max = t.dataMax))
            }, modifyBaseAxisExtremes: function () {
                var t = this.chart.navigator, e = this.getExtremes(), i = e.dataMin, n = e.dataMax;
                e = e.max - e.min;
                var r = t.stickToMin, o = t.stickToMax, s = v(this.options.overscroll, 0), l = t.series && t.series[0],
                    h = !!this.setExtremes;
                if (!this.eventArgs || "rangeSelectorButton" !== this.eventArgs.trigger) {
                    if (r) var c = i, u = i + e;
                    o && (u = n + s, r || (c = Math.max(u - e, t.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE)))), h && (r || o) && a(c) && (this.min = this.userMin = c, this.max = this.userMax = u)
                }
                t.stickToMin = t.stickToMax = null
            }, updatedDataHandler: function () {
                var t = this.chart.navigator, e = this.navigatorSeries, i = t.getBaseSeriesMin(this.xData[0]);
                t.stickToMax = t.reversedExtremes ? 0 === Math.round(t.zoomedMin) : Math.round(t.zoomedMax) >= Math.round(t.size), t.stickToMin = a(this.xAxis.min) && this.xAxis.min <= i && (!this.chart.fixedRange || !t.stickToMax), e && !t.hasNavigatorData && (e.options.pointStart = this.xData[0], e.setData(this.options.data, !1, null, !1))
            }, addChartEvents: function () {
                this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(l(this.chart, "redraw", function () {
                    var t = this.navigator,
                        e = t && (t.baseSeries && t.baseSeries[0] && t.baseSeries[0].xAxis || t.scrollbar && this.xAxis[0]);
                    e && t.render(e.min, e.max)
                }), l(this.chart, "getMargins", function () {
                    var t = this.navigator, e = t.opposite ? "plotTop" : "marginBottom";
                    this.inverted && (e = t.opposite ? "marginRight" : "plotLeft"), this[e] = (this[e] || 0) + (t.navigatorEnabled || !this.inverted ? t.outlineHeight : 0) + t.navigatorOptions.margin
                }))
            }, destroy: function () {
                this.removeEvents(), this.xAxis && (r(this.chart.xAxis, this.xAxis), r(this.chart.axes, this.xAxis)), this.yAxis && (r(this.chart.yAxis, this.yAxis), r(this.chart.axes, this.yAxis)), (this.series || []).forEach(function (t) {
                    t.destroy && t.destroy()
                }), "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" ").forEach(function (t) {
                    this[t] && this[t].destroy && this[t].destroy(), this[t] = null
                }, this), [this.handles].forEach(function (t) {
                    d(t)
                }, this)
            }
        }, t.Navigator || (t.Navigator = i, l(h, "zoom", function (t) {
            var e = this.chart.options, i = e.chart.zoomType, r = e.chart.pinchType, o = e.navigator;
            e = e.rangeSelector, this.isXAxis && (o && o.enabled || e && e.enabled) && ("y" === i ? t.zoomed = !1 : (!g && "xy" === i || g && "xy" === r) && this.options.range && (i = this.previousZoom, n(t.newMin) ? this.previousZoom = [this.min, this.max] : i && (t.newMin = i[0], t.newMax = i[1], delete this.previousZoom))), void 0 !== t.zoomed && t.preventDefault()
        }), l(e, "beforeShowResetZoom", function () {
            var t = this.options, e = t.navigator, i = t.rangeSelector;
            if ((e && e.enabled || i && i.enabled) && (!g && "x" === t.chart.zoomType || g && "x" === t.chart.pinchType)) return !1
        }), l(e, "beforeRender", function () {
            var t = this.options;
            (t.navigator.enabled || t.scrollbar.enabled) && (this.scroller = this.navigator = new i(this))
        }), l(e, "afterSetChartSize", function () {
            var t = this.legend, e = this.navigator;
            if (e) {
                var i = t && t.options, n = e.xAxis, r = e.yAxis, o = e.scrollbarHeight;
                this.inverted ? (e.left = e.opposite ? this.chartWidth - o - e.height : this.spacing[3] + o, e.top = this.plotTop + o) : (e.left = this.plotLeft + o, e.top = e.navigatorOptions.top || this.chartHeight - e.height - o - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (i && "bottom" === i.verticalAlign && i.enabled && !i.floating ? t.legendHeight + v(i.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), n && r && (this.inverted ? n.options.left = r.options.left = e.left : n.options.top = r.options.top = e.top, n.setAxisSize(), r.setAxisSize())
            }
        }), l(e, "update", function (t) {
            var e = t.options.navigator || {}, i = t.options.scrollbar || {};
            this.navigator || this.scroller || !e.enabled && !i.enabled || (m(!0, this.options.navigator, e), m(!0, this.options.scrollbar, i), delete t.options.navigator, delete t.options.scrollbar)
        }), l(e, "afterUpdate", function (t) {
            this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new i(this), v(t.redraw, !0) && this.redraw(t.animation))
        }), l(e, "afterAddSeries", function () {
            this.navigator && this.navigator.setBaseSeries(null, !1)
        }), l(b, "afterUpdate", function () {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1)
        }), e.prototype.callbacks.push(function (t) {
            var e = t.navigator;
            e && t.xAxis[0] && (t = t.xAxis[0].getExtremes(), e.render(t.min, t.max))
        }))
    }), e(i, "parts/OrdinalAxis.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined;
        e = t.addEvent;
        var n = t.Axis, r = t.Chart, o = t.css, a = t.extend, s = t.noop, l = t.pick, h = t.timeUnits;
        e(t.Series, "updatedData", function () {
            var t = this.xAxis;
            t && t.options.ordinal && delete t.ordinalIndex
        }), n.prototype.getTimeTicks = function (t, e, n, r, o, a, s) {
            var l, c, u = 0, d = {}, f = [], p = -Number.MAX_VALUE, g = this.options.tickPixelInterval,
                m = this.chart.time, v = [];
            if (!this.options.ordinal && !this.options.breaks || !o || 3 > o.length || void 0 === e) return m.getTimeTicks.apply(m, arguments);
            var y = o.length;
            for (l = 0; l < y; l++) {
                var x = l && o[l - 1] > n;
                if (o[l] < e && (u = l), l === y - 1 || o[l + 1] - o[l] > 5 * a || x) {
                    if (o[l] > p) {
                        for (c = m.getTimeTicks(t, o[u], o[l], r); c.length && c[0] <= p;) c.shift();
                        c.length && (p = c[c.length - 1]), v.push(f.length), f = f.concat(c)
                    }
                    u = l + 1
                }
                if (x) break
            }
            if (c = c.info, s && c.unitRange <= h.hour) {
                for (l = f.length - 1, u = 1; u < l; u++) if (m.dateFormat("%d", f[u]) !== m.dateFormat("%d", f[u - 1])) {
                    d[f[u]] = "day";
                    var b = !0
                }
                b && (d[f[0]] = "day"), c.higherRanks = d
            }
            if (c.segmentStarts = v, f.info = c, s && i(g)) {
                var M;
                for (u = v = f.length, b = [], m = []; u--;) l = this.translate(f[u]), M && (m[u] = M - l), b[u] = M = l;
                for (m.sort(), (m = m[Math.floor(m.length / 2)]) < .6 * g && (m = null), u = f[v - 1] > n ? v - 1 : v, M = void 0; u--;) l = b[u], v = Math.abs(M - l), M && v < .8 * g && (null === m || v < .8 * m) ? (d[f[u]] && !d[f[u + 1]] ? (v = u + 1, M = l) : v = u, f.splice(v, 1)) : M = l
            }
            return f
        }, a(n.prototype, {
            beforeSetTickPositions: function () {
                var t, e, i = [], n = !1, r = this.getExtremes(), o = r.min, a = r.max,
                    s = this.isXAxis && !!this.options.breaks;
                r = this.options.ordinal;
                var h, c = Number.MAX_VALUE, u = this.chart.options.chart.ignoreHiddenSeries;
                if (r || s) {
                    this.series.forEach(function (e, n) {
                        if (t = [], !(u && !1 === e.visible || !1 === e.takeOrdinalPosition && !s) && (i = i.concat(e.processedXData), d = i.length, i.sort(function (t, e) {
                            return t - e
                        }), c = Math.min(c, l(e.closestPointRange, c)), d)) {
                            for (n = 0; n < d - 1;) i[n] !== i[n + 1] && t.push(i[n + 1]), n++;
                            t[0] !== i[0] && t.unshift(i[0]), i = t
                        }
                        e.isSeriesBoosting && (h = !0)
                    }), h && (i.length = 0);
                    var d = i.length;
                    if (2 < d) {
                        var f = i[1] - i[0];
                        for (e = d - 1; e-- && !n;) i[e + 1] - i[e] !== f && (n = !0);
                        !this.options.keepOrdinalPadding && (i[0] - o > f || a - i[i.length - 1] > f) && (n = !0)
                    } else this.options.overscroll && (2 === d ? c = i[1] - i[0] : 1 === d ? (c = this.options.overscroll, i = [i[0], i[0] + c]) : c = this.overscrollPointsRange);
                    n ? (this.options.overscroll && (this.overscrollPointsRange = c, i = i.concat(this.getOverscrollPositions())), this.ordinalPositions = i, f = this.ordinal2lin(Math.max(o, i[0]), !0), e = Math.max(this.ordinal2lin(Math.min(a, i[i.length - 1]), !0), 1), this.ordinalSlope = a = (a - o) / (e - f), this.ordinalOffset = o - f * a) : (this.overscrollPointsRange = l(this.closestPointRange, this.overscrollPointsRange), this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0)
                }
                this.isOrdinal = r && n, this.groupIntervalFactor = null
            }, val2lin: function (t, e) {
                var i = this.ordinalPositions;
                if (i) {
                    var n, r = i.length;
                    for (n = r; n--;) if (i[n] === t) {
                        var o = n;
                        break
                    }
                    for (n = r - 1; n--;) if (t > i[n] || 0 === n) {
                        o = n + (t = (t - i[n]) / (i[n + 1] - i[n]));
                        break
                    }
                    e = e ? o : this.ordinalSlope * (o || 0) + this.ordinalOffset
                } else e = t;
                return e
            }, lin2val: function (t, e) {
                var i = this.ordinalPositions;
                if (i) {
                    var n = this.ordinalSlope, r = this.ordinalOffset, o = i.length - 1;
                    if (e) if (0 > t) t = i[0]; else if (t > o) t = i[o]; else var a = t - (o = Math.floor(t)); else for (; o--;) if (t >= (e = n * o + r)) {
                        a = (t - e) / ((n = n * (o + 1) + r) - e);
                        break
                    }
                    return void 0 !== a && void 0 !== i[o] ? i[o] + (a ? a * (i[o + 1] - i[o]) : 0) : t
                }
                return t
            }, getExtendedPositions: function () {
                var t, e = this, i = e.chart, r = e.series[0].currentDataGrouping, o = e.ordinalIndex,
                    a = r ? r.count + r.unitName : "raw", l = e.options.overscroll, h = e.getExtremes();
                if (o || (o = e.ordinalIndex = {}), !o[a]) {
                    var c = {
                        series: [], chart: i, getExtremes: function () {
                            return {min: h.dataMin, max: h.dataMax + l}
                        }, options: {ordinal: !0}, val2lin: n.prototype.val2lin, ordinal2lin: n.prototype.ordinal2lin
                    };
                    e.series.forEach(function (n) {
                        (t = {
                            xAxis: c,
                            xData: n.xData.slice(),
                            chart: i,
                            destroyGroupedData: s
                        }).xData = t.xData.concat(e.getOverscrollPositions()), t.options = {
                            dataGrouping: r ? {
                                enabled: !0,
                                forced: !0,
                                approximation: "open",
                                units: [[r.unitName, [r.count]]]
                            } : {enabled: !1}
                        }, n.processData.apply(t), c.series.push(t)
                    }), e.beforeSetTickPositions.apply(c), o[a] = c.ordinalPositions
                }
                return o[a]
            }, getOverscrollPositions: function () {
                var t = this.options.overscroll, e = this.overscrollPointsRange, n = [], r = this.dataMax;
                if (i(e)) for (n.push(r); r <= this.dataMax + t;) r += e, n.push(r);
                return n
            }, getGroupIntervalFactor: function (t, e, i) {
                var n = (i = i.processedXData).length, r = [], o = this.groupIntervalFactor;
                if (!o) {
                    for (o = 0; o < n - 1; o++) r[o] = i[o + 1] - i[o];
                    r.sort(function (t, e) {
                        return t - e
                    }), r = r[Math.floor(n / 2)], t = Math.max(t, i[0]), e = Math.min(e, i[n - 1]), this.groupIntervalFactor = o = n * r / (e - t)
                }
                return o
            }, postProcessTickInterval: function (t) {
                var e = this.ordinalSlope;
                return e ? this.options.breaks ? this.closestPointRange || t : t / (e / this.closestPointRange) : t
            }
        }), n.prototype.ordinal2lin = n.prototype.val2lin, e(r, "pan", function (t) {
            var e = this.xAxis[0], i = e.options.overscroll, n = t.originalEvent.chartX, r = !1;
            if (e.options.ordinal && e.series.length) {
                var a = this.mouseDownX, s = e.getExtremes(), l = s.dataMax, h = s.min, c = s.max, u = this.hoverPoints,
                    d = e.closestPointRange || e.overscrollPointsRange;
                a = (a - n) / (e.translationSlope * (e.ordinalSlope || d));
                var f = {ordinalPositions: e.getExtendedPositions()};
                d = e.lin2val;
                var p = e.val2lin;
                if (f.ordinalPositions) {
                    if (1 < Math.abs(a)) {
                        if (u && u.forEach(function (t) {
                            t.setState()
                        }), 0 > a) {
                            u = f;
                            var g = e.ordinalPositions ? e : f
                        } else u = e.ordinalPositions ? e : f, g = f;
                        l > (f = g.ordinalPositions)[f.length - 1] && f.push(l), this.fixedRange = c - h, (a = e.toFixedRange(null, null, d.apply(u, [p.apply(u, [h, !0]) + a, !0]), d.apply(g, [p.apply(g, [c, !0]) + a, !0]))).min >= Math.min(s.dataMin, h) && a.max <= Math.max(l, c) + i && e.setExtremes(a.min, a.max, !0, !1, {trigger: "pan"}), this.mouseDownX = n, o(this.container, {cursor: "move"})
                    }
                } else r = !0
            } else r = !0;
            r ? i && (e.max = e.dataMax + i) : t.preventDefault()
        }), e(n, "foundExtremes", function () {
            this.isXAxis && i(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && "navigator" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && i(this.userMin) && (this.min += this.options.overscroll))
        }), e(n, "afterSetScale", function () {
            this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData)
        })
    }), e(i, "modules/broken-axis.src.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.isArray;
        e = t.addEvent;
        var n = t.pick, r = t.extend, o = t.find, a = t.fireEvent, s = t.Axis, l = t.Series, h = function (t, e) {
            return o(e, function (e) {
                return e.from < t && t < e.to
            })
        };
        r(s.prototype, {
            isInBreak: function (t, e) {
                var i = t.repeat || 1 / 0, n = t.from, r = t.to - t.from;
                return e = e >= n ? (e - n) % i : i - (n - e) % i, t.inclusive ? e <= r : e < r && 0 !== e
            }, isInAnyBreak: function (t, e) {
                var i, r = this.options.breaks, o = r && r.length;
                if (o) {
                    for (; o--;) if (this.isInBreak(r[o], t)) {
                        var a = !0;
                        i || (i = n(r[o].showPoints, !this.isXAxis))
                    }
                    var s = a && e ? a && !i : a
                }
                return s
            }
        }), e(s, "afterInit", function () {
            "function" == typeof this.setBreaks && this.setBreaks(this.options.breaks, !1)
        }), e(s, "afterSetTickPositions", function () {
            if (this.isBroken) {
                var t, e = this.tickPositions, i = this.tickPositions.info, n = [];
                for (t = 0; t < e.length; t++) this.isInAnyBreak(e[t]) || n.push(e[t]);
                this.tickPositions = n, this.tickPositions.info = i
            }
        }), e(s, "afterSetOptions", function () {
            this.isBroken && (this.options.ordinal = !1)
        }), s.prototype.setBreaks = function (t, e) {
            function r(t) {
                var e, i = t;
                for (e = 0; e < o.breakArray.length; e++) {
                    var n = o.breakArray[e];
                    if (n.to <= t) i -= n.len; else {
                        if (n.from >= t) break;
                        if (o.isInBreak(n, t)) {
                            i -= t - n.from;
                            break
                        }
                    }
                }
                return i
            }

            var o = this, l = i(t) && !!t.length;
            o.isDirty = o.isBroken !== l, o.isBroken = l, o.options.breaks = o.userOptions.breaks = t, o.forceRedraw = !0, l || o.val2lin !== r || (delete o.val2lin, delete o.lin2val), l && (o.userOptions.ordinal = !1, o.val2lin = r, o.lin2val = function (t) {
                var e;
                for (e = 0; e < o.breakArray.length; e++) {
                    var i = o.breakArray[e];
                    if (i.from >= t) break;
                    i.to < t ? t += i.len : o.isInBreak(i, t) && (t += i.len)
                }
                return t
            }, o.setExtremes = function (t, e, i, n, r) {
                if (this.isBroken) {
                    for (var o, a = this.options.breaks; o = h(t, a);) t = o.to;
                    for (; o = h(e, a);) e = o.from;
                    e < t && (e = t)
                }
                s.prototype.setExtremes.call(this, t, e, i, n, r)
            }, o.setAxisTranslation = function (t) {
                if (s.prototype.setAxisTranslation.call(this, t), this.unitLength = null, this.isBroken) {
                    t = o.options.breaks;
                    var e, i, r = [], l = [], h = 0, c = o.userMin || o.min, u = o.userMax || o.max,
                        d = n(o.pointRangePadding, 0);
                    t.forEach(function (t) {
                        e = t.repeat || 1 / 0, o.isInBreak(t, c) && (c += t.to % e - c % e), o.isInBreak(t, u) && (u -= u % e - t.from % e)
                    }), t.forEach(function (t) {
                        for (p = t.from, e = t.repeat || 1 / 0; p - e > c;) p -= e;
                        for (; p < c;) p += e;
                        for (i = p; i < u; i += e) r.push({value: i, move: "in"}), r.push({
                            value: i + (t.to - t.from),
                            move: "out",
                            size: t.breakSize
                        })
                    }), r.sort(function (t, e) {
                        return t.value === e.value ? ("in" === t.move ? 0 : 1) - ("in" === e.move ? 0 : 1) : t.value - e.value
                    });
                    var f = 0, p = c;
                    r.forEach(function (t) {
                        1 === (f += "in" === t.move ? 1 : -1) && "in" === t.move && (p = t.value), 0 === f && (l.push({
                            from: p,
                            to: t.value,
                            len: t.value - p - (t.size || 0)
                        }), h += t.value - p - (t.size || 0))
                    }), o.breakArray = l, o.unitLength = u - c - h + d, a(o, "afterBreaks"), o.staticScale ? o.transA = o.staticScale : o.unitLength && (o.transA *= (u - o.min + d) / o.unitLength), d && (o.minPixelPadding = o.transA * o.minPointOffset), o.min = c, o.max = u
                }
            }), n(e, !0) && this.chart.redraw()
        }, e(l, "afterGeneratePoints", function () {
            var t = this.xAxis, e = this.yAxis, i = this.points, n = i.length, r = this.options.connectNulls;
            if (t && e && (t.options.breaks || e.options.breaks)) for (; n--;) {
                var o = i[n];
                null === o.y && !1 === r || !t.isInAnyBreak(o.x, !0) && !e.isInAnyBreak(o.y, !0) || (i.splice(n, 1), this.data[n] && this.data[n].destroyElements())
            }
        }), e(l, "afterRender", function () {
            this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, n(this.pointArrayMap, ["y"]))
        }), t.Series.prototype.drawBreaks = function (t, e) {
            var i, r, o, s, l = this, h = l.points;
            t && e.forEach(function (e) {
                i = t.breakArray || [], r = t.isXAxis ? t.min : n(l.options.threshold, t.min), h.forEach(function (l) {
                    s = n(l["stack" + e.toUpperCase()], l[e]), i.forEach(function (e) {
                        o = !1, r < e.from && s > e.to || r > e.from && s < e.from ? o = "pointBreak" : (r < e.from && s > e.from && s < e.to || r > e.from && s > e.to && s < e.from) && (o = "pointInBreak"), o && a(t, o, {
                            point: l,
                            brk: e
                        })
                    })
                })
            })
        }, t.Series.prototype.gappedPath = function () {
            var e = this.currentDataGrouping, i = e && e.gapSize;
            e = this.options.gapSize;
            var n = this.points.slice(), r = n.length - 1, o = this.yAxis;
            if (e && 0 < r) for ("value" !== this.options.gapUnit && (e *= this.basePointRange), i && i > e && i >= this.basePointRange && (e = i); r--;) n[r + 1].x - n[r].x > e && (i = (n[r].x + n[r + 1].x) / 2, n.splice(r + 1, 0, {
                isNull: !0,
                x: i
            }), this.options.stacking && ((i = o.stacks[this.stackKey][i] = new t.StackItem(o, o.options.stackLabels, !1, i, this.stack)).total = 0));
            return this.getGraphPath(n)
        }
    }), e(i, "masters/modules/broken-axis.src.js", [], function () {
    }), e(i, "parts/DataGrouping.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber;
        e = t.addEvent;
        var r = t.arrayMax, o = t.arrayMin, a = t.Axis, s = t.correctFloat, l = t.defaultPlotOptions, h = t.extend,
            c = t.format, u = t.merge, d = t.pick, f = t.Point, p = t.Series, g = t.Tooltip, m = t.approximations = {
                sum: function (t) {
                    var e = t.length;
                    if (!e && t.hasNulls) var i = null; else if (e) for (i = 0; e--;) i += t[e];
                    return i
                }, average: function (t) {
                    var e = t.length;
                    return t = m.sum(t), n(t) && e && (t = s(t / e)), t
                }, averages: function () {
                    var t = [];
                    return [].forEach.call(arguments, function (e) {
                        t.push(m.average(e))
                    }), void 0 === t[0] ? void 0 : t
                }, open: function (t) {
                    return t.length ? t[0] : t.hasNulls ? null : void 0
                }, high: function (t) {
                    return t.length ? r(t) : t.hasNulls ? null : void 0
                }, low: function (t) {
                    return t.length ? o(t) : t.hasNulls ? null : void 0
                }, close: function (t) {
                    return t.length ? t[t.length - 1] : t.hasNulls ? null : void 0
                }, ohlc: function (t, e, i, r) {
                    if (t = m.open(t), e = m.high(e), i = m.low(i), r = m.close(r), n(t) || n(e) || n(i) || n(r)) return [t, e, i, r]
                }, range: function (t, e) {
                    return t = m.low(t), e = m.high(e), n(t) || n(e) ? [t, e] : null === t && null === e ? null : void 0
                }
            }, v = function (t, e, r, o) {
                var a, s = this, l = s.data, h = s.options && s.options.data, c = [], d = [], f = [], p = t.length, g = !!e,
                    v = [], y = s.pointArrayMap, x = y && y.length, b = ["x"].concat(y || ["y"]), M = 0, A = 0;
                o = "function" == typeof o ? o : m[o] ? m[o] : m[s.getDGApproximation && s.getDGApproximation() || "average"], x ? y.forEach(function () {
                    v.push([])
                }) : v.push([]);
                var w = x || 1;
                for (a = 0; a <= p && !(t[a] >= r[0]); a++) ;
                for (; a <= p; a++) {
                    for (; void 0 !== r[M + 1] && t[a] >= r[M + 1] || a === p;) {
                        var k = r[M];
                        s.dataGroupInfo = {start: s.cropStart + A, length: v[0].length};
                        var S = o.apply(s, v);
                        for (s.pointClass && !i(s.dataGroupInfo.options) && (s.dataGroupInfo.options = u(s.pointClass.prototype.optionsToObject.call({series: s}, s.options.data[s.cropStart + A])), b.forEach(function (t) {
                            delete s.dataGroupInfo.options[t]
                        })), void 0 !== S && (c.push(k), d.push(S), f.push(s.dataGroupInfo)), A = a, k = 0; k < w; k++) v[k].length = 0, v[k].hasNulls = !1;
                        if (M += 1, a === p) break
                    }
                    if (a === p) break;
                    if (y) for (k = s.cropStart + a, S = l && l[k] || s.pointClass.prototype.applyOptions.apply({series: s}, [h[k]]), k = 0; k < x; k++) {
                        var T = S[y[k]];
                        n(T) ? v[k].push(T) : null === T && (v[k].hasNulls = !0)
                    } else k = g ? e[a] : null, n(k) ? v[0].push(k) : null === k && (v[0].hasNulls = !0)
                }
                return {groupedXData: c, groupedYData: d, groupMap: f}
            }, y = {approximations: m, groupData: v}, x = p.prototype, b = x.processData, M = x.generatePoints, A = {
                groupPixelWidth: 2,
                dateTimeLabelFormats: {
                    millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"],
                    second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"],
                    minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
                    hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
                    day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
                    week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
                    month: ["%B %Y", "%B", "-%B %Y"],
                    year: ["%Y", "%Y", "-%Y"]
                }
            }, w = {
                line: {},
                spline: {},
                area: {},
                areaspline: {},
                column: {groupPixelWidth: 10},
                columnrange: {groupPixelWidth: 10},
                candlestick: {groupPixelWidth: 10},
                ohlc: {groupPixelWidth: 5}
            },
            k = t.defaultDataGroupingUnits = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]];
        return x.getDGApproximation = function () {
            return t.seriesTypes.arearange && this instanceof t.seriesTypes.arearange ? "range" : t.seriesTypes.ohlc && this instanceof t.seriesTypes.ohlc ? "ohlc" : t.seriesTypes.column && this instanceof t.seriesTypes.column ? "sum" : "average"
        }, x.groupData = v, x.processData = function () {
            var t, e = this.chart, n = this.options.dataGrouping,
                r = !1 !== this.allowDG && n && d(n.enabled, e.options.isStock),
                o = this.visible || !e.options.chart.ignoreHiddenSeries, a = this.currentDataGrouping, s = !1;
            if (this.forceCrop = r, this.groupPixelWidth = null, this.hasProcessed = !0, r && !this.requireSorting && (this.requireSorting = s = !0), r = !1 === b.apply(this, arguments) || !r, s && (this.requireSorting = !1), !r) {
                this.destroyGroupedData(), r = n.groupAll ? this.xData : this.processedXData;
                var l = n.groupAll ? this.yData : this.processedYData, h = e.plotSizeX,
                    c = (e = this.xAxis).options.ordinal,
                    u = this.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth();
                if (u) {
                    this.isDirty = t = !0, this.points = null;
                    var f = (s = e.getExtremes()).min;
                    u = u * ((s = s.max) - f) / h * (c = c && e.getGroupIntervalFactor(f, s, this) || 1), h = e.getTimeTicks(e.normalizeTimeTickInterval(u, n.units || k), Math.min(f, r[0]), Math.max(s, r[r.length - 1]), e.options.startOfWeek, r, this.closestPointRange), r = (l = x.groupData.apply(this, [r, l, h, n.approximation])).groupedXData, c = l.groupedYData;
                    var p = 0;
                    if (n.smoothed && r.length) {
                        var g = r.length - 1;
                        for (r[g] = Math.min(r[g], s); g-- && 0 < g;) r[g] += u / 2;
                        r[0] = Math.max(r[0], f)
                    }
                    for (g = 1; g < h.length; g++) h.info.segmentStarts && -1 !== h.info.segmentStarts.indexOf(g) || (p = Math.max(h[g] - h[g - 1], p));
                    (f = h.info).gapSize = p, this.closestPointRange = h.info.totalRange, this.groupMap = l.groupMap, i(r[0]) && r[0] < e.min && o && ((!i(e.options.min) && e.min <= e.dataMin || e.min === e.dataMin) && (e.min = r[0]), e.dataMin = r[0]), n.groupAll && (r = (n = this.cropData(r, c, e.min, e.max, 1)).xData, c = n.yData), this.processedXData = r, this.processedYData = c
                } else this.groupMap = null;
                this.hasGroupedData = t, this.currentDataGrouping = f, this.preventGraphAnimation = (a && a.totalRange) !== (f && f.totalRange)
            }
        }, x.destroyGroupedData = function () {
            var t = this.groupedData;
            (t || []).forEach(function (e, i) {
                e && (t[i] = e.destroy ? e.destroy() : null)
            }), this.groupedData = null
        }, x.generatePoints = function () {
            M.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null
        }, e(f, "update", function () {
            if (this.dataGroup) return t.error(24, !1, this.series.chart), !1
        }), e(g, "headerFormatter", function (t) {
            var e = this.chart.time, i = t.labelConfig, r = i.series, o = r.tooltipOptions, a = r.options.dataGrouping,
                s = o.xDateFormat, l = r.xAxis, u = o[(t.isFooter ? "footer" : "header") + "Format"];
            if (l && "datetime" === l.options.type && a && n(i.key)) {
                var d = r.currentDataGrouping;
                if (a = a.dateTimeLabelFormats || A.dateTimeLabelFormats, d) if (o = a[d.unitName], 1 === d.count) s = o[0]; else {
                    s = o[1];
                    var f = o[2]
                } else !s && a && (s = this.getXDateFormat(i, o, l));
                s = e.dateFormat(s, i.key), f && (s += e.dateFormat(f, i.key + d.totalRange - 1)), r.chart.styledMode && (u = this.styledModeFormat(u)), t.text = c(u, {
                    point: h(i.point, {key: s}),
                    series: r
                }, e), t.preventDefault()
            }
        }), e(p, "destroy", x.destroyGroupedData), e(p, "afterSetOptions", function (t) {
            t = t.options;
            var e = this.type, i = this.chart.options.plotOptions, n = l[e].dataGrouping,
                r = this.useCommonDataGrouping && A;
            (w[e] || r) && (n || (n = u(A, w[e])), t.dataGrouping = u(r, n, i.series && i.series.dataGrouping, i[e].dataGrouping, this.userOptions.dataGrouping))
        }), e(a, "afterSetScale", function () {
            this.series.forEach(function (t) {
                t.hasProcessed = !1
            })
        }), a.prototype.getGroupPixelWidth = function () {
            var t, e, i = this.series, n = i.length, r = 0, o = !1;
            for (t = n; t--;) (e = i[t].options.dataGrouping) && (r = Math.max(r, d(e.groupPixelWidth, A.groupPixelWidth)));
            for (t = n; t--;) (e = i[t].options.dataGrouping) && i[t].hasProcessed && (n = (i[t].processedXData || i[t].data).length, i[t].groupPixelWidth || n > this.chart.plotSizeX / r || n && e.forced) && (o = !0);
            return o ? r : 0
        }, a.prototype.setDataGrouping = function (t, e) {
            var i;
            if (e = d(e, !0), t || (t = {
                forced: !1,
                units: null
            }), this instanceof a) for (i = this.series.length; i--;) this.series[i].update({dataGrouping: t}, !1); else this.chart.options.series.forEach(function (e) {
                e.dataGrouping = t
            }, !1);
            this.ordinalSlope = null, e && this.chart.redraw()
        }, t.dataGrouping = y, y
    }), e(i, "parts/OHLCSeries.js", [i["parts/Globals.js"]], function (t) {
        var e = t.Point, i = t.seriesType, n = t.seriesTypes;
        i("ohlc", "column", {
            lineWidth: 1,
            tooltip: {pointFormat: '<span style="color:{point.color}">\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'},
            threshold: null,
            states: {hover: {lineWidth: 3}},
            stickyTracking: !0
        }, {
            directTouch: !1,
            pointArrayMap: ["open", "high", "low", "close"],
            toYData: function (t) {
                return [t.open, t.high, t.low, t.close]
            },
            pointValKey: "close",
            pointAttrToOptions: {stroke: "color", "stroke-width": "lineWidth"},
            init: function () {
                n.column.prototype.init.apply(this, arguments), this.options.stacking = !1
            },
            pointAttribs: function (t, e) {
                e = n.column.prototype.pointAttribs.call(this, t, e);
                var i = this.options;
                return delete e.fill, !t.options.color && i.upColor && t.open < t.close && (e.stroke = i.upColor), e
            },
            translate: function () {
                var t = this, e = t.yAxis, i = !!t.modifyValue,
                    r = ["plotOpen", "plotHigh", "plotLow", "plotClose", "yBottom"];
                n.column.prototype.translate.apply(t), t.points.forEach(function (n) {
                    [n.open, n.high, n.low, n.close, n.low].forEach(function (o, a) {
                        null !== o && (i && (o = t.modifyValue(o)), n[r[a]] = e.toPixels(o, !0))
                    }), n.tooltipPos[1] = n.plotHigh + e.pos - t.chart.plotTop
                })
            },
            drawPoints: function () {
                var t = this, e = t.chart;
                t.points.forEach(function (i) {
                    var n = i.graphic, r = !n;
                    if (void 0 !== i.plotY) {
                        n || (i.graphic = n = e.renderer.path().add(t.group)), e.styledMode || n.attr(t.pointAttribs(i, i.selected && "select"));
                        var o = n.strokeWidth() % 2 / 2, a = Math.round(i.plotX) - o,
                            s = Math.round(i.shapeArgs.width / 2),
                            l = ["M", a, Math.round(i.yBottom), "L", a, Math.round(i.plotHigh)];
                        if (null !== i.open) {
                            var h = Math.round(i.plotOpen) + o;
                            l.push("M", a, h, "L", a - s, h)
                        }
                        null !== i.close && (h = Math.round(i.plotClose) + o, l.push("M", a, h, "L", a + s, h)), n[r ? "attr" : "animate"]({d: l}).addClass(i.getClassName(), !0)
                    }
                })
            },
            animate: null
        }, {
            getClassName: function () {
                return e.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down")
            }
        })
    }), e(i, "parts/CandlestickSeries.js", [i["parts/Globals.js"]], function (t) {
        var e = t.defaultPlotOptions, i = t.merge, n = t.seriesType, r = t.seriesTypes;
        n("candlestick", "ohlc", i(e.column, {
            states: {hover: {lineWidth: 2}},
            tooltip: e.ohlc.tooltip,
            threshold: null,
            lineColor: "#000000",
            lineWidth: 1,
            upColor: "#ffffff",
            stickyTracking: !0
        }), {
            pointAttribs: function (t, e) {
                var i = r.column.prototype.pointAttribs.call(this, t, e), n = this.options, o = t.open < t.close,
                    a = n.lineColor || this.color;
                return i["stroke-width"] = n.lineWidth, i.fill = t.options.color || o && n.upColor || this.color, i.stroke = t.options.lineColor || o && n.upLineColor || a, e && (t = n.states[e], i.fill = t.color || i.fill, i.stroke = t.lineColor || i.stroke, i["stroke-width"] = t.lineWidth || i["stroke-width"]), i
            }, drawPoints: function () {
                var t = this, e = t.chart, i = t.yAxis.reversed;
                t.points.forEach(function (n) {
                    var r = n.graphic, o = !r;
                    if (void 0 !== n.plotY) {
                        r || (n.graphic = r = e.renderer.path().add(t.group)), t.chart.styledMode || r.attr(t.pointAttribs(n, n.selected && "select")).shadow(t.options.shadow);
                        var a = r.strokeWidth() % 2 / 2, s = Math.round(n.plotX) - a, l = n.plotOpen, h = n.plotClose,
                            c = Math.min(l, h);
                        l = Math.max(l, h);
                        var u = Math.round(n.shapeArgs.width / 2);
                        h = i ? l !== n.yBottom : Math.round(c) !== Math.round(n.plotHigh);
                        var d = i ? Math.round(c) !== Math.round(n.plotHigh) : l !== n.yBottom;
                        c = Math.round(c) + a, l = Math.round(l) + a, (a = []).push("M", s - u, l, "L", s - u, c, "L", s + u, c, "L", s + u, l, "Z", "M", s, c, "L", s, h ? Math.round(i ? n.yBottom : n.plotHigh) : c, "M", s, l, "L", s, d ? Math.round(i ? n.plotHigh : n.yBottom) : l), r[o ? "attr" : "animate"]({d: a}).addClass(n.getClassName(), !0)
                    }
                })
            }
        })
    }), e(i, "mixins/on-series.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = t.seriesTypes, r = t.stableSort;
        return {
            getPlotBox: function () {
                return t.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this)
            }, translate: function () {
                n.column.prototype.translate.apply(this);
                var t, e = this, o = e.options, a = e.chart, s = e.points, l = s.length - 1, h = o.onSeries;
                h = h && a.get(h), o = o.onKey || "y";
                var c, u = h && h.options.step, d = h && h.points, f = d && d.length, p = a.inverted, g = e.xAxis,
                    m = e.yAxis, v = 0;
                if (h && h.visible && f) {
                    v = (h.pointXOffset || 0) + (h.barW || 0) / 2, a = h.currentDataGrouping;
                    var y = d[f - 1].x + (a ? a.totalRange : 0);
                    for (r(s, function (t, e) {
                        return t.x - e.x
                    }), o = "plot" + o[0].toUpperCase() + o.substr(1); f-- && s[l];) {
                        var x = d[f];
                        if ((a = s[l]).y = x.y, x.x <= a.x && void 0 !== x[o]) {
                            if (a.x <= y && (a.plotY = x[o], x.x < a.x && !u && (c = d[f + 1]) && void 0 !== c[o])) {
                                var b = (a.x - x.x) / (c.x - x.x);
                                a.plotY += b * (c[o] - x[o]), a.y += b * (c.y - x.y)
                            }
                            if (f++, 0 > --l) break
                        }
                    }
                }
                s.forEach(function (n, r) {
                    if (n.plotX += v, (void 0 === n.plotY || p) && (0 <= n.plotX && n.plotX <= g.len ? p ? (n.plotY = g.translate(n.x, 0, 1, 0, 1), n.plotX = i(n.y) ? m.translate(n.y, 0, 0, 0, 1) : 0) : n.plotY = (g.opposite ? 0 : e.yAxis.len) + g.offset : n.shapeArgs = {}), (t = s[r - 1]) && t.plotX === n.plotX) {
                        void 0 === t.stackIndex && (t.stackIndex = 0);
                        var o = t.stackIndex + 1
                    }
                    n.stackIndex = o
                }), this.onSeries = h
            }
        }
    }), e(i, "parts/FlagsSeries.js", [i["parts/Globals.js"], i["parts/Utilities.js"], i["mixins/on-series.js"]], function (t, e, i) {
        function n(t) {
            p[t + "pin"] = function (e, i, n, r, o) {
                var a = o && o.anchorX;
                o = o && o.anchorY, "circle" === t && r > n && (e -= Math.round((r - n) / 2), n = r);
                var s = p[t](e, i, n, r);
                return a && o && (s.push("M", "circle" === t ? e + n / 2 : s[1] + s[4] / 2, i > o ? i : i + r, "L", a, o), s = s.concat(p.circle(a - 1, o - 1, 2, 2))), s
            }
        }

        var r = e.defined, o = e.isNumber, a = e.objectEach, s = t.addEvent, l = t.merge;
        e = t.noop;
        var h = t.Renderer, c = t.Series, u = t.seriesType, d = t.TrackerMixin, f = t.VMLRenderer,
            p = t.SVGRenderer.prototype.symbols;
        u("flags", "column", {
            pointRange: 0,
            allowOverlapX: !1,
            shape: "flag",
            stackDistance: 12,
            textAlign: "center",
            tooltip: {pointFormat: "{point.text}<br/>"},
            threshold: null,
            y: -30,
            fillColor: "#ffffff",
            lineWidth: 1,
            states: {hover: {lineColor: "#000000", fillColor: "#ccd6eb"}},
            style: {fontSize: "11px", fontWeight: "bold"}
        }, {
            sorted: !1,
            noSharedTooltip: !0,
            allowDG: !1,
            takeOrdinalPosition: !1,
            trackerGroups: ["markerGroup"],
            forceCrop: !0,
            init: c.prototype.init,
            pointAttribs: function (t, e) {
                var i = this.options, n = t && t.color || this.color, r = i.lineColor, o = t && t.lineWidth;
                return t = t && t.fillColor || i.fillColor, e && (t = i.states[e].fillColor, r = i.states[e].lineColor, o = i.states[e].lineWidth), {
                    fill: t || n,
                    stroke: r || n,
                    "stroke-width": o || i.lineWidth || 0
                }
            },
            translate: i.translate,
            getPlotBox: i.getPlotBox,
            drawPoints: function () {
                var e, i = this.points, n = this.chart, o = n.renderer, s = n.inverted, h = this.options, c = h.y,
                    u = this.yAxis, d = {}, f = [];
                for (e = i.length; e--;) {
                    var p = i[e], g = (s ? p.plotY : p.plotX) > this.xAxis.len, m = p.plotX, v = p.stackIndex,
                        y = p.options.shape || h.shape, x = p.plotY;
                    void 0 !== x && (x = p.plotY + c - (void 0 !== v && v * h.stackDistance)), p.anchorX = v ? void 0 : p.plotX;
                    var b = v ? void 0 : p.plotY, M = "flag" !== y;
                    v = p.graphic, void 0 !== x && 0 <= m && !g ? (v || (v = p.graphic = o.label("", null, null, y, null, null, h.useHTML), n.styledMode || v.attr(this.pointAttribs(p)).css(l(h.style, p.style)), v.attr({
                        align: M ? "center" : "left",
                        width: h.width,
                        height: h.height,
                        "text-align": h.textAlign
                    }).addClass("highcharts-point").add(this.markerGroup), p.graphic.div && (p.graphic.div.point = p), n.styledMode || v.shadow(h.shadow), v.isNew = !0), 0 < m && (m -= v.strokeWidth() % 2), y = {
                        y: x,
                        anchorY: b
                    }, h.allowOverlapX && (y.x = m, y.anchorX = p.anchorX), v.attr({text: p.options.title || h.title || "A"})[v.isNew ? "attr" : "animate"](y), h.allowOverlapX || (d[p.plotX] ? d[p.plotX].size = Math.max(d[p.plotX].size, v.width) : d[p.plotX] = {
                        align: M ? .5 : 0,
                        size: v.width,
                        target: m,
                        anchorX: m
                    }), p.tooltipPos = [m, x + u.pos - n.plotTop]) : v && (p.graphic = v.destroy())
                }
                h.allowOverlapX || (a(d, function (t) {
                    t.plotX = t.anchorX, f.push(t)
                }), t.distribute(f, s ? u.len : this.xAxis.len, 100), i.forEach(function (t) {
                    var e = t.graphic && d[t.plotX];
                    e && (t.graphic[t.graphic.isNew ? "attr" : "animate"]({
                        x: e.pos + e.align * e.size,
                        anchorX: t.anchorX
                    }), r(e.pos) ? t.graphic.isNew = !1 : (t.graphic.attr({
                        x: -9999,
                        anchorX: -9999
                    }), t.graphic.isNew = !0))
                })), h.useHTML && t.wrap(this.markerGroup, "on", function (e) {
                    return t.SVGElement.prototype.on.apply(e.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1))
                })
            },
            drawTracker: function () {
                var t = this.points;
                d.drawTrackerPoint.apply(this), t.forEach(function (e) {
                    var i = e.graphic;
                    i && s(i.element, "mouseover", function () {
                        0 < e.stackIndex && !e.raised && (e._y = i.y, i.attr({y: e._y - 8}), e.raised = !0), t.forEach(function (t) {
                            t !== e && t.raised && t.graphic && (t.graphic.attr({y: t._y}), t.raised = !1)
                        })
                    })
                })
            },
            animate: function (t) {
                t ? this.setClip() : this.animate = null
            },
            setClip: function () {
                c.prototype.setClip.apply(this, arguments), !1 !== this.options.clip && this.sharedClipKey && this.markerGroup.clip(this.chart[this.sharedClipKey])
            },
            buildKDTree: e,
            invertGroups: e
        }, {
            isValid: function () {
                return o(this.y) || void 0 === this.y
            }
        }), p.flag = function (t, e, i, n, r) {
            var o = r && r.anchorX || t;
            return r = r && r.anchorY || e, p.circle(o - 1, r - 1, 2, 2).concat(["M", o, r, "L", t, e + n, t, e, t + i, e, t + i, e + n, t, e + n, "Z"])
        }, n("circle"), n("square"), h === f && ["circlepin", "flag", "squarepin"].forEach(function (t) {
            f.prototype.symbols[t] = p[t]
        })
    }), e(i, "parts/RangeSelector.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        function i(t) {
            this.init(t)
        }

        var n = e.defined, r = e.isNumber, o = e.objectEach, a = e.pInt, s = e.splat, l = t.addEvent, h = t.Axis;
        e = t.Chart;
        var c = t.css, u = t.createElement, d = t.defaultOptions, f = t.destroyObjectProperties, p = t.discardElement,
            g = t.extend, m = t.fireEvent, v = t.merge, y = t.pick;
        g(d, {
            rangeSelector: {
                verticalAlign: "top",
                buttonTheme: {width: 28, height: 18, padding: 2, zIndex: 7},
                floating: !1,
                x: 0,
                y: 0,
                height: void 0,
                inputPosition: {align: "right", x: 0, y: 0},
                buttonPosition: {align: "left", x: 0, y: 0},
                labelStyle: {color: "#666666"}
            }
        }), d.lang = v(d.lang, {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "From",
            rangeSelectorTo: "To"
        }), i.prototype = {
            clickButton: function (t, e) {
                var i = this.chart, n = this.buttonOptions[t], o = i.xAxis[0],
                    a = i.scroller && i.scroller.getUnionExtremes() || o || {}, c = a.dataMin, u = a.dataMax,
                    d = o && Math.round(Math.min(o.max, y(u, o.max))), f = n.type;
                a = n._range;
                var p, g = n.dataGrouping;
                if (null !== c && null !== u) {
                    if (i.fixedRange = a, g && (this.forcedDataGrouping = !0, h.prototype.setDataGrouping.call(o || {chart: this.chart}, g, !1), this.frozenStates = n.preserveDataGrouping), "month" === f || "year" === f) if (o) {
                        f = {range: n, max: d, chart: i, dataMin: c, dataMax: u};
                        var m = o.minFromRange.call(f);
                        r(f.newMax) && (d = f.newMax)
                    } else a = n; else if (a) m = Math.max(d - a, c), d = Math.min(m + a, u); else if ("ytd" === f) {
                        if (!o) return void (this.deferredYTDClick = t);
                        void 0 === u && (c = Number.MAX_VALUE, u = Number.MIN_VALUE, i.series.forEach(function (t) {
                            t = t.xData, c = Math.min(t[0], c), u = Math.max(t[t.length - 1], u)
                        }), e = !1), m = p = (d = this.getYTDExtremes(u, c, i.time.useUTC)).min, d = d.max
                    } else "all" === f && o && (m = c, d = u);
                    if (m += n._offsetMin, d += n._offsetMax, this.setSelected(t), o) o.setExtremes(m, d, y(e, 1), null, {
                        trigger: "rangeSelectorButton",
                        rangeSelectorButton: n
                    }); else {
                        var v = s(i.options.xAxis)[0], x = v.range;
                        v.range = a;
                        var b = v.min;
                        v.min = p, l(i, "load", function () {
                            v.range = x, v.min = b
                        })
                    }
                }
            },
            setSelected: function (t) {
                this.selected = this.options.selected = t
            },
            defaultButtons: [{type: "month", count: 1, text: "1m"}, {
                type: "month",
                count: 3,
                text: "3m"
            }, {type: "month", count: 6, text: "6m"}, {type: "ytd", text: "YTD"}, {
                type: "year",
                count: 1,
                text: "1y"
            }, {type: "all", text: "All"}],
            init: function (t) {
                var e = this, i = t.options.rangeSelector, n = i.buttons || [].concat(e.defaultButtons), r = i.selected,
                    o = function () {
                        var t = e.minInput, i = e.maxInput;
                        t && t.blur && m(t, "blur"), i && i.blur && m(i, "blur")
                    };
                e.chart = t, e.options = i, e.buttons = [], e.buttonOptions = n, this.unMouseDown = l(t.container, "mousedown", o), this.unResize = l(t, "resize", o), n.forEach(e.computeButtonRange), void 0 !== r && n[r] && this.clickButton(r, !1), l(t, "load", function () {
                    t.xAxis && t.xAxis[0] && l(t.xAxis[0], "setExtremes", function (i) {
                        this.max - this.min !== t.fixedRange && "rangeSelectorButton" !== i.trigger && "updatedData" !== i.trigger && e.forcedDataGrouping && !e.frozenStates && this.setDataGrouping(!1, !1)
                    })
                })
            },
            updateButtonStates: function () {
                var t = this, e = this.chart, i = e.xAxis[0], n = Math.round(i.max - i.min), o = !i.hasVisibleSeries,
                    a = e.scroller && e.scroller.getUnionExtremes() || i, s = a.dataMin, l = a.dataMax,
                    h = (e = t.getYTDExtremes(l, s, e.time.useUTC)).min, c = e.max, u = t.selected, d = r(u),
                    f = t.options.allButtonsEnabled, p = t.buttons;
                t.buttonOptions.forEach(function (e, r) {
                    var a = e._range, g = e.type, m = e.count || 1, v = p[r], y = 0, x = e._offsetMax - e._offsetMin;
                    e = r === u;
                    var b = a > l - s, M = a < i.minRange, A = !1, w = !1;
                    a = a === n, ("month" === g || "year" === g) && n + 36e5 >= 864e5 * {
                        month: 28,
                        year: 365
                    }[g] * m - x && n - 36e5 <= 864e5 * {
                        month: 31,
                        year: 366
                    }[g] * m + x ? a = !0 : "ytd" === g ? (a = c - h + x === n, A = !e) : "all" === g && (a = i.max - i.min >= l - s, w = !e && d && a), g = !f && (b || M || w || o), m = e && a || a && !d && !A || e && t.frozenStates, g ? y = 3 : m && (d = !0, y = 2), v.state !== y && (v.setState(y), 0 === y && u === r && t.setSelected(null))
                })
            },
            computeButtonRange: function (t) {
                var e = t.type, i = t.count || 1,
                    n = {millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5};
                n[e] ? t._range = n[e] * i : "month" !== e && "year" !== e || (t._range = 864e5 * {
                    month: 30,
                    year: 365
                }[e] * i), t._offsetMin = y(t.offsetMin, 0), t._offsetMax = y(t.offsetMax, 0), t._range += t._offsetMax - t._offsetMin
            },
            setInputValue: function (t, e) {
                var i = this.chart.options.rangeSelector, r = this.chart.time, o = this[t + "Input"];
                n(e) && (o.previousValue = o.HCTime, o.HCTime = e), o.value = r.dateFormat(i.inputEditDateFormat || "%Y-%m-%d", o.HCTime), this[t + "DateBox"].attr({text: r.dateFormat(i.inputDateFormat || "%b %e, %Y", o.HCTime)})
            },
            showInput: function (t) {
                var e = this.inputGroup, i = this[t + "DateBox"];
                c(this[t + "Input"], {
                    left: e.translateX + i.x + "px",
                    top: e.translateY + "px",
                    width: i.width - 2 + "px",
                    height: i.height - 2 + "px",
                    border: "2px solid silver"
                })
            },
            hideInput: function (t) {
                c(this[t + "Input"], {border: 0, width: "1px", height: "1px"}), this.setInputValue(t)
            },
            drawInput: function (e) {
                function i() {
                    var t = n.value, e = (p.inputDateParser || Date.parse)(t), i = l.xAxis[0],
                        o = l.scroller && l.scroller.xAxis ? l.scroller.xAxis : i, h = o.dataMin;
                    o = o.dataMax, e !== n.previousValue && (n.previousValue = e, r(e) || (e = t.split("-"), e = Date.UTC(a(e[0]), a(e[1]) - 1, a(e[2]))), r(e) && (l.time.useUTC || (e += 6e4 * (new Date).getTimezoneOffset()), y ? e > s.maxInput.HCTime ? e = void 0 : e < h && (e = h) : e < s.minInput.HCTime ? e = void 0 : e > o && (e = o), void 0 !== e && i.setExtremes(y ? e : i.min, y ? i.max : e, void 0, void 0, {trigger: "rangeSelectorInput"})))
                }

                var n, o, s = this, l = s.chart, h = l.renderer.style || {}, f = l.renderer,
                    p = l.options.rangeSelector, m = s.div, y = "min" === e, x = this.inputGroup;
                this[e + "Label"] = o = f.label(d.lang[y ? "rangeSelectorFrom" : "rangeSelectorTo"], this.inputGroup.offset).addClass("highcharts-range-label").attr({padding: 2}).add(x), x.offset += o.width + 5, this[e + "DateBox"] = f = f.label("", x.offset).addClass("highcharts-range-input").attr({
                    padding: 2,
                    width: p.inputBoxWidth || 90,
                    height: p.inputBoxHeight || 17,
                    "text-align": "center"
                }).on("click", function () {
                    s.showInput(e), s[e + "Input"].focus()
                }), l.styledMode || f.attr({
                    stroke: p.inputBoxBorderColor || "#cccccc",
                    "stroke-width": 1
                }), f.add(x), x.offset += f.width + (y ? 10 : 0), this[e + "Input"] = n = u("input", {
                    name: e,
                    className: "highcharts-range-selector",
                    type: "text"
                }, {top: l.plotTop + "px"}, m), l.styledMode || (o.css(v(h, p.labelStyle)), f.css(v({color: "#333333"}, h, p.inputStyle)), c(n, g({
                    position: "absolute",
                    border: 0,
                    width: "1px",
                    height: "1px",
                    padding: 0,
                    textAlign: "center",
                    fontSize: h.fontSize,
                    fontFamily: h.fontFamily,
                    top: "-9999em"
                }, p.inputStyle))), n.onfocus = function () {
                    s.showInput(e)
                }, n.onblur = function () {
                    n === t.doc.activeElement && i(), s.hideInput(e), n.blur()
                }, n.onchange = i, n.onkeypress = function (t) {
                    13 === t.keyCode && i()
                }
            },
            getPosition: function () {
                var t = this.chart, e = t.options.rangeSelector;
                return {
                    buttonTop: (t = "top" === e.verticalAlign ? t.plotTop - t.axisOffset[0] : 0) + e.buttonPosition.y,
                    inputTop: t + e.inputPosition.y - 10
                }
            },
            getYTDExtremes: function (t, e, i) {
                var n = this.chart.time, r = new n.Date(t), o = n.get("FullYear", r);
                return i = i ? n.Date.UTC(o, 0, 1) : +new n.Date(o, 0, 1), e = Math.max(e || 0, i), r = r.getTime(), {
                    max: Math.min(t || r, r),
                    min: e
                }
            },
            render: function (t, e) {
                var i = this, n = i.chart, r = n.renderer, o = n.container, a = n.options,
                    s = a.exporting && !1 !== a.exporting.enabled && a.navigation && a.navigation.buttonOptions,
                    l = d.lang, h = i.div, c = a.rangeSelector, f = y(a.chart.style && a.chart.style.zIndex, 0) + 1;
                a = c.floating;
                var p = i.buttons;
                h = i.inputGroup;
                var g, m = c.buttonTheme, v = c.buttonPosition, x = c.inputPosition, b = c.inputEnabled,
                    M = m && m.states, A = n.plotLeft, w = i.buttonGroup, k = i.rendered, S = i.options.verticalAlign,
                    T = n.legend, E = T && T.options, C = v.y, D = x.y, P = k || !1, _ = P ? "animate" : "attr", O = 0,
                    L = 0;
                if (!1 !== c.enabled) {
                    k || (i.group = k = r.g("range-selector-group").attr({zIndex: 7}).add(), i.buttonGroup = w = r.g("range-selector-buttons").add(k), i.zoomText = r.text(l.rangeSelectorZoom, 0, 15).add(w), n.styledMode || (i.zoomText.css(c.labelStyle), m["stroke-width"] = y(m["stroke-width"], 0)), i.buttonOptions.forEach(function (t, e) {
                        p[e] = r.button(t.text, 0, 0, function (n) {
                            var r, o = t.events && t.events.click;
                            o && (r = o.call(t, n)), !1 !== r && i.clickButton(e), i.isActive = !0
                        }, m, M && M.hover, M && M.select, M && M.disabled).attr({"text-align": "center"}).add(w)
                    }), !1 !== b && (i.div = h = u("div", null, {
                        position: "relative",
                        height: 0,
                        zIndex: f
                    }), o.parentNode.insertBefore(h, o), i.inputGroup = h = r.g("input-group").add(k), h.offset = 0, i.drawInput("min"), i.drawInput("max"))), i.zoomText[_]({x: y(A + v.x, A)});
                    var N = y(A + v.x, A) + i.zoomText.getBBox().width + 5;
                    i.buttonOptions.forEach(function (t, e) {
                        p[e][_]({x: N}), N += p[e].width + y(c.buttonSpacing, 5)
                    }), A = n.plotLeft - n.spacing[3], i.updateButtonStates(), s && this.titleCollision(n) && "top" === S && "right" === v.align && v.y + w.getBBox().height - 12 < (s.y || 0) + s.height && (O = -40), "left" === v.align ? g = v.x - n.spacing[3] : "right" === v.align && (g = v.x + O - n.spacing[1]), w.align({
                        y: v.y,
                        width: w.getBBox().width,
                        align: v.align,
                        x: g
                    }, !0, n.spacingBox), i.group.placed = P, i.buttonGroup.placed = P, !1 !== b && (O = s && this.titleCollision(n) && "top" === S && "right" === x.align && x.y - h.getBBox().height - 12 < (s.y || 0) + s.height + n.spacing[0] ? -40 : 0, "left" === x.align ? g = A : "right" === x.align && (g = -Math.max(n.axisOffset[1], -O)), h.align({
                        y: x.y,
                        width: h.getBBox().width,
                        align: x.align,
                        x: x.x + g - 2
                    }, !0, n.spacingBox), o = h.alignAttr.translateX + h.alignOptions.x - O + h.getBBox().x + 2, s = h.alignOptions.width, l = w.alignAttr.translateX + w.getBBox().x, g = w.getBBox().width + 20, (x.align === v.align || l + g > o && o + s > l && C < D + h.getBBox().height) && h.attr({
                        translateX: h.alignAttr.translateX + (n.axisOffset[1] >= -O ? 0 : -O),
                        translateY: h.alignAttr.translateY + w.getBBox().height + 10
                    }), i.setInputValue("min", t), i.setInputValue("max", e), i.inputGroup.placed = P), i.group.align({verticalAlign: S}, !0, n.spacingBox), t = i.group.getBBox().height + 20, e = i.group.alignAttr.translateY, "bottom" === S && (L = e - (t = t + (T = E && "bottom" === E.verticalAlign && E.enabled && !E.floating ? T.legendHeight + y(E.margin, 10) : 0) - 20) - (a ? 0 : c.y) - (n.titleOffset ? n.titleOffset[2] : 0) - 10), "top" === S ? (a && (L = 0), n.titleOffset && n.titleOffset[0] && (L = n.titleOffset[0]), L += n.margin[0] - n.spacing[0] || 0) : "middle" === S && (D === C ? L = 0 > D ? e + void 0 : e : (D || C) && (L = 0 > D || 0 > C ? L - Math.min(D, C) : e - t + NaN)), i.group.translate(c.x, c.y + Math.floor(L)), !1 !== b && (i.minInput.style.marginTop = i.group.translateY + "px", i.maxInput.style.marginTop = i.group.translateY + "px"), i.rendered = !0
                }
            },
            getHeight: function () {
                var t = this.options, e = this.group, i = t.y, n = t.buttonPosition.y, r = t.inputPosition.y;
                return t.height ? t.height : (t = e ? e.getBBox(!0).height + 13 + i : 0, e = Math.min(r, n), (0 > r && 0 > n || 0 < r && 0 < n) && (t += Math.abs(e)), t)
            },
            titleCollision: function (t) {
                return !(t.options.title.text || t.options.subtitle.text)
            },
            update: function (t) {
                var e = this.chart;
                v(!0, e.options.rangeSelector, t), this.destroy(), this.init(e), e.rangeSelector.render()
            },
            destroy: function () {
                var t = this, e = t.minInput, n = t.maxInput;
                t.unMouseDown(), t.unResize(), f(t.buttons), e && (e.onfocus = e.onblur = e.onchange = null), n && (n.onfocus = n.onblur = n.onchange = null), o(t, function (e, n) {
                    e && "chart" !== n && (e.destroy ? e.destroy() : e.nodeType && p(this[n])), e !== i.prototype[n] && (t[n] = null)
                }, this)
            }
        }, h.prototype.minFromRange = function () {
            var t = this.range, e = {month: "Month", year: "FullYear"}[t.type], i = this.max, n = this.chart.time,
                o = function (t, i) {
                    var r = new n.Date(t), o = n.get(e, r);
                    return n.set(e, r, o + i), o === n.get(e, r) && n.set("Date", r, 0), r.getTime() - t
                };
            if (r(t)) var a = i - t, s = t; else a = i + o(i, -t.count), this.chart && (this.chart.fixedRange = i - a);
            var l = y(this.dataMin, Number.MIN_VALUE);
            return r(a) || (a = l), a <= l && (a = l, void 0 === s && (s = o(a, t.count)), this.newMax = Math.min(a + s, this.dataMax)), r(i) || (a = void 0), a
        }, t.RangeSelector || (l(e, "afterGetContainer", function () {
            this.options.rangeSelector.enabled && (this.rangeSelector = new i(this))
        }), l(e, "beforeRender", function () {
            var t = this.axes, e = this.rangeSelector;
            e && (r(e.deferredYTDClick) && (e.clickButton(e.deferredYTDClick), delete e.deferredYTDClick), t.forEach(function (t) {
                t.updateNames(), t.setScale()
            }), this.getAxisMargins(), e.render(), t = e.options.verticalAlign, e.options.floating || ("bottom" === t ? this.extraBottomMargin = !0 : "middle" !== t && (this.extraTopMargin = !0)))
        }), l(e, "update", function (t) {
            var e = t.options.rangeSelector;
            t = this.rangeSelector;
            var r = this.extraBottomMargin, o = this.extraTopMargin;
            e && e.enabled && !n(t) && (this.options.rangeSelector.enabled = !0, this.rangeSelector = new i(this)), this.extraTopMargin = this.extraBottomMargin = !1, t && (t.render(), e = e && e.verticalAlign || t.options && t.options.verticalAlign, t.options.floating || ("bottom" === e ? this.extraBottomMargin = !0 : "middle" !== e && (this.extraTopMargin = !0)), this.extraBottomMargin !== r || this.extraTopMargin !== o) && (this.isDirtyBox = !0)
        }), l(e, "render", function () {
            var t = this.rangeSelector;
            t && !t.options.floating && (t.render(), "bottom" === (t = t.options.verticalAlign) ? this.extraBottomMargin = !0 : "middle" !== t && (this.extraTopMargin = !0))
        }), l(e, "getMargins", function () {
            var t = this.rangeSelector;
            t && (t = t.getHeight(), this.extraTopMargin && (this.plotTop += t), this.extraBottomMargin && (this.marginBottom += t))
        }), e.prototype.callbacks.push(function (t) {
            function e() {
                i = t.xAxis[0].getExtremes(), r(i.min) && n.render(i.min, i.max)
            }

            var i, n = t.rangeSelector;
            if (n) {
                var o = l(t.xAxis[0], "afterSetExtremes", function (t) {
                    n.render(t.min, t.max)
                }), a = l(t, "redraw", e);
                e()
            }
            l(t, "destroy", function () {
                n && (a(), o())
            })
        }), t.RangeSelector = i)
    }), e(i, "parts/StockChart.js", [i["parts/Globals.js"], i["parts/Utilities.js"]], function (t, e) {
        var i = e.defined, n = e.isNumber, r = e.isString, o = e.splat;
        e = t.addEvent;
        var a = t.arrayMax, s = t.arrayMin, l = t.Axis, h = t.Chart, c = t.extend, u = t.format, d = t.merge,
            f = t.pick, p = t.Point, g = t.Renderer, m = t.Series, v = t.SVGRenderer, y = t.VMLRenderer,
            x = m.prototype, b = x.init, M = x.processData, A = p.prototype.tooltipFormatter;
        t.StockChart = t.stockChart = function (e, i, n) {
            var a, s = r(e) || e.nodeName, l = arguments[s ? 1 : 0], c = l, u = l.series, p = t.getOptions(),
                g = f(l.navigator && l.navigator.enabled, p.navigator.enabled, !0),
                m = g ? {startOnTick: !1, endOnTick: !1} : null;
            return l.xAxis = o(l.xAxis || {}).map(function (t, e) {
                return d({
                    minPadding: 0,
                    maxPadding: 0,
                    overscroll: 0,
                    ordinal: !0,
                    title: {text: null},
                    labels: {overflow: "justify"},
                    showLastLabel: !0
                }, p.xAxis, p.xAxis && p.xAxis[e], t, {type: "datetime", categories: null}, m)
            }), l.yAxis = o(l.yAxis || {}).map(function (t, e) {
                return a = f(t.opposite, !0), d({
                    labels: {y: -2},
                    opposite: a,
                    showLastLabel: !(!t.categories && "category" !== t.type),
                    title: {text: null}
                }, p.yAxis, p.yAxis && p.yAxis[e], t)
            }), l.series = null, (l = d({
                chart: {panning: !0, pinchType: "x"},
                navigator: {enabled: g},
                scrollbar: {enabled: f(p.scrollbar.enabled, !0)},
                rangeSelector: {enabled: f(p.rangeSelector.enabled, !0)},
                title: {text: null},
                tooltip: {split: f(p.tooltip.split, !0), crosshairs: !0},
                legend: {enabled: !1}
            }, l, {isStock: !0})).series = c.series = u, s ? new h(e, l, n) : new h(l, i)
        }, e(m, "setOptions", function (e) {
            function i(e) {
                return t.seriesTypes[e] && r instanceof t.seriesTypes[e]
            }

            var n, r = this;
            this.chart.options.isStock && (i("column") || i("columnrange") ? n = {
                borderWidth: 0,
                shadow: !1
            } : !i("line") || i("scatter") || i("sma") || (n = {
                marker: {
                    enabled: !1,
                    radius: 2
                }
            }), n && (e.plotOptions[this.type] = d(e.plotOptions[this.type], n)))
        }), e(l, "autoLabelAlign", function (t) {
            var e = this.chart, i = this.options;
            e = e._labelPanes = e._labelPanes || {};
            var n = this.options.labels;
            this.chart.options.isStock && "yAxis" === this.coll && (!e[i = i.top + "," + i.height] && n.enabled && (15 === n.x && (n.x = 0), void 0 === n.align && (n.align = "right"), e[i] = this, t.align = "right", t.preventDefault()))
        }), e(l, "destroy", function () {
            var t = this.chart, e = this.options && this.options.top + "," + this.options.height;
            e && t._labelPanes && t._labelPanes[e] === this && delete t._labelPanes[e]
        }), e(l, "getPlotLinePath", function (e) {
            var o, a, s, l, h = this, c = this.isLinked && !this.series ? this.linkedParent.series : this.series,
                u = h.chart, d = u.renderer, p = h.left, g = h.top, m = [], v = [], y = e.translatedValue, x = e.value,
                b = e.force;
            if (u.options.isStock && !1 !== e.acrossPanes && "xAxis" === h.coll || "yAxis" === h.coll) {
                e.preventDefault(), v = function (t) {
                    var e = "xAxis" === t ? "yAxis" : "xAxis";
                    return t = h.options[e], n(t) ? [u[e][t]] : r(t) ? [u.get(t)] : c.map(function (t) {
                        return t[e]
                    })
                }(h.coll), (h.isXAxis ? u.yAxis : u.xAxis).forEach(function (t) {
                    if (!i(t.options.id) || -1 === t.options.id.indexOf("navigator")) {
                        var e = t.isXAxis ? "yAxis" : "xAxis";
                        e = i(t.options[e]) ? u[e][t.options[e]] : u[e][0], h === e && v.push(t)
                    }
                });
                var M = v.length ? [] : [h.isXAxis ? u.yAxis[0] : u.xAxis[0]];
                v.forEach(function (e) {
                    -1 !== M.indexOf(e) || t.find(M, function (t) {
                        return t.pos === e.pos && t.len === e.len
                    }) || M.push(e)
                });
                var A = f(y, h.translate(x, null, null, e.old));
                n(A) && (h.horiz ? M.forEach(function (t) {
                    var e;
                    a = t.pos, l = a + t.len, o = s = Math.round(A + h.transB), "pass" !== b && (o < p || o > p + h.width) && (b ? o = s = Math.min(Math.max(p, o), p + h.width) : e = !0), e || m.push("M", o, a, "L", s, l)
                }) : M.forEach(function (t) {
                    var e;
                    o = t.pos, s = o + t.len, a = l = Math.round(g + h.height - A), "pass" !== b && (a < g || a > g + h.height) && (b ? a = l = Math.min(Math.max(g, a), h.top + h.height) : e = !0), e || m.push("M", o, a, "L", s, l)
                })), e.path = 0 < m.length ? d.crispPolyLine(m, e.lineWidth || 1) : null
            }
        }), v.prototype.crispPolyLine = function (t, e) {
            var i;
            for (i = 0; i < t.length; i += 6) t[i + 1] === t[i + 4] && (t[i + 1] = t[i + 4] = Math.round(t[i + 1]) - e % 2 / 2), t[i + 2] === t[i + 5] && (t[i + 2] = t[i + 5] = Math.round(t[i + 2]) + e % 2 / 2);
            return t
        }, g === y && (y.prototype.crispPolyLine = v.prototype.crispPolyLine), e(l, "afterHideCrosshair", function () {
            this.crossLabel && (this.crossLabel = this.crossLabel.hide())
        }), e(l, "afterDrawCrosshair", function (t) {
            var e, n;
            if (i(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {
                var r = this.chart, o = this.options.crosshair.label, a = this.horiz, s = this.opposite, l = this.left,
                    h = this.top, d = this.crossLabel, p = o.format, g = "", m = "inside" === this.options.tickPosition,
                    v = !1 !== this.crosshair.snap, y = 0, x = t.e || this.cross && this.cross.e, b = t.point,
                    M = this.lin2log;
                if (this.isLog) {
                    t = M(this.min);
                    var A = M(this.max)
                } else t = this.min, A = this.max;
                M = a ? "center" : s ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center", d || (d = this.crossLabel = r.renderer.label(null, null, null, o.shape || "callout").addClass("highcharts-crosshair-label" + (this.series[0] && " highcharts-color-" + this.series[0].colorIndex)).attr({
                    align: o.align || M,
                    padding: f(o.padding, 8),
                    r: f(o.borderRadius, 3),
                    zIndex: 2
                }).add(this.labelGroup), r.styledMode || d.attr({
                    fill: o.backgroundColor || this.series[0] && this.series[0].color || "#666666",
                    stroke: o.borderColor || "",
                    "stroke-width": o.borderWidth || 0
                }).css(c({
                    color: "#ffffff",
                    fontWeight: "normal",
                    fontSize: "11px",
                    textAlign: "center"
                }, o.style))), a ? (M = v ? b.plotX + l : x.chartX, h += s ? 0 : this.height) : (M = s ? this.width + l : 0, h = v ? b.plotY + h : x.chartY), p || o.formatter || (this.isDatetimeAxis && (g = "%b %d, %Y"), p = "{value" + (g ? ":" + g : "") + "}"), g = v ? b[this.isXAxis ? "x" : "y"] : this.toValue(a ? x.chartX : x.chartY), d.attr({
                    text: p ? u(p, {value: g}, r.time) : o.formatter.call(this, g),
                    x: M,
                    y: h,
                    visibility: g < t || g > A ? "hidden" : "visible"
                }), o = d.getBBox(), a ? (m && !s || !m && s) && (h = d.y - o.height) : h = d.y - o.height / 2, a ? (e = l - o.x, n = l + this.width - o.x) : (e = "left" === this.labelAlign ? l : 0, n = "right" === this.labelAlign ? l + this.width : r.chartWidth), d.translateX < e && (y = e - d.translateX), d.translateX + o.width >= n && (y = -(d.translateX + o.width - n)), d.attr({
                    x: M + y,
                    y: h,
                    anchorX: a ? M : this.opposite ? 0 : r.chartWidth,
                    anchorY: a ? this.opposite ? r.chartHeight : 0 : h + o.height / 2
                })
            }
        }), x.init = function () {
            b.apply(this, arguments), this.setCompare(this.options.compare)
        }, x.setCompare = function (t) {
            this.modifyValue = "value" === t || "percent" === t ? function (e, i) {
                var n = this.compareValue;
                if (void 0 !== e && void 0 !== n) return e = "value" === t ? e - n : e / n * 100 - (100 === this.options.compareBase ? 0 : 100), i && (i.change = e), e
            } : null, this.userOptions.compare = t, this.chart.hasRendered && (this.isDirty = !0)
        }, x.processData = function (t) {
            var e, i = -1, r = !0 === this.options.compareStart ? 0 : 1;
            if (M.apply(this, arguments), this.xAxis && this.processedYData) {
                var o = this.processedXData, a = this.processedYData, s = a.length;
                for (this.pointArrayMap && (i = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || "y")), e = 0; e < s - r; e++) {
                    var l = a[e] && -1 < i ? a[e][i] : a[e];
                    if (n(l) && o[e + r] >= this.xAxis.min && 0 !== l) {
                        this.compareValue = l;
                        break
                    }
                }
            }
        }, e(m, "afterGetExtremes", function () {
            if (this.modifyValue) {
                var t = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];
                this.dataMin = s(t), this.dataMax = a(t)
            }
        }), l.prototype.setCompare = function (t, e) {
            this.isXAxis || (this.series.forEach(function (e) {
                e.setCompare(t)
            }), f(e, !0) && this.chart.redraw())
        }, p.prototype.tooltipFormatter = function (e) {
            return e = e.replace("{point.change}", (0 < this.change ? "+" : "") + t.numberFormat(this.change, f(this.series.tooltipOptions.changeDecimals, 2))), A.apply(this, [e])
        }, e(m, "render", function () {
            var t = this.chart;
            if (!(t.is3d && t.is3d() || t.polar) && this.xAxis && !this.xAxis.isRadial) {
                var e = this.yAxis.len;
                if (this.xAxis.axisLine) {
                    var i = t.plotTop + t.plotHeight - this.yAxis.pos - this.yAxis.len,
                        n = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);
                    0 <= i && (e -= Math.max(n - i, 0))
                }
                !this.clipBox && this.animate ? (this.clipBox = d(t.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = e) : t[this.sharedClipKey] && (t[this.sharedClipKey].animate({
                    width: this.xAxis.len,
                    height: e
                }), t[this.sharedClipKey + "m"] && t[this.sharedClipKey + "m"].animate({width: this.xAxis.len}))
            }
        }), e(h, "update", function (t) {
            "scrollbar" in (t = t.options) && this.navigator && (d(!0, this.options.scrollbar, t.scrollbar), this.navigator.update({}, !1), delete t.scrollbar)
        })
    }), e(i, "masters/modules/stock.src.js", [], function () {
    }), e(i, "masters/highstock.src.js", [i["masters/highcharts.src.js"]], function (t) {
        return t.product = "Highstock", t
    }), i["masters/highstock.src.js"]._modules = i, i["masters/highstock.src.js"]
}), function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.moment = e()
}(this, function () {
    "use strict";
    var t, e;

    function i() {
        return t.apply(null, arguments)
    }

    function n(t) {
        return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t)
    }

    function r(t) {
        return null != t && "[object Object]" === Object.prototype.toString.call(t)
    }

    function o(t) {
        return void 0 === t
    }

    function a(t) {
        return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t)
    }

    function s(t) {
        return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t)
    }

    function l(t, e) {
        var i, n = [];
        for (i = 0; i < t.length; ++i) n.push(e(t[i], i));
        return n
    }

    function h(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }

    function c(t, e) {
        for (var i in e) h(e, i) && (t[i] = e[i]);
        return h(e, "toString") && (t.toString = e.toString), h(e, "valueOf") && (t.valueOf = e.valueOf), t
    }

    function u(t, e, i, n) {
        return Se(t, e, i, n, !0).utc()
    }

    function d(t) {
        return null == t._pf && (t._pf = {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1
        }), t._pf
    }

    function f(t) {
        if (null == t._isValid) {
            var i = d(t), n = e.call(i.parsedDateParts, function (t) {
                    return null != t
                }),
                r = !isNaN(t._d.getTime()) && i.overflow < 0 && !i.empty && !i.invalidMonth && !i.invalidWeekday && !i.weekdayMismatch && !i.nullInput && !i.invalidFormat && !i.userInvalidated && (!i.meridiem || i.meridiem && n);
            if (t._strict && (r = r && 0 === i.charsLeftOver && 0 === i.unusedTokens.length && void 0 === i.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return r;
            t._isValid = r
        }
        return t._isValid
    }

    function p(t) {
        var e = u(NaN);
        return null != t ? c(d(e), t) : d(e).userInvalidated = !0, e
    }

    e = Array.prototype.some ? Array.prototype.some : function (t) {
        for (var e = Object(this), i = e.length >>> 0, n = 0; n < i; n++) if (n in e && t.call(this, e[n], n, e)) return !0;
        return !1
    };
    var g = i.momentProperties = [];

    function m(t, e) {
        var i, n, r;
        if (o(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), o(e._i) || (t._i = e._i), o(e._f) || (t._f = e._f), o(e._l) || (t._l = e._l), o(e._strict) || (t._strict = e._strict), o(e._tzm) || (t._tzm = e._tzm), o(e._isUTC) || (t._isUTC = e._isUTC), o(e._offset) || (t._offset = e._offset), o(e._pf) || (t._pf = d(e)), o(e._locale) || (t._locale = e._locale), 0 < g.length) for (i = 0; i < g.length; i++) o(r = e[n = g[i]]) || (t[n] = r);
        return t
    }

    var v = !1;

    function y(t) {
        m(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === v && (v = !0, i.updateOffset(this), v = !1)
    }

    function x(t) {
        return t instanceof y || null != t && null != t._isAMomentObject
    }

    function b(t) {
        return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
    }

    function M(t) {
        var e = +t, i = 0;
        return 0 !== e && isFinite(e) && (i = b(e)), i
    }

    function A(t, e, i) {
        var n, r = Math.min(t.length, e.length), o = Math.abs(t.length - e.length), a = 0;
        for (n = 0; n < r; n++) (i && t[n] !== e[n] || !i && M(t[n]) !== M(e[n])) && a++;
        return a + o
    }

    function w(t) {
        !1 === i.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
    }

    function k(t, e) {
        var n = !0;
        return c(function () {
            if (null != i.deprecationHandler && i.deprecationHandler(null, t), n) {
                for (var r, o = [], a = 0; a < arguments.length; a++) {
                    if (r = "", "object" == typeof arguments[a]) {
                        for (var s in r += "\n[" + a + "] ", arguments[0]) r += s + ": " + arguments[0][s] + ", ";
                        r = r.slice(0, -2)
                    } else r = arguments[a];
                    o.push(r)
                }
                w(t + "\nArguments: " + Array.prototype.slice.call(o).join("") + "\n" + (new Error).stack), n = !1
            }
            return e.apply(this, arguments)
        }, e)
    }

    var S, T = {};

    function E(t, e) {
        null != i.deprecationHandler && i.deprecationHandler(t, e), T[t] || (w(e), T[t] = !0)
    }

    function C(t) {
        return t instanceof Function || "[object Function]" === Object.prototype.toString.call(t)
    }

    function D(t, e) {
        var i, n = c({}, t);
        for (i in e) h(e, i) && (r(t[i]) && r(e[i]) ? (n[i] = {}, c(n[i], t[i]), c(n[i], e[i])) : null != e[i] ? n[i] = e[i] : delete n[i]);
        for (i in t) h(t, i) && !h(e, i) && r(t[i]) && (n[i] = c({}, n[i]));
        return n
    }

    function P(t) {
        null != t && this.set(t)
    }

    i.suppressDeprecationWarnings = !1, i.deprecationHandler = null, S = Object.keys ? Object.keys : function (t) {
        var e, i = [];
        for (e in t) h(t, e) && i.push(e);
        return i
    };
    var _ = {};

    function O(t, e) {
        var i = t.toLowerCase();
        _[i] = _[i + "s"] = _[e] = t
    }

    function L(t) {
        return "string" == typeof t ? _[t] || _[t.toLowerCase()] : void 0
    }

    function N(t) {
        var e, i, n = {};
        for (i in t) h(t, i) && (e = L(i)) && (n[e] = t[i]);
        return n
    }

    var z = {};

    function I(t, e) {
        z[t] = e
    }

    function R(t, e, i) {
        var n = "" + Math.abs(t), r = e - n.length;
        return (0 <= t ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + n
    }

    var B = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        j = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, W = {}, H = {};

    function Y(t, e, i, n) {
        var r = n;
        "string" == typeof n && (r = function () {
            return this[n]()
        }), t && (H[t] = r), e && (H[e[0]] = function () {
            return R(r.apply(this, arguments), e[1], e[2])
        }), i && (H[i] = function () {
            return this.localeData().ordinal(r.apply(this, arguments), t)
        })
    }

    function G(t, e) {
        return t.isValid() ? (e = F(e, t.localeData()), W[e] = W[e] || function (t) {
            var e, i, n, r = t.match(B);
            for (e = 0, i = r.length; e < i; e++) H[r[e]] ? r[e] = H[r[e]] : r[e] = (n = r[e]).match(/\[[\s\S]/) ? n.replace(/^\[|\]$/g, "") : n.replace(/\\/g, "");
            return function (e) {
                var n, o = "";
                for (n = 0; n < i; n++) o += C(r[n]) ? r[n].call(e, t) : r[n];
                return o
            }
        }(e), W[e](t)) : t.localeData().invalidDate()
    }

    function F(t, e) {
        var i = 5;

        function n(t) {
            return e.longDateFormat(t) || t
        }

        for (j.lastIndex = 0; 0 <= i && j.test(t);) t = t.replace(j, n), j.lastIndex = 0, i -= 1;
        return t
    }

    var X = /\d/, U = /\d\d/, q = /\d{3}/, $ = /\d{4}/, V = /[+-]?\d{6}/, K = /\d\d?/, Z = /\d\d\d\d?/,
        J = /\d\d\d\d\d\d?/, Q = /\d{1,3}/, tt = /\d{1,4}/, et = /[+-]?\d{1,6}/, it = /\d+/, nt = /[+-]?\d+/,
        rt = /Z|[+-]\d\d:?\d\d/gi, ot = /Z|[+-]\d\d(?::?\d\d)?/gi,
        at = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        st = {};

    function lt(t, e, i) {
        st[t] = C(e) ? e : function (t, n) {
            return t && i ? i : e
        }
    }

    function ht(t, e) {
        return h(st, t) ? st[t](e._strict, e._locale) : new RegExp(ct(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, r) {
            return e || i || n || r
        })))
    }

    function ct(t) {
        return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }

    var ut = {};

    function dt(t, e) {
        var i, n = e;
        for ("string" == typeof t && (t = [t]), a(e) && (n = function (t, i) {
            i[e] = M(t)
        }), i = 0; i < t.length; i++) ut[t[i]] = n
    }

    function ft(t, e) {
        dt(t, function (t, i, n, r) {
            n._w = n._w || {}, e(t, n._w, n, r)
        })
    }

    var pt = 0, gt = 1, mt = 2, vt = 3, yt = 4, xt = 5, bt = 6, Mt = 7, At = 8;

    function wt(t) {
        return kt(t) ? 366 : 365
    }

    function kt(t) {
        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
    }

    Y("Y", 0, 0, function () {
        var t = this.year();
        return t <= 9999 ? "" + t : "+" + t
    }), Y(0, ["YY", 2], 0, function () {
        return this.year() % 100
    }), Y(0, ["YYYY", 4], 0, "year"), Y(0, ["YYYYY", 5], 0, "year"), Y(0, ["YYYYYY", 6, !0], 0, "year"), O("year", "y"), I("year", 1), lt("Y", nt), lt("YY", K, U), lt("YYYY", tt, $), lt("YYYYY", et, V), lt("YYYYYY", et, V), dt(["YYYYY", "YYYYYY"], pt), dt("YYYY", function (t, e) {
        e[pt] = 2 === t.length ? i.parseTwoDigitYear(t) : M(t)
    }), dt("YY", function (t, e) {
        e[pt] = i.parseTwoDigitYear(t)
    }), dt("Y", function (t, e) {
        e[pt] = parseInt(t, 10)
    }), i.parseTwoDigitYear = function (t) {
        return M(t) + (68 < M(t) ? 1900 : 2e3)
    };
    var St, Tt = Et("FullYear", !0);

    function Et(t, e) {
        return function (n) {
            return null != n ? (Dt(this, t, n), i.updateOffset(this, e), this) : Ct(this, t)
        }
    }

    function Ct(t, e) {
        return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN
    }

    function Dt(t, e, i) {
        t.isValid() && !isNaN(i) && ("FullYear" === e && kt(t.year()) && 1 === t.month() && 29 === t.date() ? t._d["set" + (t._isUTC ? "UTC" : "") + e](i, t.month(), Pt(i, t.month())) : t._d["set" + (t._isUTC ? "UTC" : "") + e](i))
    }

    function Pt(t, e) {
        if (isNaN(t) || isNaN(e)) return NaN;
        var i = (e % 12 + 12) % 12;
        return t += (e - i) / 12, 1 === i ? kt(t) ? 29 : 28 : 31 - i % 7 % 2
    }

    St = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) {
        var e;
        for (e = 0; e < this.length; ++e) if (this[e] === t) return e;
        return -1
    }, Y("M", ["MM", 2], "Mo", function () {
        return this.month() + 1
    }), Y("MMM", 0, 0, function (t) {
        return this.localeData().monthsShort(this, t)
    }), Y("MMMM", 0, 0, function (t) {
        return this.localeData().months(this, t)
    }), O("month", "M"), I("month", 8), lt("M", K), lt("MM", K, U), lt("MMM", function (t, e) {
        return e.monthsShortRegex(t)
    }), lt("MMMM", function (t, e) {
        return e.monthsRegex(t)
    }), dt(["M", "MM"], function (t, e) {
        e[gt] = M(t) - 1
    }), dt(["MMM", "MMMM"], function (t, e, i, n) {
        var r = i._locale.monthsParse(t, n, i._strict);
        null != r ? e[gt] = r : d(i).invalidMonth = t
    });
    var _t = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        Ot = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        Lt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

    function Nt(t, e) {
        var i;
        if (!t.isValid()) return t;
        if ("string" == typeof e) if (/^\d+$/.test(e)) e = M(e); else if (!a(e = t.localeData().monthsParse(e))) return t;
        return i = Math.min(t.date(), Pt(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i), t
    }

    function zt(t) {
        return null != t ? (Nt(this, t), i.updateOffset(this, !0), this) : Ct(this, "Month")
    }

    var It = at, Rt = at;

    function Bt() {
        function t(t, e) {
            return e.length - t.length
        }

        var e, i, n = [], r = [], o = [];
        for (e = 0; e < 12; e++) i = u([2e3, e]), n.push(this.monthsShort(i, "")), r.push(this.months(i, "")), o.push(this.months(i, "")), o.push(this.monthsShort(i, ""));
        for (n.sort(t), r.sort(t), o.sort(t), e = 0; e < 12; e++) n[e] = ct(n[e]), r[e] = ct(r[e]);
        for (e = 0; e < 24; e++) o[e] = ct(o[e]);
        this._monthsRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i")
    }

    function jt(t) {
        var e = new Date(Date.UTC.apply(null, arguments));
        return t < 100 && 0 <= t && isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t), e
    }

    function Wt(t, e, i) {
        var n = 7 + e - i;
        return -(7 + jt(t, 0, n).getUTCDay() - e) % 7 + n - 1
    }

    function Ht(t, e, i, n, r) {
        var o, a, s = 1 + 7 * (e - 1) + (7 + i - n) % 7 + Wt(t, n, r);
        return a = s <= 0 ? wt(o = t - 1) + s : s > wt(t) ? (o = t + 1, s - wt(t)) : (o = t, s), {year: o, dayOfYear: a}
    }

    function Yt(t, e, i) {
        var n, r, o = Wt(t.year(), e, i), a = Math.floor((t.dayOfYear() - o - 1) / 7) + 1;
        return a < 1 ? n = a + Gt(r = t.year() - 1, e, i) : a > Gt(t.year(), e, i) ? (n = a - Gt(t.year(), e, i), r = t.year() + 1) : (r = t.year(), n = a), {
            week: n,
            year: r
        }
    }

    function Gt(t, e, i) {
        var n = Wt(t, e, i), r = Wt(t + 1, e, i);
        return (wt(t) - n + r) / 7
    }

    Y("w", ["ww", 2], "wo", "week"), Y("W", ["WW", 2], "Wo", "isoWeek"), O("week", "w"), O("isoWeek", "W"), I("week", 5), I("isoWeek", 5), lt("w", K), lt("ww", K, U), lt("W", K), lt("WW", K, U), ft(["w", "ww", "W", "WW"], function (t, e, i, n) {
        e[n.substr(0, 1)] = M(t)
    }), Y("d", 0, "do", "day"), Y("dd", 0, 0, function (t) {
        return this.localeData().weekdaysMin(this, t)
    }), Y("ddd", 0, 0, function (t) {
        return this.localeData().weekdaysShort(this, t)
    }), Y("dddd", 0, 0, function (t) {
        return this.localeData().weekdays(this, t)
    }), Y("e", 0, 0, "weekday"), Y("E", 0, 0, "isoWeekday"), O("day", "d"), O("weekday", "e"), O("isoWeekday", "E"), I("day", 11), I("weekday", 11), I("isoWeekday", 11), lt("d", K), lt("e", K), lt("E", K), lt("dd", function (t, e) {
        return e.weekdaysMinRegex(t)
    }), lt("ddd", function (t, e) {
        return e.weekdaysShortRegex(t)
    }), lt("dddd", function (t, e) {
        return e.weekdaysRegex(t)
    }), ft(["dd", "ddd", "dddd"], function (t, e, i, n) {
        var r = i._locale.weekdaysParse(t, n, i._strict);
        null != r ? e.d = r : d(i).invalidWeekday = t
    }), ft(["d", "e", "E"], function (t, e, i, n) {
        e[n] = M(t)
    });
    var Ft = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        Xt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Ut = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), qt = at, $t = at,
        Vt = at;

    function Kt() {
        function t(t, e) {
            return e.length - t.length
        }

        var e, i, n, r, o, a = [], s = [], l = [], h = [];
        for (e = 0; e < 7; e++) i = u([2e3, 1]).day(e), n = this.weekdaysMin(i, ""), r = this.weekdaysShort(i, ""), o = this.weekdays(i, ""), a.push(n), s.push(r), l.push(o), h.push(n), h.push(r), h.push(o);
        for (a.sort(t), s.sort(t), l.sort(t), h.sort(t), e = 0; e < 7; e++) s[e] = ct(s[e]), l[e] = ct(l[e]), h[e] = ct(h[e]);
        this._weekdaysRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
    }

    function Zt() {
        return this.hours() % 12 || 12
    }

    function Jt(t, e) {
        Y(t, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), e)
        })
    }

    function Qt(t, e) {
        return e._meridiemParse
    }

    Y("H", ["HH", 2], 0, "hour"), Y("h", ["hh", 2], 0, Zt), Y("k", ["kk", 2], 0, function () {
        return this.hours() || 24
    }), Y("hmm", 0, 0, function () {
        return "" + Zt.apply(this) + R(this.minutes(), 2)
    }), Y("hmmss", 0, 0, function () {
        return "" + Zt.apply(this) + R(this.minutes(), 2) + R(this.seconds(), 2)
    }), Y("Hmm", 0, 0, function () {
        return "" + this.hours() + R(this.minutes(), 2)
    }), Y("Hmmss", 0, 0, function () {
        return "" + this.hours() + R(this.minutes(), 2) + R(this.seconds(), 2)
    }), Jt("a", !0), Jt("A", !1), O("hour", "h"), I("hour", 13), lt("a", Qt), lt("A", Qt), lt("H", K), lt("h", K), lt("k", K), lt("HH", K, U), lt("hh", K, U), lt("kk", K, U), lt("hmm", Z), lt("hmmss", J), lt("Hmm", Z), lt("Hmmss", J), dt(["H", "HH"], vt), dt(["k", "kk"], function (t, e, i) {
        var n = M(t);
        e[vt] = 24 === n ? 0 : n
    }), dt(["a", "A"], function (t, e, i) {
        i._isPm = i._locale.isPM(t), i._meridiem = t
    }), dt(["h", "hh"], function (t, e, i) {
        e[vt] = M(t), d(i).bigHour = !0
    }), dt("hmm", function (t, e, i) {
        var n = t.length - 2;
        e[vt] = M(t.substr(0, n)), e[yt] = M(t.substr(n)), d(i).bigHour = !0
    }), dt("hmmss", function (t, e, i) {
        var n = t.length - 4, r = t.length - 2;
        e[vt] = M(t.substr(0, n)), e[yt] = M(t.substr(n, 2)), e[xt] = M(t.substr(r)), d(i).bigHour = !0
    }), dt("Hmm", function (t, e, i) {
        var n = t.length - 2;
        e[vt] = M(t.substr(0, n)), e[yt] = M(t.substr(n))
    }), dt("Hmmss", function (t, e, i) {
        var n = t.length - 4, r = t.length - 2;
        e[vt] = M(t.substr(0, n)), e[yt] = M(t.substr(n, 2)), e[xt] = M(t.substr(r))
    });
    var te, ee = Et("Hours", !0), ie = {
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        invalidDate: "Invalid date",
        ordinal: "%d",
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        months: Ot,
        monthsShort: Lt,
        week: {dow: 0, doy: 6},
        weekdays: Ft,
        weekdaysMin: Ut,
        weekdaysShort: Xt,
        meridiemParse: /[ap]\.?m?\.?/i
    }, ne = {}, re = {};

    function oe(t) {
        return t ? t.toLowerCase().replace("_", "-") : t
    }

    function ae(t) {
        var e = null;
        if (!ne[t] && "undefined" != typeof module && module && module.exports) try {
            e = te._abbr, require("./locale/" + t), se(e)
        } catch (t) {
        }
        return ne[t]
    }

    function se(t, e) {
        var i;
        return t && ((i = o(e) ? he(t) : le(t, e)) ? te = i : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), te._abbr
    }

    function le(t, e) {
        if (null === e) return delete ne[t], null;
        var i, n = ie;
        if (e.abbr = t, null != ne[t]) E("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = ne[t]._config; else if (null != e.parentLocale) if (null != ne[e.parentLocale]) n = ne[e.parentLocale]._config; else {
            if (null == (i = ae(e.parentLocale))) return re[e.parentLocale] || (re[e.parentLocale] = []), re[e.parentLocale].push({
                name: t,
                config: e
            }), null;
            n = i._config
        }
        return ne[t] = new P(D(n, e)), re[t] && re[t].forEach(function (t) {
            le(t.name, t.config)
        }), se(t), ne[t]
    }

    function he(t) {
        var e;
        if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return te;
        if (!n(t)) {
            if (e = ae(t)) return e;
            t = [t]
        }
        return function (t) {
            for (var e, i, n, r, o = 0; o < t.length;) {
                for (e = (r = oe(t[o]).split("-")).length, i = (i = oe(t[o + 1])) ? i.split("-") : null; 0 < e;) {
                    if (n = ae(r.slice(0, e).join("-"))) return n;
                    if (i && i.length >= e && A(r, i, !0) >= e - 1) break;
                    e--
                }
                o++
            }
            return te
        }(t)
    }

    function ce(t) {
        var e, i = t._a;
        return i && -2 === d(t).overflow && (e = i[gt] < 0 || 11 < i[gt] ? gt : i[mt] < 1 || i[mt] > Pt(i[pt], i[gt]) ? mt : i[vt] < 0 || 24 < i[vt] || 24 === i[vt] && (0 !== i[yt] || 0 !== i[xt] || 0 !== i[bt]) ? vt : i[yt] < 0 || 59 < i[yt] ? yt : i[xt] < 0 || 59 < i[xt] ? xt : i[bt] < 0 || 999 < i[bt] ? bt : -1, d(t)._overflowDayOfYear && (e < pt || mt < e) && (e = mt), d(t)._overflowWeeks && -1 === e && (e = Mt), d(t)._overflowWeekday && -1 === e && (e = At), d(t).overflow = e), t
    }

    function ue(t, e, i) {
        return null != t ? t : null != e ? e : i
    }

    function de(t) {
        var e, n, r, o, a, s = [];
        if (!t._d) {
            var l, h;
            for (l = t, h = new Date(i.now()), r = l._useUTC ? [h.getUTCFullYear(), h.getUTCMonth(), h.getUTCDate()] : [h.getFullYear(), h.getMonth(), h.getDate()], t._w && null == t._a[mt] && null == t._a[gt] && function (t) {
                var e, i, n, r, o, a, s, l;
                if (null != (e = t._w).GG || null != e.W || null != e.E) o = 1, a = 4, i = ue(e.GG, t._a[pt], Yt(Te(), 1, 4).year), n = ue(e.W, 1), ((r = ue(e.E, 1)) < 1 || 7 < r) && (l = !0); else {
                    o = t._locale._week.dow, a = t._locale._week.doy;
                    var h = Yt(Te(), o, a);
                    i = ue(e.gg, t._a[pt], h.year), n = ue(e.w, h.week), null != e.d ? ((r = e.d) < 0 || 6 < r) && (l = !0) : null != e.e ? (r = e.e + o, (e.e < 0 || 6 < e.e) && (l = !0)) : r = o
                }
                n < 1 || n > Gt(i, o, a) ? d(t)._overflowWeeks = !0 : null != l ? d(t)._overflowWeekday = !0 : (s = Ht(i, n, r, o, a), t._a[pt] = s.year, t._dayOfYear = s.dayOfYear)
            }(t), null != t._dayOfYear && (a = ue(t._a[pt], r[pt]), (t._dayOfYear > wt(a) || 0 === t._dayOfYear) && (d(t)._overflowDayOfYear = !0), n = jt(a, 0, t._dayOfYear), t._a[gt] = n.getUTCMonth(), t._a[mt] = n.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e) t._a[e] = s[e] = r[e];
            for (; e < 7; e++) t._a[e] = s[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];
            24 === t._a[vt] && 0 === t._a[yt] && 0 === t._a[xt] && 0 === t._a[bt] && (t._nextDay = !0, t._a[vt] = 0), t._d = (t._useUTC ? jt : function (t, e, i, n, r, o, a) {
                var s = new Date(t, e, i, n, r, o, a);
                return t < 100 && 0 <= t && isFinite(s.getFullYear()) && s.setFullYear(t), s
            }).apply(null, s), o = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[vt] = 24), t._w && void 0 !== t._w.d && t._w.d !== o && (d(t).weekdayMismatch = !0)
        }
    }

    var fe = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        pe = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        ge = /Z|[+-]\d\d(?::?\d\d)?/,
        me = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]],
        ve = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
        ye = /^\/?Date\((\-?\d+)/i;

    function xe(t) {
        var e, i, n, r, o, a, s = t._i, l = fe.exec(s) || pe.exec(s);
        if (l) {
            for (d(t).iso = !0, e = 0, i = me.length; e < i; e++) if (me[e][1].exec(l[1])) {
                r = me[e][0], n = !1 !== me[e][2];
                break
            }
            if (null == r) return void (t._isValid = !1);
            if (l[3]) {
                for (e = 0, i = ve.length; e < i; e++) if (ve[e][1].exec(l[3])) {
                    o = (l[2] || " ") + ve[e][0];
                    break
                }
                if (null == o) return void (t._isValid = !1)
            }
            if (!n && null != o) return void (t._isValid = !1);
            if (l[4]) {
                if (!ge.exec(l[4])) return void (t._isValid = !1);
                a = "Z"
            }
            t._f = r + (o || "") + (a || ""), we(t)
        } else t._isValid = !1
    }

    var be = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    var Me = {UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480};

    function Ae(t) {
        var e, i, n,
            r = be.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
        if (r) {
            var o = function (t, e, i, n, r, o) {
                var a = [function (t) {
                    var e = parseInt(t, 10);
                    return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e
                }(t), Lt.indexOf(e), parseInt(i, 10), parseInt(n, 10), parseInt(r, 10)];
                return o && a.push(parseInt(o, 10)), a
            }(r[4], r[3], r[2], r[5], r[6], r[7]);
            if (i = o, n = t, (e = r[1]) && Xt.indexOf(e) !== new Date(i[0], i[1], i[2]).getDay() && (d(n).weekdayMismatch = !0, !(n._isValid = !1))) return;
            t._a = o, t._tzm = function (t, e, i) {
                if (t) return Me[t];
                if (e) return 0;
                var n = parseInt(i, 10), r = n % 100;
                return (n - r) / 100 * 60 + r
            }(r[8], r[9], r[10]), t._d = jt.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), d(t).rfc2822 = !0
        } else t._isValid = !1
    }

    function we(t) {
        if (t._f !== i.ISO_8601) if (t._f !== i.RFC_2822) {
            t._a = [], d(t).empty = !0;
            var e, n, r, o, a, s, l, c, u = "" + t._i, f = u.length, p = 0;
            for (r = F(t._f, t._locale).match(B) || [], e = 0; e < r.length; e++) o = r[e], (n = (u.match(ht(o, t)) || [])[0]) && (0 < (a = u.substr(0, u.indexOf(n))).length && d(t).unusedInput.push(a), u = u.slice(u.indexOf(n) + n.length), p += n.length), H[o] ? (n ? d(t).empty = !1 : d(t).unusedTokens.push(o), s = o, c = t, null != (l = n) && h(ut, s) && ut[s](l, c._a, c, s)) : t._strict && !n && d(t).unusedTokens.push(o);
            d(t).charsLeftOver = f - p, 0 < u.length && d(t).unusedInput.push(u), t._a[vt] <= 12 && !0 === d(t).bigHour && 0 < t._a[vt] && (d(t).bigHour = void 0), d(t).parsedDateParts = t._a.slice(0), d(t).meridiem = t._meridiem, t._a[vt] = function (t, e, i) {
                var n;
                return null == i ? e : null != t.meridiemHour ? t.meridiemHour(e, i) : (null != t.isPM && ((n = t.isPM(i)) && e < 12 && (e += 12), n || 12 !== e || (e = 0)), e)
            }(t._locale, t._a[vt], t._meridiem), de(t), ce(t)
        } else Ae(t); else xe(t)
    }

    function ke(t) {
        var e, h, u, g, v = t._i, b = t._f;
        return t._locale = t._locale || he(t._l), null === v || void 0 === b && "" === v ? p({nullInput: !0}) : ("string" == typeof v && (t._i = v = t._locale.preparse(v)), x(v) ? new y(ce(v)) : (s(v) ? t._d = v : n(b) ? function (t) {
            var e, i, n, r, o;
            if (0 === t._f.length) return d(t).invalidFormat = !0, t._d = new Date(NaN);
            for (r = 0; r < t._f.length; r++) o = 0, e = m({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[r], we(e), f(e) && (o += d(e).charsLeftOver, o += 10 * d(e).unusedTokens.length, d(e).score = o, (null == n || o < n) && (n = o, i = e));
            c(t, i || e)
        }(t) : b ? we(t) : o(h = (e = t)._i) ? e._d = new Date(i.now()) : s(h) ? e._d = new Date(h.valueOf()) : "string" == typeof h ? (u = e, null === (g = ye.exec(u._i)) ? (xe(u), !1 === u._isValid && (delete u._isValid, Ae(u), !1 === u._isValid && (delete u._isValid, i.createFromInputFallback(u)))) : u._d = new Date(+g[1])) : n(h) ? (e._a = l(h.slice(0), function (t) {
            return parseInt(t, 10)
        }), de(e)) : r(h) ? function (t) {
            if (!t._d) {
                var e = N(t._i);
                t._a = l([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], function (t) {
                    return t && parseInt(t, 10)
                }), de(t)
            }
        }(e) : a(h) ? e._d = new Date(h) : i.createFromInputFallback(e), f(t) || (t._d = null), t))
    }

    function Se(t, e, i, o, a) {
        var s, l = {};
        return !0 !== i && !1 !== i || (o = i, i = void 0), (r(t) && function (t) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(t).length;
            var e;
            for (e in t) if (t.hasOwnProperty(e)) return !1;
            return !0
        }(t) || n(t) && 0 === t.length) && (t = void 0), l._isAMomentObject = !0, l._useUTC = l._isUTC = a, l._l = i, l._i = t, l._f = e, l._strict = o, (s = new y(ce(ke(l))))._nextDay && (s.add(1, "d"), s._nextDay = void 0), s
    }

    function Te(t, e, i, n) {
        return Se(t, e, i, n, !1)
    }

    i.createFromInputFallback = k("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (t) {
        t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
    }), i.ISO_8601 = function () {
    }, i.RFC_2822 = function () {
    };
    var Ee = k("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
            var t = Te.apply(null, arguments);
            return this.isValid() && t.isValid() ? t < this ? this : t : p()
        }),
        Ce = k("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
            var t = Te.apply(null, arguments);
            return this.isValid() && t.isValid() ? this < t ? this : t : p()
        });

    function De(t, e) {
        var i, r;
        if (1 === e.length && n(e[0]) && (e = e[0]), !e.length) return Te();
        for (i = e[0], r = 1; r < e.length; ++r) e[r].isValid() && !e[r][t](i) || (i = e[r]);
        return i
    }

    var Pe = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

    function _e(t) {
        var e = N(t), i = e.year || 0, n = e.quarter || 0, r = e.month || 0, o = e.week || e.isoWeek || 0,
            a = e.day || 0, s = e.hour || 0, l = e.minute || 0, h = e.second || 0, c = e.millisecond || 0;
        this._isValid = function (t) {
            for (var e in t) if (-1 === St.call(Pe, e) || null != t[e] && isNaN(t[e])) return !1;
            for (var i = !1, n = 0; n < Pe.length; ++n) if (t[Pe[n]]) {
                if (i) return !1;
                parseFloat(t[Pe[n]]) !== M(t[Pe[n]]) && (i = !0)
            }
            return !0
        }(e), this._milliseconds = +c + 1e3 * h + 6e4 * l + 1e3 * s * 60 * 60, this._days = +a + 7 * o, this._months = +r + 3 * n + 12 * i, this._data = {}, this._locale = he(), this._bubble()
    }

    function Oe(t) {
        return t instanceof _e
    }

    function Le(t) {
        return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t)
    }

    function Ne(t, e) {
        Y(t, 0, 0, function () {
            var t = this.utcOffset(), i = "+";
            return t < 0 && (t = -t, i = "-"), i + R(~~(t / 60), 2) + e + R(~~t % 60, 2)
        })
    }

    Ne("Z", ":"), Ne("ZZ", ""), lt("Z", ot), lt("ZZ", ot), dt(["Z", "ZZ"], function (t, e, i) {
        i._useUTC = !0, i._tzm = Ie(ot, t)
    });
    var ze = /([\+\-]|\d\d)/gi;

    function Ie(t, e) {
        var i = (e || "").match(t);
        if (null === i) return null;
        var n = ((i[i.length - 1] || []) + "").match(ze) || ["-", 0, 0], r = 60 * n[1] + M(n[2]);
        return 0 === r ? 0 : "+" === n[0] ? r : -r
    }

    function Re(t, e) {
        var n, r;
        return e._isUTC ? (n = e.clone(), r = (x(t) || s(t) ? t.valueOf() : Te(t).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + r), i.updateOffset(n, !1), n) : Te(t).local()
    }

    function Be(t) {
        return 15 * -Math.round(t._d.getTimezoneOffset() / 15)
    }

    function je() {
        return !!this.isValid() && this._isUTC && 0 === this._offset
    }

    i.updateOffset = function () {
    };
    var We = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
        He = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function Ye(t, e) {
        var i, n, r, o = t, s = null;
        return Oe(t) ? o = {
            ms: t._milliseconds,
            d: t._days,
            M: t._months
        } : a(t) ? (o = {}, e ? o[e] = t : o.milliseconds = t) : (s = We.exec(t)) ? (i = "-" === s[1] ? -1 : 1, o = {
            y: 0,
            d: M(s[mt]) * i,
            h: M(s[vt]) * i,
            m: M(s[yt]) * i,
            s: M(s[xt]) * i,
            ms: M(Le(1e3 * s[bt])) * i
        }) : (s = He.exec(t)) ? (i = "-" === s[1] ? -1 : 1, o = {
            y: Ge(s[2], i),
            M: Ge(s[3], i),
            w: Ge(s[4], i),
            d: Ge(s[5], i),
            h: Ge(s[6], i),
            m: Ge(s[7], i),
            s: Ge(s[8], i)
        }) : null == o ? o = {} : "object" == typeof o && ("from" in o || "to" in o) && (r = function (t, e) {
            var i;
            return t.isValid() && e.isValid() ? (e = Re(e, t), t.isBefore(e) ? i = Fe(t, e) : ((i = Fe(e, t)).milliseconds = -i.milliseconds, i.months = -i.months), i) : {
                milliseconds: 0,
                months: 0
            }
        }(Te(o.from), Te(o.to)), (o = {}).ms = r.milliseconds, o.M = r.months), n = new _e(o), Oe(t) && h(t, "_locale") && (n._locale = t._locale), n
    }

    function Ge(t, e) {
        var i = t && parseFloat(t.replace(",", "."));
        return (isNaN(i) ? 0 : i) * e
    }

    function Fe(t, e) {
        var i = {milliseconds: 0, months: 0};
        return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i
    }

    function Xe(t, e) {
        return function (i, n) {
            var r;
            return null === n || isNaN(+n) || (E(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = i, i = n, n = r), Ue(this, Ye(i = "string" == typeof i ? +i : i, n), t), this
        }
    }

    function Ue(t, e, n, r) {
        var o = e._milliseconds, a = Le(e._days), s = Le(e._months);
        t.isValid() && (r = null == r || r, s && Nt(t, Ct(t, "Month") + s * n), a && Dt(t, "Date", Ct(t, "Date") + a * n), o && t._d.setTime(t._d.valueOf() + o * n), r && i.updateOffset(t, a || s))
    }

    Ye.fn = _e.prototype, Ye.invalid = function () {
        return Ye(NaN)
    };
    var qe = Xe(1, "add"), $e = Xe(-1, "subtract");

    function Ve(t, e) {
        var i = 12 * (e.year() - t.year()) + (e.month() - t.month()), n = t.clone().add(i, "months");
        return -(i + (e - n < 0 ? (e - n) / (n - t.clone().add(i - 1, "months")) : (e - n) / (t.clone().add(i + 1, "months") - n))) || 0
    }

    function Ke(t) {
        var e;
        return void 0 === t ? this._locale._abbr : (null != (e = he(t)) && (this._locale = e), this)
    }

    i.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", i.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var Ze = k("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
        return void 0 === t ? this.localeData() : this.locale(t)
    });

    function Je() {
        return this._locale
    }

    function Qe(t, e) {
        Y(0, [t, t.length], 0, e)
    }

    function ti(t, e, i, n, r) {
        var o;
        return null == t ? Yt(this, n, r).year : ((o = Gt(t, n, r)) < e && (e = o), (function (t, e, i, n, r) {
            var o = Ht(t, e, i, n, r), a = jt(o.year, 0, o.dayOfYear);
            return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
        }).call(this, t, e, i, n, r))
    }

    Y(0, ["gg", 2], 0, function () {
        return this.weekYear() % 100
    }), Y(0, ["GG", 2], 0, function () {
        return this.isoWeekYear() % 100
    }), Qe("gggg", "weekYear"), Qe("ggggg", "weekYear"), Qe("GGGG", "isoWeekYear"), Qe("GGGGG", "isoWeekYear"), O("weekYear", "gg"), O("isoWeekYear", "GG"), I("weekYear", 1), I("isoWeekYear", 1), lt("G", nt), lt("g", nt), lt("GG", K, U), lt("gg", K, U), lt("GGGG", tt, $), lt("gggg", tt, $), lt("GGGGG", et, V), lt("ggggg", et, V), ft(["gggg", "ggggg", "GGGG", "GGGGG"], function (t, e, i, n) {
        e[n.substr(0, 2)] = M(t)
    }), ft(["gg", "GG"], function (t, e, n, r) {
        e[r] = i.parseTwoDigitYear(t)
    }), Y("Q", 0, "Qo", "quarter"), O("quarter", "Q"), I("quarter", 7), lt("Q", X), dt("Q", function (t, e) {
        e[gt] = 3 * (M(t) - 1)
    }), Y("D", ["DD", 2], "Do", "date"), O("date", "D"), I("date", 9), lt("D", K), lt("DD", K, U), lt("Do", function (t, e) {
        return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
    }), dt(["D", "DD"], mt), dt("Do", function (t, e) {
        e[mt] = M(t.match(K)[0])
    });
    var ei = Et("Date", !0);
    Y("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), O("dayOfYear", "DDD"), I("dayOfYear", 4), lt("DDD", Q), lt("DDDD", q), dt(["DDD", "DDDD"], function (t, e, i) {
        i._dayOfYear = M(t)
    }), Y("m", ["mm", 2], 0, "minute"), O("minute", "m"), I("minute", 14), lt("m", K), lt("mm", K, U), dt(["m", "mm"], yt);
    var ii = Et("Minutes", !1);
    Y("s", ["ss", 2], 0, "second"), O("second", "s"), I("second", 15), lt("s", K), lt("ss", K, U), dt(["s", "ss"], xt);
    var ni, ri = Et("Seconds", !1);
    for (Y("S", 0, 0, function () {
        return ~~(this.millisecond() / 100)
    }), Y(0, ["SS", 2], 0, function () {
        return ~~(this.millisecond() / 10)
    }), Y(0, ["SSS", 3], 0, "millisecond"), Y(0, ["SSSS", 4], 0, function () {
        return 10 * this.millisecond()
    }), Y(0, ["SSSSS", 5], 0, function () {
        return 100 * this.millisecond()
    }), Y(0, ["SSSSSS", 6], 0, function () {
        return 1e3 * this.millisecond()
    }), Y(0, ["SSSSSSS", 7], 0, function () {
        return 1e4 * this.millisecond()
    }), Y(0, ["SSSSSSSS", 8], 0, function () {
        return 1e5 * this.millisecond()
    }), Y(0, ["SSSSSSSSS", 9], 0, function () {
        return 1e6 * this.millisecond()
    }), O("millisecond", "ms"), I("millisecond", 16), lt("S", Q, X), lt("SS", Q, U), lt("SSS", Q, q), ni = "SSSS"; ni.length <= 9; ni += "S") lt(ni, it);

    function oi(t, e) {
        e[bt] = M(1e3 * ("0." + t))
    }

    for (ni = "S"; ni.length <= 9; ni += "S") dt(ni, oi);
    var ai = Et("Milliseconds", !1);
    Y("z", 0, 0, "zoneAbbr"), Y("zz", 0, 0, "zoneName");
    var si = y.prototype;

    function li(t) {
        return t
    }

    si.add = qe, si.calendar = function (t, e) {
        var n = t || Te(), r = Re(n, this).startOf("day"), o = i.calendarFormat(this, r) || "sameElse",
            a = e && (C(e[o]) ? e[o].call(this, n) : e[o]);
        return this.format(a || this.localeData().calendar(o, this, Te(n)))
    }, si.clone = function () {
        return new y(this)
    }, si.diff = function (t, e, i) {
        var n, r, o;
        if (!this.isValid()) return NaN;
        if (!(n = Re(t, this)).isValid()) return NaN;
        switch (r = 6e4 * (n.utcOffset() - this.utcOffset()), e = L(e)) {
            case"year":
                o = Ve(this, n) / 12;
                break;
            case"month":
                o = Ve(this, n);
                break;
            case"quarter":
                o = Ve(this, n) / 3;
                break;
            case"second":
                o = (this - n) / 1e3;
                break;
            case"minute":
                o = (this - n) / 6e4;
                break;
            case"hour":
                o = (this - n) / 36e5;
                break;
            case"day":
                o = (this - n - r) / 864e5;
                break;
            case"week":
                o = (this - n - r) / 6048e5;
                break;
            default:
                o = this - n
        }
        return i ? o : b(o)
    }, si.endOf = function (t) {
        return void 0 === (t = L(t)) || "millisecond" === t ? this : ("date" === t && (t = "day"), this.startOf(t).add(1, "isoWeek" === t ? "week" : t).subtract(1, "ms"))
    }, si.format = function (t) {
        t || (t = this.isUtc() ? i.defaultFormatUtc : i.defaultFormat);
        var e = G(this, t);
        return this.localeData().postformat(e)
    }, si.from = function (t, e) {
        return this.isValid() && (x(t) && t.isValid() || Te(t).isValid()) ? Ye({
            to: this,
            from: t
        }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
    }, si.fromNow = function (t) {
        return this.from(Te(), t)
    }, si.to = function (t, e) {
        return this.isValid() && (x(t) && t.isValid() || Te(t).isValid()) ? Ye({
            from: this,
            to: t
        }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
    }, si.toNow = function (t) {
        return this.to(Te(), t)
    }, si.get = function (t) {
        return C(this[t = L(t)]) ? this[t]() : this
    }, si.invalidAt = function () {
        return d(this).overflow
    }, si.isAfter = function (t, e) {
        var i = x(t) ? t : Te(t);
        return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf())
    }, si.isBefore = function (t, e) {
        var i = x(t) ? t : Te(t);
        return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf())
    }, si.isBetween = function (t, e, i, n) {
        var r = x(t) ? t : Te(t), o = x(e) ? e : Te(e);
        return !!(this.isValid() && r.isValid() && o.isValid()) && ("(" === (n = n || "()")[0] ? this.isAfter(r, i) : !this.isBefore(r, i)) && (")" === n[1] ? this.isBefore(o, i) : !this.isAfter(o, i))
    }, si.isSame = function (t, e) {
        var i, n = x(t) ? t : Te(t);
        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf()))
    }, si.isSameOrAfter = function (t, e) {
        return this.isSame(t, e) || this.isAfter(t, e)
    }, si.isSameOrBefore = function (t, e) {
        return this.isSame(t, e) || this.isBefore(t, e)
    }, si.isValid = function () {
        return f(this)
    }, si.lang = Ze, si.locale = Ke, si.localeData = Je, si.max = Ce, si.min = Ee, si.parsingFlags = function () {
        return c({}, d(this))
    }, si.set = function (t, e) {
        if ("object" == typeof t) for (var i = function (t) {
            var e = [];
            for (var i in t) e.push({unit: i, priority: z[i]});
            return e.sort(function (t, e) {
                return t.priority - e.priority
            }), e
        }(t = N(t)), n = 0; n < i.length; n++) this[i[n].unit](t[i[n].unit]); else if (C(this[t = L(t)])) return this[t](e);
        return this
    }, si.startOf = function (t) {
        switch (t = L(t)) {
            case"year":
                this.month(0);
            case"quarter":
            case"month":
                this.date(1);
            case"week":
            case"isoWeek":
            case"day":
            case"date":
                this.hours(0);
            case"hour":
                this.minutes(0);
            case"minute":
                this.seconds(0);
            case"second":
                this.milliseconds(0)
        }
        return "week" === t && this.weekday(0), "isoWeek" === t && this.isoWeekday(1), "quarter" === t && this.month(3 * Math.floor(this.month() / 3)), this
    }, si.subtract = $e, si.toArray = function () {
        var t = this;
        return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]
    }, si.toObject = function () {
        var t = this;
        return {
            years: t.year(),
            months: t.month(),
            date: t.date(),
            hours: t.hours(),
            minutes: t.minutes(),
            seconds: t.seconds(),
            milliseconds: t.milliseconds()
        }
    }, si.toDate = function () {
        return new Date(this.valueOf())
    }, si.toISOString = function (t) {
        if (!this.isValid()) return null;
        var e = !0 !== t, i = e ? this.clone().utc() : this;
        return i.year() < 0 || 9999 < i.year() ? G(i, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : C(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", G(i, "Z")) : G(i, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
    }, si.inspect = function () {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var t = "moment", e = "";
        this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
        var i = "[" + t + '("]', n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = e + '[")]';
        return this.format(i + n + "-MM-DD[T]HH:mm:ss.SSS" + r)
    }, si.toJSON = function () {
        return this.isValid() ? this.toISOString() : null
    }, si.toString = function () {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
    }, si.unix = function () {
        return Math.floor(this.valueOf() / 1e3)
    }, si.valueOf = function () {
        return this._d.valueOf() - 6e4 * (this._offset || 0)
    }, si.creationData = function () {
        return {input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict}
    }, si.year = Tt, si.isLeapYear = function () {
        return kt(this.year())
    }, si.weekYear = function (t) {
        return ti.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
    }, si.isoWeekYear = function (t) {
        return ti.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
    }, si.quarter = si.quarters = function (t) {
        return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3)
    }, si.month = zt, si.daysInMonth = function () {
        return Pt(this.year(), this.month())
    }, si.week = si.weeks = function (t) {
        var e = this.localeData().week(this);
        return null == t ? e : this.add(7 * (t - e), "d")
    }, si.isoWeek = si.isoWeeks = function (t) {
        var e = Yt(this, 1, 4).week;
        return null == t ? e : this.add(7 * (t - e), "d")
    }, si.weeksInYear = function () {
        var t = this.localeData()._week;
        return Gt(this.year(), t.dow, t.doy)
    }, si.isoWeeksInYear = function () {
        return Gt(this.year(), 1, 4)
    }, si.date = ei, si.day = si.days = function (t) {
        if (!this.isValid()) return null != t ? this : NaN;
        var e, i, n = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != t ? (e = t, i = this.localeData(), t = "string" != typeof e ? e : isNaN(e) ? "number" == typeof (e = i.weekdaysParse(e)) ? e : null : parseInt(e, 10), this.add(t - n, "d")) : n
    }, si.weekday = function (t) {
        if (!this.isValid()) return null != t ? this : NaN;
        var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == t ? e : this.add(t - e, "d")
    }, si.isoWeekday = function (t) {
        if (!this.isValid()) return null != t ? this : NaN;
        if (null == t) return this.day() || 7;
        var e, i,
            n = (e = t, i = this.localeData(), "string" == typeof e ? i.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e);
        return this.day(this.day() % 7 ? n : n - 7)
    }, si.dayOfYear = function (t) {
        var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == t ? e : this.add(t - e, "d")
    }, si.hour = si.hours = ee, si.minute = si.minutes = ii, si.second = si.seconds = ri, si.millisecond = si.milliseconds = ai, si.utcOffset = function (t, e, n) {
        var r, o = this._offset || 0;
        if (!this.isValid()) return null != t ? this : NaN;
        if (null == t) return this._isUTC ? o : Be(this);
        if ("string" == typeof t) {
            if (null === (t = Ie(ot, t))) return this
        } else Math.abs(t) < 16 && !n && (t *= 60);
        return !this._isUTC && e && (r = Be(this)), this._offset = t, this._isUTC = !0, null != r && this.add(r, "m"), o !== t && (!e || this._changeInProgress ? Ue(this, Ye(t - o, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, i.updateOffset(this, !0), this._changeInProgress = null)), this
    }, si.utc = function (t) {
        return this.utcOffset(0, t)
    }, si.local = function (t) {
        return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Be(this), "m")), this
    }, si.parseZone = function () {
        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
            var t = Ie(rt, this._i);
            null != t ? this.utcOffset(t) : this.utcOffset(0, !0)
        }
        return this
    }, si.hasAlignedHourOffset = function (t) {
        return !!this.isValid() && (t = t ? Te(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0)
    }, si.isDST = function () {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
    }, si.isLocal = function () {
        return !!this.isValid() && !this._isUTC
    }, si.isUtcOffset = function () {
        return !!this.isValid() && this._isUTC
    }, si.isUtc = je, si.isUTC = je, si.zoneAbbr = function () {
        return this._isUTC ? "UTC" : ""
    }, si.zoneName = function () {
        return this._isUTC ? "Coordinated Universal Time" : ""
    }, si.dates = k("dates accessor is deprecated. Use date instead.", ei), si.months = k("months accessor is deprecated. Use month instead", zt), si.years = k("years accessor is deprecated. Use year instead", Tt), si.zone = k("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (t, e) {
        return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset()
    }), si.isDSTShifted = k("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
        if (!o(this._isDSTShifted)) return this._isDSTShifted;
        var t = {};
        if (m(t, this), (t = ke(t))._a) {
            var e = t._isUTC ? u(t._a) : Te(t._a);
            this._isDSTShifted = this.isValid() && 0 < A(t._a, e.toArray())
        } else this._isDSTShifted = !1;
        return this._isDSTShifted
    });
    var hi = P.prototype;

    function ci(t, e, i, n) {
        var r = he(), o = u().set(n, e);
        return r[i](o, t)
    }

    function ui(t, e, i) {
        if (a(t) && (e = t, t = void 0), t = t || "", null != e) return ci(t, e, i, "month");
        var n, r = [];
        for (n = 0; n < 12; n++) r[n] = ci(t, n, i, "month");
        return r
    }

    function di(t, e, i, n) {
        "boolean" == typeof t ? a(e) && (i = e, e = void 0) : (e = t, t = !1, a(i = e) && (i = e, e = void 0)), e = e || "";
        var r, o = he(), s = t ? o._week.dow : 0;
        if (null != i) return ci(e, (i + s) % 7, n, "day");
        var l = [];
        for (r = 0; r < 7; r++) l[r] = ci(e, (r + s) % 7, n, "day");
        return l
    }

    hi.calendar = function (t, e, i) {
        var n = this._calendar[t] || this._calendar.sameElse;
        return C(n) ? n.call(e, i) : n
    }, hi.longDateFormat = function (t) {
        var e = this._longDateFormat[t], i = this._longDateFormat[t.toUpperCase()];
        return e || !i ? e : (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, function (t) {
            return t.slice(1)
        }), this._longDateFormat[t])
    }, hi.invalidDate = function () {
        return this._invalidDate
    }, hi.ordinal = function (t) {
        return this._ordinal.replace("%d", t)
    }, hi.preparse = li, hi.postformat = li, hi.relativeTime = function (t, e, i, n) {
        var r = this._relativeTime[i];
        return C(r) ? r(t, e, i, n) : r.replace(/%d/i, t)
    }, hi.pastFuture = function (t, e) {
        var i = this._relativeTime[0 < t ? "future" : "past"];
        return C(i) ? i(e) : i.replace(/%s/i, e)
    }, hi.set = function (t) {
        var e, i;
        for (i in t) C(e = t[i]) ? this[i] = e : this["_" + i] = e;
        this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
    }, hi.months = function (t, e) {
        return t ? n(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || _t).test(e) ? "format" : "standalone"][t.month()] : n(this._months) ? this._months : this._months.standalone
    }, hi.monthsShort = function (t, e) {
        return t ? n(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[_t.test(e) ? "format" : "standalone"][t.month()] : n(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
    }, hi.monthsParse = function (t, e, i) {
        var n, r, o;
        if (this._monthsParseExact) return (function (t, e, i) {
            var n, r, o, a = t.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n) o = u([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(o, "").toLocaleLowerCase(), this._longMonthsParse[n] = this.months(o, "").toLocaleLowerCase();
            return i ? "MMM" === e ? -1 !== (r = St.call(this._shortMonthsParse, a)) ? r : null : -1 !== (r = St.call(this._longMonthsParse, a)) ? r : null : "MMM" === e ? -1 !== (r = St.call(this._shortMonthsParse, a)) ? r : -1 !== (r = St.call(this._longMonthsParse, a)) ? r : null : -1 !== (r = St.call(this._longMonthsParse, a)) ? r : -1 !== (r = St.call(this._shortMonthsParse, a)) ? r : null
        }).call(this, t, e, i);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
            if (r = u([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp("^" + this.months(r, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(r, "").replace(".", "") + "$", "i")), i || this._monthsParse[n] || (o = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[n] = new RegExp(o.replace(".", ""), "i")), i && "MMMM" === e && this._longMonthsParse[n].test(t)) return n;
            if (i && "MMM" === e && this._shortMonthsParse[n].test(t)) return n;
            if (!i && this._monthsParse[n].test(t)) return n
        }
    }, hi.monthsRegex = function (t) {
        return this._monthsParseExact ? (h(this, "_monthsRegex") || Bt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (h(this, "_monthsRegex") || (this._monthsRegex = Rt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex)
    }, hi.monthsShortRegex = function (t) {
        return this._monthsParseExact ? (h(this, "_monthsRegex") || Bt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (h(this, "_monthsShortRegex") || (this._monthsShortRegex = It), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex)
    }, hi.week = function (t) {
        return Yt(t, this._week.dow, this._week.doy).week
    }, hi.firstDayOfYear = function () {
        return this._week.doy
    }, hi.firstDayOfWeek = function () {
        return this._week.dow
    }, hi.weekdays = function (t, e) {
        return t ? n(this._weekdays) ? this._weekdays[t.day()] : this._weekdays[this._weekdays.isFormat.test(e) ? "format" : "standalone"][t.day()] : n(this._weekdays) ? this._weekdays : this._weekdays.standalone
    }, hi.weekdaysMin = function (t) {
        return t ? this._weekdaysMin[t.day()] : this._weekdaysMin
    }, hi.weekdaysShort = function (t) {
        return t ? this._weekdaysShort[t.day()] : this._weekdaysShort
    }, hi.weekdaysParse = function (t, e, i) {
        var n, r, o;
        if (this._weekdaysParseExact) return (function (t, e, i) {
            var n, r, o, a = t.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n) o = u([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(o, "").toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(o, "").toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(o, "").toLocaleLowerCase();
            return i ? "dddd" === e ? -1 !== (r = St.call(this._weekdaysParse, a)) ? r : null : "ddd" === e ? -1 !== (r = St.call(this._shortWeekdaysParse, a)) ? r : null : -1 !== (r = St.call(this._minWeekdaysParse, a)) ? r : null : "dddd" === e ? -1 !== (r = St.call(this._weekdaysParse, a)) ? r : -1 !== (r = St.call(this._shortWeekdaysParse, a)) ? r : -1 !== (r = St.call(this._minWeekdaysParse, a)) ? r : null : "ddd" === e ? -1 !== (r = St.call(this._shortWeekdaysParse, a)) ? r : -1 !== (r = St.call(this._weekdaysParse, a)) ? r : -1 !== (r = St.call(this._minWeekdaysParse, a)) ? r : null : -1 !== (r = St.call(this._minWeekdaysParse, a)) ? r : -1 !== (r = St.call(this._weekdaysParse, a)) ? r : -1 !== (r = St.call(this._shortWeekdaysParse, a)) ? r : null
        }).call(this, t, e, i);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
            if (r = u([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp("^" + this.weekdays(r, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[n] = new RegExp("^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[n] = new RegExp("^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[n] || (o = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[n] = new RegExp(o.replace(".", ""), "i")), i && "dddd" === e && this._fullWeekdaysParse[n].test(t)) return n;
            if (i && "ddd" === e && this._shortWeekdaysParse[n].test(t)) return n;
            if (i && "dd" === e && this._minWeekdaysParse[n].test(t)) return n;
            if (!i && this._weekdaysParse[n].test(t)) return n
        }
    }, hi.weekdaysRegex = function (t) {
        return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Kt.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (h(this, "_weekdaysRegex") || (this._weekdaysRegex = qt), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex)
    }, hi.weekdaysShortRegex = function (t) {
        return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Kt.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (h(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = $t), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
    }, hi.weekdaysMinRegex = function (t) {
        return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Kt.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (h(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Vt), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
    }, hi.isPM = function (t) {
        return "p" === (t + "").toLowerCase().charAt(0)
    }, hi.meridiem = function (t, e, i) {
        return 11 < t ? i ? "pm" : "PM" : i ? "am" : "AM"
    }, se("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (t) {
            var e = t % 10;
            return t + (1 === M(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th")
        }
    }), i.lang = k("moment.lang is deprecated. Use moment.locale instead.", se), i.langData = k("moment.langData is deprecated. Use moment.localeData instead.", he);
    var fi = Math.abs;

    function pi(t, e, i, n) {
        var r = Ye(e, i);
        return t._milliseconds += n * r._milliseconds, t._days += n * r._days, t._months += n * r._months, t._bubble()
    }

    function gi(t) {
        return t < 0 ? Math.floor(t) : Math.ceil(t)
    }

    function mi(t) {
        return 4800 * t / 146097
    }

    function vi(t) {
        return 146097 * t / 4800
    }

    function yi(t) {
        return function () {
            return this.as(t)
        }
    }

    var xi = yi("ms"), bi = yi("s"), Mi = yi("m"), Ai = yi("h"), wi = yi("d"), ki = yi("w"), Si = yi("M"), Ti = yi("y");

    function Ei(t) {
        return function () {
            return this.isValid() ? this._data[t] : NaN
        }
    }

    var Ci = Ei("milliseconds"), Di = Ei("seconds"), Pi = Ei("minutes"), _i = Ei("hours"), Oi = Ei("days"),
        Li = Ei("months"), Ni = Ei("years"), zi = Math.round, Ii = {ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11},
        Ri = Math.abs;

    function Bi(t) {
        return (0 < t) - (t < 0) || +t
    }

    function ji() {
        if (!this.isValid()) return this.localeData().invalidDate();
        var t, e, i = Ri(this._milliseconds) / 1e3, n = Ri(this._days), r = Ri(this._months);
        e = b((t = b(i / 60)) / 60), i %= 60, t %= 60;
        var o = b(r / 12), a = r %= 12, s = n, l = e, h = t, c = i ? i.toFixed(3).replace(/\.?0+$/, "") : "",
            u = this.asSeconds();
        if (!u) return "P0D";
        var d = u < 0 ? "-" : "", f = Bi(this._months) !== Bi(u) ? "-" : "", p = Bi(this._days) !== Bi(u) ? "-" : "",
            g = Bi(this._milliseconds) !== Bi(u) ? "-" : "";
        return d + "P" + (o ? f + o + "Y" : "") + (a ? f + a + "M" : "") + (s ? p + s + "D" : "") + (l || h || c ? "T" : "") + (l ? g + l + "H" : "") + (h ? g + h + "M" : "") + (c ? g + c + "S" : "")
    }

    var Wi = _e.prototype;
    return Wi.isValid = function () {
        return this._isValid
    }, Wi.abs = function () {
        var t = this._data;
        return this._milliseconds = fi(this._milliseconds), this._days = fi(this._days), this._months = fi(this._months), t.milliseconds = fi(t.milliseconds), t.seconds = fi(t.seconds), t.minutes = fi(t.minutes), t.hours = fi(t.hours), t.months = fi(t.months), t.years = fi(t.years), this
    }, Wi.add = function (t, e) {
        return pi(this, t, e, 1)
    }, Wi.subtract = function (t, e) {
        return pi(this, t, e, -1)
    }, Wi.as = function (t) {
        if (!this.isValid()) return NaN;
        var e, i, n = this._milliseconds;
        if ("month" === (t = L(t)) || "year" === t) return e = this._days + n / 864e5, i = this._months + mi(e), "month" === t ? i : i / 12;
        switch (e = this._days + Math.round(vi(this._months)), t) {
            case"week":
                return e / 7 + n / 6048e5;
            case"day":
                return e + n / 864e5;
            case"hour":
                return 24 * e + n / 36e5;
            case"minute":
                return 1440 * e + n / 6e4;
            case"second":
                return 86400 * e + n / 1e3;
            case"millisecond":
                return Math.floor(864e5 * e) + n;
            default:
                throw new Error("Unknown unit " + t)
        }
    }, Wi.asMilliseconds = xi, Wi.asSeconds = bi, Wi.asMinutes = Mi, Wi.asHours = Ai, Wi.asDays = wi, Wi.asWeeks = ki, Wi.asMonths = Si, Wi.asYears = Ti, Wi.valueOf = function () {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * M(this._months / 12) : NaN
    }, Wi._bubble = function () {
        var t, e, i, n, r, o = this._milliseconds, a = this._days, s = this._months, l = this._data;
        return 0 <= o && 0 <= a && 0 <= s || o <= 0 && a <= 0 && s <= 0 || (o += 864e5 * gi(vi(s) + a), s = a = 0), l.milliseconds = o % 1e3, t = b(o / 1e3), l.seconds = t % 60, e = b(t / 60), l.minutes = e % 60, i = b(e / 60), l.hours = i % 24, s += r = b(mi(a += b(i / 24))), a -= gi(vi(r)), n = b(s / 12), s %= 12, l.days = a, l.months = s, l.years = n, this
    }, Wi.clone = function () {
        return Ye(this)
    }, Wi.get = function (t) {
        return t = L(t), this.isValid() ? this[t + "s"]() : NaN
    }, Wi.milliseconds = Ci, Wi.seconds = Di, Wi.minutes = Pi, Wi.hours = _i, Wi.days = Oi, Wi.weeks = function () {
        return b(this.days() / 7)
    }, Wi.months = Li, Wi.years = Ni, Wi.humanize = function (t) {
        if (!this.isValid()) return this.localeData().invalidDate();
        var e, i, n, r, o, a, s, l, h, c, u = this.localeData(),
            d = (e = !t, i = u, n = Ye(this).abs(), r = zi(n.as("s")), o = zi(n.as("m")), a = zi(n.as("h")), s = zi(n.as("d")), l = zi(n.as("M")), h = zi(n.as("y")), (c = r <= Ii.ss && ["s", r] || r < Ii.s && ["ss", r] || o <= 1 && ["m"] || o < Ii.m && ["mm", o] || a <= 1 && ["h"] || a < Ii.h && ["hh", a] || s <= 1 && ["d"] || s < Ii.d && ["dd", s] || l <= 1 && ["M"] || l < Ii.M && ["MM", l] || h <= 1 && ["y"] || ["yy", h])[2] = e, c[3] = 0 < +this, c[4] = i, (function (t, e, i, n, r) {
                return r.relativeTime(e || 1, !!i, t, n)
            }).apply(null, c));
        return t && (d = u.pastFuture(+this, d)), u.postformat(d)
    }, Wi.toISOString = ji, Wi.toString = ji, Wi.toJSON = ji, Wi.locale = Ke, Wi.localeData = Je, Wi.toIsoString = k("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", ji), Wi.lang = Ze, Y("X", 0, 0, "unix"), Y("x", 0, 0, "valueOf"), lt("x", nt), lt("X", /[+-]?\d+(\.\d{1,3})?/), dt("X", function (t, e, i) {
        i._d = new Date(1e3 * parseFloat(t, 10))
    }), dt("x", function (t, e, i) {
        i._d = new Date(M(t))
    }), i.version = "2.23.0", t = Te, i.fn = si, i.min = function () {
        return De("isBefore", [].slice.call(arguments, 0))
    }, i.max = function () {
        return De("isAfter", [].slice.call(arguments, 0))
    }, i.now = function () {
        return Date.now ? Date.now() : +new Date
    }, i.utc = u, i.unix = function (t) {
        return Te(1e3 * t)
    }, i.months = function (t, e) {
        return ui(t, e, "months")
    }, i.isDate = s, i.locale = se, i.invalid = p, i.duration = Ye, i.isMoment = x, i.weekdays = function (t, e, i) {
        return di(t, e, i, "weekdays")
    }, i.parseZone = function () {
        return Te.apply(null, arguments).parseZone()
    }, i.localeData = he, i.isDuration = Oe, i.monthsShort = function (t, e) {
        return ui(t, e, "monthsShort")
    }, i.weekdaysMin = function (t, e, i) {
        return di(t, e, i, "weekdaysMin")
    }, i.defineLocale = le, i.updateLocale = function (t, e) {
        if (null != e) {
            var i, n, r = ie;
            null != (n = ae(t)) && (r = n._config), (i = new P(e = D(r, e))).parentLocale = ne[t], ne[t] = i, se(t)
        } else null != ne[t] && (null != ne[t].parentLocale ? ne[t] = ne[t].parentLocale : null != ne[t] && delete ne[t]);
        return ne[t]
    }, i.locales = function () {
        return S(ne)
    }, i.weekdaysShort = function (t, e, i) {
        return di(t, e, i, "weekdaysShort")
    }, i.normalizeUnits = L, i.relativeTimeRounding = function (t) {
        return void 0 === t ? zi : "function" == typeof t && (zi = t, !0)
    }, i.relativeTimeThreshold = function (t, e) {
        return void 0 !== Ii[t] && (void 0 === e ? Ii[t] : (Ii[t] = e, "s" === t && (Ii.ss = e - 1), !0))
    }, i.calendarFormat = function (t, e) {
        var i = t.diff(e, "days", !0);
        return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse"
    }, i.prototype = si, i.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
    }, i
}), function (t, e) {
    "use strict";
    "object" == typeof module && module.exports ? module.exports = e(require("moment")) : "function" == typeof define && define.amd ? define(["moment"], e) : e(t.moment)
}(this, function (t) {
    "use strict";
    var e, i = {}, n = {}, r = {}, o = {};
    t && "string" == typeof t.version || T("Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/");
    var a = t.version.split("."), s = +a[0], l = +a[1];

    function h(t) {
        return 96 < t ? t - 87 : 64 < t ? t - 29 : t - 48
    }

    function c(t) {
        var e = 0, i = t.split("."), n = i[0], r = i[1] || "", o = 1, a = 0, s = 1;
        for (45 === t.charCodeAt(0) && (s = -(e = 1)); e < n.length; e++) a = 60 * a + h(n.charCodeAt(e));
        for (e = 0; e < r.length; e++) o /= 60, a += h(r.charCodeAt(e)) * o;
        return a * s
    }

    function u(t) {
        for (var e = 0; e < t.length; e++) t[e] = c(t[e])
    }

    function d(t, e) {
        var i, n = [];
        for (i = 0; i < e.length; i++) n[i] = t[e[i]];
        return n
    }

    function f(t) {
        var e = t.split("|"), i = e[2].split(" "), n = e[3].split(""), r = e[4].split(" ");
        return u(i), u(n), u(r), function (t, e) {
            for (var i = 0; i < e; i++) t[i] = Math.round((t[i - 1] || 0) + 6e4 * t[i]);
            t[e - 1] = 1 / 0
        }(r, n.length), {name: e[0], abbrs: d(e[1].split(" "), n), offsets: d(i, n), untils: r, population: 0 | e[5]}
    }

    function p(t) {
        t && this._set(f(t))
    }

    function g(t) {
        var e = t.toTimeString(), i = e.match(/\([a-z ]+\)/i);
        "GMT" === (i = i && i[0] ? (i = i[0].match(/[A-Z]/g)) ? i.join("") : void 0 : (i = e.match(/[A-Z]{3,5}/g)) ? i[0] : void 0) && (i = void 0), this.at = +t, this.abbr = i, this.offset = t.getTimezoneOffset()
    }

    function m(t) {
        this.zone = t, this.offsetScore = 0, this.abbrScore = 0
    }

    function v(t, e) {
        for (var i, n; n = 6e4 * ((e.at - t.at) / 12e4 | 0);) (i = new g(new Date(t.at + n))).offset === t.offset ? t = i : e = i;
        return t
    }

    function y(t, e) {
        return t.offsetScore !== e.offsetScore ? t.offsetScore - e.offsetScore : t.abbrScore !== e.abbrScore ? t.abbrScore - e.abbrScore : e.zone.population - t.zone.population
    }

    function x(t, e) {
        var i, n;
        for (u(e), i = 0; i < e.length; i++) n = e[i], o[n] = o[n] || {}, o[n][t] = !0
    }

    function b(t) {
        return (t || "").toLowerCase().replace(/\//g, "_")
    }

    function M(t) {
        var e, n, o, a;
        for ("string" == typeof t && (t = [t]), e = 0; e < t.length; e++) a = b(n = (o = t[e].split("|"))[0]), i[a] = t[e], r[a] = n, x(a, o[2].split(" "))
    }

    function A(t, e) {
        t = b(t);
        var o, a = i[t];
        return a instanceof p ? a : "string" == typeof a ? (a = new p(a), i[t] = a) : n[t] && e !== A && (o = A(n[t], A)) ? ((a = i[t] = new p)._set(o), a.name = r[t], a) : null
    }

    function w(t) {
        var e, i, o, a;
        for ("string" == typeof t && (t = [t]), e = 0; e < t.length; e++) o = b((i = t[e].split("|"))[0]), a = b(i[1]), n[o] = a, r[o] = i[0], n[a] = o, r[a] = i[1]
    }

    function k(t) {
        M(t.zones), w(t.links), E.dataVersion = t.version
    }

    function S(t) {
        var e = "X" === t._f || "x" === t._f;
        return !(!t._a || void 0 !== t._tzm || e)
    }

    function T(t) {
        "undefined" != typeof console && "function" == typeof console.error && console.error(t)
    }

    function E(e) {
        var i = Array.prototype.slice.call(arguments, 0, -1), n = arguments[arguments.length - 1], r = A(n),
            o = t.utc.apply(null, i);
        return r && !t.isMoment(e) && S(o) && o.add(r.parse(o), "minutes"), o.tz(n), o
    }

    (s < 2 || 2 == s && l < 6) && T("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js " + t.version + ". See momentjs.com"), p.prototype = {
        _set: function (t) {
            this.name = t.name, this.abbrs = t.abbrs, this.untils = t.untils, this.offsets = t.offsets, this.population = t.population
        }, _index: function (t) {
            var e, i = +t, n = this.untils;
            for (e = 0; e < n.length; e++) if (i < n[e]) return e
        }, parse: function (t) {
            var e, i, n, r, o = +t, a = this.offsets, s = this.untils, l = s.length - 1;
            for (r = 0; r < l; r++) if (e = a[r], i = a[r + 1], n = a[r ? r - 1 : r], e < i && E.moveAmbiguousForward ? e = i : n < e && E.moveInvalidForward && (e = n), o < s[r] - 6e4 * e) return a[r];
            return a[l]
        }, abbr: function (t) {
            return this.abbrs[this._index(t)]
        }, offset: function (t) {
            return T("zone.offset has been deprecated in favor of zone.utcOffset"), this.offsets[this._index(t)]
        }, utcOffset: function (t) {
            return this.offsets[this._index(t)]
        }
    }, m.prototype.scoreOffsetAt = function (t) {
        this.offsetScore += Math.abs(this.zone.utcOffset(t.at) - t.offset), this.zone.abbr(t.at).replace(/[^A-Z]/g, "") !== t.abbr && this.abbrScore++
    }, E.version = "0.5.26", E.dataVersion = "", E._zones = i, E._links = n, E._names = r, E.add = M, E.link = w, E.load = k, E.zone = A, E.zoneExists = function t(e) {
        return t.didShowError || (t.didShowError = !0, T("moment.tz.zoneExists('" + e + "') has been deprecated in favor of !moment.tz.zone('" + e + "')")), !!A(e)
    }, E.guess = function (t) {
        return e && !t || (e = function () {
            try {
                var t = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (t && 3 < t.length) {
                    var e = r[b(t)];
                    if (e) return e;
                    T("Moment Timezone found " + t + " from the Intl api, but did not have that data loaded.")
                }
            } catch (t) {
            }
            var i, n, a, s = function () {
                var t, e, i, n = (new Date).getFullYear() - 2, r = new g(new Date(n, 0, 1)), o = [r];
                for (i = 1; i < 48; i++) (e = new g(new Date(n, i, 1))).offset !== r.offset && (t = v(r, e), o.push(t), o.push(new g(new Date(t.at + 6e4)))), r = e;
                for (i = 0; i < 4; i++) o.push(new g(new Date(n + i, 0, 1))), o.push(new g(new Date(n + i, 6, 1)));
                return o
            }(), l = s.length, h = function (t) {
                var e, i, n, a = t.length, s = {}, l = [];
                for (e = 0; e < a; e++) for (i in n = o[t[e].offset] || {}) n.hasOwnProperty(i) && (s[i] = !0);
                for (e in s) s.hasOwnProperty(e) && l.push(r[e]);
                return l
            }(s), c = [];
            for (n = 0; n < h.length; n++) {
                for (i = new m(A(h[n]), l), a = 0; a < l; a++) i.scoreOffsetAt(s[a]);
                c.push(i)
            }
            return c.sort(y), 0 < c.length ? c[0].zone.name : void 0
        }()), e
    }, E.names = function () {
        var t, e = [];
        for (t in r) r.hasOwnProperty(t) && (i[t] || i[n[t]]) && r[t] && e.push(r[t]);
        return e.sort()
    }, E.Zone = p, E.unpack = f, E.unpackBase60 = c, E.needsOffset = S, E.moveInvalidForward = !0, E.moveAmbiguousForward = !1;
    var C, D = t.fn;

    function P(t) {
        return function () {
            return this._z ? this._z.abbr(this) : t.call(this)
        }
    }

    function _(t) {
        return function () {
            return this._z = null, t.apply(this, arguments)
        }
    }

    t.tz = E, t.defaultZone = null, t.updateOffset = function (e, i) {
        var n, r = t.defaultZone;
        if (void 0 === e._z && (r && S(e) && !e._isUTC && (e._d = t.utc(e._a)._d, e.utc().add(r.parse(e), "minutes")), e._z = r), e._z) if (n = e._z.utcOffset(e), Math.abs(n) < 16 && (n /= 60), void 0 !== e.utcOffset) {
            var o = e._z;
            e.utcOffset(-n, i), e._z = o
        } else e.zone(n, i)
    }, D.tz = function (e, i) {
        if (e) {
            if ("string" != typeof e) throw new Error("Time zone name must be a string, got " + e + " [" + typeof e + "]");
            return this._z = A(e), this._z ? t.updateOffset(this, i) : T("Moment Timezone has no data for " + e + ". See http://momentjs.com/timezone/docs/#/data-loading/."), this
        }
        if (this._z) return this._z.name
    }, D.zoneName = P(D.zoneName), D.zoneAbbr = P(D.zoneAbbr), D.utc = _(D.utc), D.local = _(D.local), D.utcOffset = (C = D.utcOffset, function () {
        return 0 < arguments.length && (this._z = null), C.apply(this, arguments)
    }), t.tz.setDefault = function (e) {
        return (s < 2 || 2 == s && l < 9) && T("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js " + t.version + "."), t.defaultZone = e ? A(e) : null, t
    };
    var O = t.momentProperties;
    return "[object Array]" === Object.prototype.toString.call(O) ? (O.push("_z"), O.push("_a")) : O && (O._z = null), k({
        version: "2019b",
        zones: ["Africa/Abidjan|GMT|0|0||48e5", "Africa/Nairobi|EAT|-30|0||47e5", "Africa/Algiers|CET|-10|0||26e5", "Africa/Lagos|WAT|-10|0||17e6", "Africa/Maputo|CAT|-20|0||26e5", "Africa/Cairo|EET EEST|-20 -30|01010|1M2m0 gL0 e10 mn0|15e6", "Africa/Casablanca|+00 +01|0 -10|010101010101010101010101010101010101|1H3C0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 e00 28M0 e00 2600 gM0|32e5", "Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|11e6", "Africa/Johannesburg|SAST|-20|0||84e5", "Africa/Khartoum|EAT CAT|-30 -20|01|1Usl0|51e5", "Africa/Sao_Tome|GMT WAT|0 -10|010|1UQN0 2q00", "Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5", "Africa/Windhoek|CAT WAT|-20 -10|0101010101010|1GQo0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|32e4", "America/Adak|HST HDT|a0 90|01010101010101010101010|1GIc0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|326", "America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1GIb0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|30e4", "America/Santo_Domingo|AST|40|0||29e5", "America/Araguaina|-03 -02|30 20|010|1IdD0 Lz0|14e4", "America/Fortaleza|-03|30|0||34e5", "America/Asuncion|-03 -04|30 40|01010101010101010101010|1GTf0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0|28e5", "America/Panama|EST|50|0||15e5", "America/Mexico_City|CST CDT|60 50|01010101010101010101010|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|20e6", "America/Bahia|-02 -03|20 30|01|1GCq0|27e5", "America/Managua|CST|60|0||22e5", "America/La_Paz|-04|40|0||19e5", "America/Lima|-05|50|0||11e6", "America/Denver|MST MDT|70 60|01010101010101010101010|1GI90 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|26e5", "America/Campo_Grande|-03 -04|30 40|0101010101010101|1GCr0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4", "America/Cancun|CST CDT EST|60 50 50|01010102|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4", "America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5", "America/Chicago|CST CDT|60 50|01010101010101010101010|1GI80 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|92e5", "America/Chihuahua|MST MDT|70 60|01010101010101010101010|1GQx0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|81e4", "America/Phoenix|MST|70|0||42e5", "America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|15e6", "America/New_York|EST EDT|50 40|01010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|21e6", "America/Rio_Branco|-04 -05|40 50|01|1KLE0|31e4", "America/Fort_Nelson|PST PDT MST|80 70 70|01010102|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2", "America/Halifax|AST ADT|40 30|01010101010101010101010|1GI60 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|39e4", "America/Godthab|-03 -02|30 20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|17e3", "America/Grand_Turk|EST EDT AST|50 40 40|0101010121010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 5Ip0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|37e2", "America/Havana|CST CDT|50 40|01010101010101010101010|1GQt0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0|21e5", "America/Metlakatla|PST AKST AKDT|80 90 80|01212120121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|14e2", "America/Miquelon|-03 -02|30 20|01010101010101010101010|1GI50 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|61e2", "America/Montevideo|-02 -03|20 30|01010101|1GI40 1o10 11z0 1o10 11z0 1o10 11z0|17e5", "America/Noronha|-02|20|0||30e2", "America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|23e5", "Antarctica/Palmer|-03 -04|30 40|010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40", "America/Santiago|-03 -04|30 40|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|62e5", "America/Sao_Paulo|-02 -03|20 30|0101010101010101|1GCq0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6", "Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e4", "America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1GI5u 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|11e4", "Antarctica/Casey|+11 +08|-b0 -80|0101|1GAF0 blz0 3m10|10", "Antarctica/Davis|+05 +07|-50 -70|01|1GAI0|70", "Pacific/Port_Moresby|+10|-a0|0||25e4", "Pacific/Guadalcanal|+11|-b0|0||11e4", "Asia/Tashkent|+05|-50|0||23e5", "Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|14e5", "Asia/Baghdad|+03|-30|0||66e5", "Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|40", "Asia/Dhaka|+06|-60|0||16e6", "Asia/Amman|EET EEST|-20 -30|010101010101010101010|1GPy0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00|25e5", "Asia/Kamchatka|+12|-c0|0||18e4", "Asia/Baku|+04 +05|-40 -50|010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5", "Asia/Bangkok|+07|-70|0||15e6", "Asia/Barnaul|+07 +06|-70 -60|010|1N7v0 3rd0", "Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1GNy0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|22e5", "Asia/Kuala_Lumpur|+08|-80|0||71e5", "Asia/Kolkata|IST|-5u|0||15e6", "Asia/Chita|+10 +08 +09|-a0 -80 -90|012|1N7s0 3re0|33e4", "Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5", "Asia/Shanghai|CST|-80|0||23e6", "Asia/Colombo|+0530|-5u|0||22e5", "Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1GPy0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|26e5", "Asia/Dili|+09|-90|0||19e4", "Asia/Dubai|+04|-40|0||39e5", "Asia/Famagusta|EET EEST +03|-20 -30 -30|0101010101201010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0", "Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1GPy0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0|18e5", "Asia/Hong_Kong|HKT|-80|0||73e5", "Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3", "Asia/Irkutsk|+09 +08|-90 -80|01|1N7t0|60e4", "Europe/Istanbul|EET EEST +03|-20 -30 -30|01010101012|1GNB0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6", "Asia/Jakarta|WIB|-70|0||31e6", "Asia/Jayapura|WIT|-90|0||26e4", "Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1GPA0 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0|81e4", "Asia/Kabul|+0430|-4u|0||46e5", "Asia/Karachi|PKT|-50|0||24e6", "Asia/Kathmandu|+0545|-5J|0||12e5", "Asia/Yakutsk|+10 +09|-a0 -90|01|1N7s0|28e4", "Asia/Krasnoyarsk|+08 +07|-80 -70|01|1N7u0|10e5", "Asia/Magadan|+12 +10 +11|-c0 -a0 -b0|012|1N7q0 3Cq0|95e3", "Asia/Makassar|WITA|-80|0||15e5", "Asia/Manila|PST|-80|0||24e6", "Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|35e5", "Asia/Novosibirsk|+07 +06|-70 -60|010|1N7v0 4eN0|15e5", "Asia/Omsk|+07 +06|-70 -60|01|1N7v0|12e5", "Asia/Pyongyang|KST KST|-90 -8u|010|1P4D0 6BA0|29e5", "Asia/Qyzylorda|+06 +05|-60 -50|01|1Xei0|73e4", "Asia/Rangoon|+0630|-6u|0||48e5", "Asia/Sakhalin|+11 +10|-b0 -a0|010|1N7r0 3rd0|58e4", "Asia/Seoul|KST|-90|0||23e6", "Asia/Srednekolymsk|+12 +11|-c0 -b0|01|1N7q0|35e2", "Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1GLUu 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0|14e6", "Asia/Tokyo|JST|-90|0||38e6", "Asia/Tomsk|+07 +06|-70 -60|010|1N7v0 3Qp0|10e5", "Asia/Vladivostok|+11 +10|-b0 -a0|01|1N7r0|60e4", "Asia/Yekaterinburg|+06 +05|-60 -50|01|1N7w0|14e5", "Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|27e5", "Atlantic/Cape_Verde|-01|10|0||50e4", "Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1GQg0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|40e5", "Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1GQgu 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|11e5", "Australia/Brisbane|AEST|-a0|0||20e5", "Australia/Darwin|ACST|-9u|0||12e4", "Australia/Eucla|+0845|-8J|0||368", "Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1GQf0 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu|347", "Australia/Perth|AWST|-80|0||18e5", "Pacific/Easter|-05 -06|50 60|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|30e2", "Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|12e5", "Etc/GMT-1|+01|-10|0|", "Pacific/Fakaofo|+13|-d0|0||483", "Pacific/Kiritimati|+14|-e0|0||51e2", "Etc/GMT-2|+02|-20|0|", "Pacific/Tahiti|-10|a0|0||18e4", "Pacific/Niue|-11|b0|0||12e2", "Etc/GMT+12|-12|c0|0|", "Pacific/Galapagos|-06|60|0||25e3", "Etc/GMT+7|-07|70|0|", "Pacific/Pitcairn|-08|80|0||56", "Pacific/Gambier|-09|90|0||125", "Etc/UTC|UTC|0|0|", "Europe/Ulyanovsk|+04 +03|-40 -30|010|1N7y0 3rd0|13e5", "Europe/London|GMT BST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|10e6", "Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|67e4", "Europe/Kaliningrad|+03 EET|-30 -20|01|1N7z0|44e4", "Europe/Kirov|+04 +03|-40 -30|01|1N7y0|48e4", "Europe/Moscow|MSK MSK|-40 -30|01|1N7y0|16e6", "Europe/Saratov|+04 +03|-40 -30|010|1N7y0 5810", "Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|0101023|1GNB0 1qM0 11A0 1o00 11z0 1nW0|33e4", "Europe/Volgograd|+04 +03|-40 -30|010|1N7y0 9Jd0|10e5", "Pacific/Honolulu|HST|a0|0||37e4", "MET|MET MEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0", "Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|600", "Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|37e3", "Pacific/Bougainville|+10 +11|-a0 -b0|01|1NwE0|18e4", "Pacific/Fiji|+13 +12|-d0 -c0|01010101010101010101010|1Goe0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1VA0 s00 1VA0|88e4", "Pacific/Guam|ChST|-a0|0||17e4", "Pacific/Marquesas|-0930|9u|0||86e2", "Pacific/Pago_Pago|SST|b0|0||37e2", "Pacific/Norfolk|+1130 +11|-bu -b0|01|1PoCu|25e4", "Pacific/Tongatapu|+13 +14|-d0 -e0|010|1S4d0 s00|75e3"],
        links: ["Africa/Abidjan|Africa/Accra", "Africa/Abidjan|Africa/Bamako", "Africa/Abidjan|Africa/Banjul", "Africa/Abidjan|Africa/Bissau", "Africa/Abidjan|Africa/Conakry", "Africa/Abidjan|Africa/Dakar", "Africa/Abidjan|Africa/Freetown", "Africa/Abidjan|Africa/Lome", "Africa/Abidjan|Africa/Monrovia", "Africa/Abidjan|Africa/Nouakchott", "Africa/Abidjan|Africa/Ouagadougou", "Africa/Abidjan|Africa/Timbuktu", "Africa/Abidjan|America/Danmarkshavn", "Africa/Abidjan|Atlantic/Reykjavik", "Africa/Abidjan|Atlantic/St_Helena", "Africa/Abidjan|Etc/GMT", "Africa/Abidjan|Etc/GMT+0", "Africa/Abidjan|Etc/GMT-0", "Africa/Abidjan|Etc/GMT0", "Africa/Abidjan|Etc/Greenwich", "Africa/Abidjan|GMT", "Africa/Abidjan|GMT+0", "Africa/Abidjan|GMT-0", "Africa/Abidjan|GMT0", "Africa/Abidjan|Greenwich", "Africa/Abidjan|Iceland", "Africa/Algiers|Africa/Tunis", "Africa/Cairo|Egypt", "Africa/Casablanca|Africa/El_Aaiun", "Africa/Johannesburg|Africa/Maseru", "Africa/Johannesburg|Africa/Mbabane", "Africa/Lagos|Africa/Bangui", "Africa/Lagos|Africa/Brazzaville", "Africa/Lagos|Africa/Douala", "Africa/Lagos|Africa/Kinshasa", "Africa/Lagos|Africa/Libreville", "Africa/Lagos|Africa/Luanda", "Africa/Lagos|Africa/Malabo", "Africa/Lagos|Africa/Ndjamena", "Africa/Lagos|Africa/Niamey", "Africa/Lagos|Africa/Porto-Novo", "Africa/Maputo|Africa/Blantyre", "Africa/Maputo|Africa/Bujumbura", "Africa/Maputo|Africa/Gaborone", "Africa/Maputo|Africa/Harare", "Africa/Maputo|Africa/Kigali", "Africa/Maputo|Africa/Lubumbashi", "Africa/Maputo|Africa/Lusaka", "Africa/Nairobi|Africa/Addis_Ababa", "Africa/Nairobi|Africa/Asmara", "Africa/Nairobi|Africa/Asmera", "Africa/Nairobi|Africa/Dar_es_Salaam", "Africa/Nairobi|Africa/Djibouti", "Africa/Nairobi|Africa/Juba", "Africa/Nairobi|Africa/Kampala", "Africa/Nairobi|Africa/Mogadishu", "Africa/Nairobi|Indian/Antananarivo", "Africa/Nairobi|Indian/Comoro", "Africa/Nairobi|Indian/Mayotte", "Africa/Tripoli|Libya", "America/Adak|America/Atka", "America/Adak|US/Aleutian", "America/Anchorage|America/Juneau", "America/Anchorage|America/Nome", "America/Anchorage|America/Sitka", "America/Anchorage|America/Yakutat", "America/Anchorage|US/Alaska", "America/Campo_Grande|America/Cuiaba", "America/Chicago|America/Indiana/Knox", "America/Chicago|America/Indiana/Tell_City", "America/Chicago|America/Knox_IN", "America/Chicago|America/Matamoros", "America/Chicago|America/Menominee", "America/Chicago|America/North_Dakota/Beulah", "America/Chicago|America/North_Dakota/Center", "America/Chicago|America/North_Dakota/New_Salem", "America/Chicago|America/Rainy_River", "America/Chicago|America/Rankin_Inlet", "America/Chicago|America/Resolute", "America/Chicago|America/Winnipeg", "America/Chicago|CST6CDT", "America/Chicago|Canada/Central", "America/Chicago|US/Central", "America/Chicago|US/Indiana-Starke", "America/Chihuahua|America/Mazatlan", "America/Chihuahua|Mexico/BajaSur", "America/Denver|America/Boise", "America/Denver|America/Cambridge_Bay", "America/Denver|America/Edmonton", "America/Denver|America/Inuvik", "America/Denver|America/Ojinaga", "America/Denver|America/Shiprock", "America/Denver|America/Yellowknife", "America/Denver|Canada/Mountain", "America/Denver|MST7MDT", "America/Denver|Navajo", "America/Denver|US/Mountain", "America/Fortaleza|America/Argentina/Buenos_Aires", "America/Fortaleza|America/Argentina/Catamarca", "America/Fortaleza|America/Argentina/ComodRivadavia", "America/Fortaleza|America/Argentina/Cordoba", "America/Fortaleza|America/Argentina/Jujuy", "America/Fortaleza|America/Argentina/La_Rioja", "America/Fortaleza|America/Argentina/Mendoza", "America/Fortaleza|America/Argentina/Rio_Gallegos", "America/Fortaleza|America/Argentina/Salta", "America/Fortaleza|America/Argentina/San_Juan", "America/Fortaleza|America/Argentina/San_Luis", "America/Fortaleza|America/Argentina/Tucuman", "America/Fortaleza|America/Argentina/Ushuaia", "America/Fortaleza|America/Belem", "America/Fortaleza|America/Buenos_Aires", "America/Fortaleza|America/Catamarca", "America/Fortaleza|America/Cayenne", "America/Fortaleza|America/Cordoba", "America/Fortaleza|America/Jujuy", "America/Fortaleza|America/Maceio", "America/Fortaleza|America/Mendoza", "America/Fortaleza|America/Paramaribo", "America/Fortaleza|America/Recife", "America/Fortaleza|America/Rosario", "America/Fortaleza|America/Santarem", "America/Fortaleza|Antarctica/Rothera", "America/Fortaleza|Atlantic/Stanley", "America/Fortaleza|Etc/GMT+3", "America/Halifax|America/Glace_Bay", "America/Halifax|America/Goose_Bay", "America/Halifax|America/Moncton", "America/Halifax|America/Thule", "America/Halifax|Atlantic/Bermuda", "America/Halifax|Canada/Atlantic", "America/Havana|Cuba", "America/La_Paz|America/Boa_Vista", "America/La_Paz|America/Guyana", "America/La_Paz|America/Manaus", "America/La_Paz|America/Porto_Velho", "America/La_Paz|Brazil/West", "America/La_Paz|Etc/GMT+4", "America/Lima|America/Bogota", "America/Lima|America/Guayaquil", "America/Lima|Etc/GMT+5", "America/Los_Angeles|America/Dawson", "America/Los_Angeles|America/Ensenada", "America/Los_Angeles|America/Santa_Isabel", "America/Los_Angeles|America/Tijuana", "America/Los_Angeles|America/Vancouver", "America/Los_Angeles|America/Whitehorse", "America/Los_Angeles|Canada/Pacific", "America/Los_Angeles|Canada/Yukon", "America/Los_Angeles|Mexico/BajaNorte", "America/Los_Angeles|PST8PDT", "America/Los_Angeles|US/Pacific", "America/Los_Angeles|US/Pacific-New", "America/Managua|America/Belize", "America/Managua|America/Costa_Rica", "America/Managua|America/El_Salvador", "America/Managua|America/Guatemala", "America/Managua|America/Regina", "America/Managua|America/Swift_Current", "America/Managua|America/Tegucigalpa", "America/Managua|Canada/Saskatchewan", "America/Mexico_City|America/Bahia_Banderas", "America/Mexico_City|America/Merida", "America/Mexico_City|America/Monterrey", "America/Mexico_City|Mexico/General", "America/New_York|America/Detroit", "America/New_York|America/Fort_Wayne", "America/New_York|America/Indiana/Indianapolis", "America/New_York|America/Indiana/Marengo", "America/New_York|America/Indiana/Petersburg", "America/New_York|America/Indiana/Vevay", "America/New_York|America/Indiana/Vincennes", "America/New_York|America/Indiana/Winamac", "America/New_York|America/Indianapolis", "America/New_York|America/Iqaluit", "America/New_York|America/Kentucky/Louisville", "America/New_York|America/Kentucky/Monticello", "America/New_York|America/Louisville", "America/New_York|America/Montreal", "America/New_York|America/Nassau", "America/New_York|America/Nipigon", "America/New_York|America/Pangnirtung", "America/New_York|America/Thunder_Bay", "America/New_York|America/Toronto", "America/New_York|Canada/Eastern", "America/New_York|EST5EDT", "America/New_York|US/East-Indiana", "America/New_York|US/Eastern", "America/New_York|US/Michigan", "America/Noronha|Atlantic/South_Georgia", "America/Noronha|Brazil/DeNoronha", "America/Noronha|Etc/GMT+2", "America/Panama|America/Atikokan", "America/Panama|America/Cayman", "America/Panama|America/Coral_Harbour", "America/Panama|America/Jamaica", "America/Panama|EST", "America/Panama|Jamaica", "America/Phoenix|America/Creston", "America/Phoenix|America/Dawson_Creek", "America/Phoenix|America/Hermosillo", "America/Phoenix|MST", "America/Phoenix|US/Arizona", "America/Rio_Branco|America/Eirunepe", "America/Rio_Branco|America/Porto_Acre", "America/Rio_Branco|Brazil/Acre", "America/Santiago|Chile/Continental", "America/Santo_Domingo|America/Anguilla", "America/Santo_Domingo|America/Antigua", "America/Santo_Domingo|America/Aruba", "America/Santo_Domingo|America/Barbados", "America/Santo_Domingo|America/Blanc-Sablon", "America/Santo_Domingo|America/Curacao", "America/Santo_Domingo|America/Dominica", "America/Santo_Domingo|America/Grenada", "America/Santo_Domingo|America/Guadeloupe", "America/Santo_Domingo|America/Kralendijk", "America/Santo_Domingo|America/Lower_Princes", "America/Santo_Domingo|America/Marigot", "America/Santo_Domingo|America/Martinique", "America/Santo_Domingo|America/Montserrat", "America/Santo_Domingo|America/Port_of_Spain", "America/Santo_Domingo|America/Puerto_Rico", "America/Santo_Domingo|America/St_Barthelemy", "America/Santo_Domingo|America/St_Kitts", "America/Santo_Domingo|America/St_Lucia", "America/Santo_Domingo|America/St_Thomas", "America/Santo_Domingo|America/St_Vincent", "America/Santo_Domingo|America/Tortola", "America/Santo_Domingo|America/Virgin", "America/Sao_Paulo|Brazil/East", "America/St_Johns|Canada/Newfoundland", "Antarctica/Palmer|America/Punta_Arenas", "Asia/Baghdad|Antarctica/Syowa", "Asia/Baghdad|Asia/Aden", "Asia/Baghdad|Asia/Bahrain", "Asia/Baghdad|Asia/Kuwait", "Asia/Baghdad|Asia/Qatar", "Asia/Baghdad|Asia/Riyadh", "Asia/Baghdad|Etc/GMT-3", "Asia/Baghdad|Europe/Minsk", "Asia/Bangkok|Asia/Ho_Chi_Minh", "Asia/Bangkok|Asia/Novokuznetsk", "Asia/Bangkok|Asia/Phnom_Penh", "Asia/Bangkok|Asia/Saigon", "Asia/Bangkok|Asia/Vientiane", "Asia/Bangkok|Etc/GMT-7", "Asia/Bangkok|Indian/Christmas", "Asia/Dhaka|Antarctica/Vostok", "Asia/Dhaka|Asia/Almaty", "Asia/Dhaka|Asia/Bishkek", "Asia/Dhaka|Asia/Dacca", "Asia/Dhaka|Asia/Kashgar", "Asia/Dhaka|Asia/Qostanay", "Asia/Dhaka|Asia/Thimbu", "Asia/Dhaka|Asia/Thimphu", "Asia/Dhaka|Asia/Urumqi", "Asia/Dhaka|Etc/GMT-6", "Asia/Dhaka|Indian/Chagos", "Asia/Dili|Etc/GMT-9", "Asia/Dili|Pacific/Palau", "Asia/Dubai|Asia/Muscat", "Asia/Dubai|Asia/Tbilisi", "Asia/Dubai|Asia/Yerevan", "Asia/Dubai|Etc/GMT-4", "Asia/Dubai|Europe/Samara", "Asia/Dubai|Indian/Mahe", "Asia/Dubai|Indian/Mauritius", "Asia/Dubai|Indian/Reunion", "Asia/Gaza|Asia/Hebron", "Asia/Hong_Kong|Hongkong", "Asia/Jakarta|Asia/Pontianak", "Asia/Jerusalem|Asia/Tel_Aviv", "Asia/Jerusalem|Israel", "Asia/Kamchatka|Asia/Anadyr", "Asia/Kamchatka|Etc/GMT-12", "Asia/Kamchatka|Kwajalein", "Asia/Kamchatka|Pacific/Funafuti", "Asia/Kamchatka|Pacific/Kwajalein", "Asia/Kamchatka|Pacific/Majuro", "Asia/Kamchatka|Pacific/Nauru", "Asia/Kamchatka|Pacific/Tarawa", "Asia/Kamchatka|Pacific/Wake", "Asia/Kamchatka|Pacific/Wallis", "Asia/Kathmandu|Asia/Katmandu", "Asia/Kolkata|Asia/Calcutta", "Asia/Kuala_Lumpur|Asia/Brunei", "Asia/Kuala_Lumpur|Asia/Kuching", "Asia/Kuala_Lumpur|Asia/Singapore", "Asia/Kuala_Lumpur|Etc/GMT-8", "Asia/Kuala_Lumpur|Singapore", "Asia/Makassar|Asia/Ujung_Pandang", "Asia/Rangoon|Asia/Yangon", "Asia/Rangoon|Indian/Cocos", "Asia/Seoul|ROK", "Asia/Shanghai|Asia/Chongqing", "Asia/Shanghai|Asia/Chungking", "Asia/Shanghai|Asia/Harbin", "Asia/Shanghai|Asia/Macao", "Asia/Shanghai|Asia/Macau", "Asia/Shanghai|Asia/Taipei", "Asia/Shanghai|PRC", "Asia/Shanghai|ROC", "Asia/Tashkent|Antarctica/Mawson", "Asia/Tashkent|Asia/Aqtau", "Asia/Tashkent|Asia/Aqtobe", "Asia/Tashkent|Asia/Ashgabat", "Asia/Tashkent|Asia/Ashkhabad", "Asia/Tashkent|Asia/Atyrau", "Asia/Tashkent|Asia/Dushanbe", "Asia/Tashkent|Asia/Oral", "Asia/Tashkent|Asia/Samarkand", "Asia/Tashkent|Etc/GMT-5", "Asia/Tashkent|Indian/Kerguelen", "Asia/Tashkent|Indian/Maldives", "Asia/Tehran|Iran", "Asia/Tokyo|Japan", "Asia/Ulaanbaatar|Asia/Choibalsan", "Asia/Ulaanbaatar|Asia/Ulan_Bator", "Asia/Vladivostok|Asia/Ust-Nera", "Asia/Yakutsk|Asia/Khandyga", "Atlantic/Azores|America/Scoresbysund", "Atlantic/Cape_Verde|Etc/GMT+1", "Australia/Adelaide|Australia/Broken_Hill", "Australia/Adelaide|Australia/South", "Australia/Adelaide|Australia/Yancowinna", "Australia/Brisbane|Australia/Lindeman", "Australia/Brisbane|Australia/Queensland", "Australia/Darwin|Australia/North", "Australia/Lord_Howe|Australia/LHI", "Australia/Perth|Australia/West", "Australia/Sydney|Australia/ACT", "Australia/Sydney|Australia/Canberra", "Australia/Sydney|Australia/Currie", "Australia/Sydney|Australia/Hobart", "Australia/Sydney|Australia/Melbourne", "Australia/Sydney|Australia/NSW", "Australia/Sydney|Australia/Tasmania", "Australia/Sydney|Australia/Victoria", "Etc/UTC|Etc/UCT", "Etc/UTC|Etc/Universal", "Etc/UTC|Etc/Zulu", "Etc/UTC|UCT", "Etc/UTC|UTC", "Etc/UTC|Universal", "Etc/UTC|Zulu", "Europe/Athens|Asia/Nicosia", "Europe/Athens|EET", "Europe/Athens|Europe/Bucharest", "Europe/Athens|Europe/Helsinki", "Europe/Athens|Europe/Kiev", "Europe/Athens|Europe/Mariehamn", "Europe/Athens|Europe/Nicosia", "Europe/Athens|Europe/Riga", "Europe/Athens|Europe/Sofia", "Europe/Athens|Europe/Tallinn", "Europe/Athens|Europe/Uzhgorod", "Europe/Athens|Europe/Vilnius", "Europe/Athens|Europe/Zaporozhye", "Europe/Chisinau|Europe/Tiraspol", "Europe/Dublin|Eire", "Europe/Istanbul|Asia/Istanbul", "Europe/Istanbul|Turkey", "Europe/Lisbon|Atlantic/Canary", "Europe/Lisbon|Atlantic/Faeroe", "Europe/Lisbon|Atlantic/Faroe", "Europe/Lisbon|Atlantic/Madeira", "Europe/Lisbon|Portugal", "Europe/Lisbon|WET", "Europe/London|Europe/Belfast", "Europe/London|Europe/Guernsey", "Europe/London|Europe/Isle_of_Man", "Europe/London|Europe/Jersey", "Europe/London|GB", "Europe/London|GB-Eire", "Europe/Moscow|W-SU", "Europe/Paris|Africa/Ceuta", "Europe/Paris|Arctic/Longyearbyen", "Europe/Paris|Atlantic/Jan_Mayen", "Europe/Paris|CET", "Europe/Paris|Europe/Amsterdam", "Europe/Paris|Europe/Andorra", "Europe/Paris|Europe/Belgrade", "Europe/Paris|Europe/Berlin", "Europe/Paris|Europe/Bratislava", "Europe/Paris|Europe/Brussels", "Europe/Paris|Europe/Budapest", "Europe/Paris|Europe/Busingen", "Europe/Paris|Europe/Copenhagen", "Europe/Paris|Europe/Gibraltar", "Europe/Paris|Europe/Ljubljana", "Europe/Paris|Europe/Luxembourg", "Europe/Paris|Europe/Madrid", "Europe/Paris|Europe/Malta", "Europe/Paris|Europe/Monaco", "Europe/Paris|Europe/Oslo", "Europe/Paris|Europe/Podgorica", "Europe/Paris|Europe/Prague", "Europe/Paris|Europe/Rome", "Europe/Paris|Europe/San_Marino", "Europe/Paris|Europe/Sarajevo", "Europe/Paris|Europe/Skopje", "Europe/Paris|Europe/Stockholm", "Europe/Paris|Europe/Tirane", "Europe/Paris|Europe/Vaduz", "Europe/Paris|Europe/Vatican", "Europe/Paris|Europe/Vienna", "Europe/Paris|Europe/Warsaw", "Europe/Paris|Europe/Zagreb", "Europe/Paris|Europe/Zurich", "Europe/Paris|Poland", "Europe/Ulyanovsk|Europe/Astrakhan", "Pacific/Auckland|Antarctica/McMurdo", "Pacific/Auckland|Antarctica/South_Pole", "Pacific/Auckland|NZ", "Pacific/Chatham|NZ-CHAT", "Pacific/Easter|Chile/EasterIsland", "Pacific/Fakaofo|Etc/GMT-13", "Pacific/Fakaofo|Pacific/Enderbury", "Pacific/Galapagos|Etc/GMT+6", "Pacific/Gambier|Etc/GMT+9", "Pacific/Guadalcanal|Antarctica/Macquarie", "Pacific/Guadalcanal|Etc/GMT-11", "Pacific/Guadalcanal|Pacific/Efate", "Pacific/Guadalcanal|Pacific/Kosrae", "Pacific/Guadalcanal|Pacific/Noumea", "Pacific/Guadalcanal|Pacific/Pohnpei", "Pacific/Guadalcanal|Pacific/Ponape", "Pacific/Guam|Pacific/Saipan", "Pacific/Honolulu|HST", "Pacific/Honolulu|Pacific/Johnston", "Pacific/Honolulu|US/Hawaii", "Pacific/Kiritimati|Etc/GMT-14", "Pacific/Niue|Etc/GMT+11", "Pacific/Pago_Pago|Pacific/Midway", "Pacific/Pago_Pago|Pacific/Samoa", "Pacific/Pago_Pago|US/Samoa", "Pacific/Pitcairn|Etc/GMT+8", "Pacific/Port_Moresby|Antarctica/DumontDUrville", "Pacific/Port_Moresby|Etc/GMT-10", "Pacific/Port_Moresby|Pacific/Chuuk", "Pacific/Port_Moresby|Pacific/Truk", "Pacific/Port_Moresby|Pacific/Yap", "Pacific/Tahiti|Etc/GMT+10", "Pacific/Tahiti|Pacific/Rarotonga"]
    }), t
}), function () {
    function t(t) {
        return t && (t.ownerDocument || t.document || t).documentElement
    }

    function e(t) {
        return t && (t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView)
    }

    function i(t, e) {
        return e > t ? -1 : t > e ? 1 : t >= e ? 0 : NaN
    }

    function n(t) {
        return null === t ? NaN : +t
    }

    function r(t) {
        return !isNaN(t)
    }

    function o(t) {
        return {
            left: function (e, i, n, r) {
                for (arguments.length < 3 && (n = 0), arguments.length < 4 && (r = e.length); r > n;) {
                    var o = n + r >>> 1;
                    t(e[o], i) < 0 ? n = o + 1 : r = o
                }
                return n
            }, right: function (e, i, n, r) {
                for (arguments.length < 3 && (n = 0), arguments.length < 4 && (r = e.length); r > n;) {
                    var o = n + r >>> 1;
                    t(e[o], i) > 0 ? r = o : n = o + 1
                }
                return n
            }
        }
    }

    function a(t) {
        return t.length
    }

    function s(t, e) {
        for (var i in e) Object.defineProperty(t.prototype, i, {value: e[i], enumerable: !1})
    }

    function l() {
        this._ = Object.create(null)
    }

    function h(t) {
        return (t += "") === uo || t[0] === fo ? fo + t : t
    }

    function c(t) {
        return (t += "")[0] === fo ? t.slice(1) : t
    }

    function u(t) {
        return h(t) in this._
    }

    function d(t) {
        return (t = h(t)) in this._ && delete this._[t]
    }

    function f() {
        var t = [];
        for (var e in this._) t.push(c(e));
        return t
    }

    function p() {
        var t = 0;
        for (var e in this._) ++t;
        return t
    }

    function g() {
        for (var t in this._) return !1;
        return !0
    }

    function m() {
        this._ = Object.create(null)
    }

    function v(t) {
        return t
    }

    function y(t, e, i) {
        return function () {
            var n = i.apply(e, arguments);
            return n === e ? t : n
        }
    }

    function x(t, e) {
        if (e in t) return e;
        e = e.charAt(0).toUpperCase() + e.slice(1);
        for (var i = 0, n = po.length; n > i; ++i) {
            var r = po[i] + e;
            if (r in t) return r
        }
    }

    function b() {
    }

    function M() {
    }

    function A(t) {
        function e() {
            for (var e, n = i, r = -1, o = n.length; ++r < o;) (e = n[r].on) && e.apply(this, arguments);
            return t
        }

        var i = [], n = new l;
        return e.on = function (e, r) {
            var o, a = n.get(e);
            return arguments.length < 2 ? a && a.on : (a && (a.on = null, i = i.slice(0, o = i.indexOf(a)).concat(i.slice(o + 1)), n.remove(e)), r && i.push(n.set(e, {on: r})), t)
        }, e
    }

    function w() {
        to.event.preventDefault()
    }

    function k() {
        for (var t, e = to.event; t = e.sourceEvent;) e = t;
        return e
    }

    function S(t) {
        for (var e = new M, i = 0, n = arguments.length; ++i < n;) e[arguments[i]] = A(e);
        return e.of = function (i, n) {
            return function (r) {
                try {
                    var o = r.sourceEvent = to.event;
                    r.target = t, to.event = r, e[r.type].apply(i, n)
                } finally {
                    to.event = o
                }
            }
        }, e
    }

    function T(t) {
        return mo(t, bo), t
    }

    function E(t) {
        return "function" == typeof t ? t : function () {
            return vo(t, this)
        }
    }

    function C(t) {
        return "function" == typeof t ? t : function () {
            return yo(t, this)
        }
    }

    function D(t, e) {
        return t = to.ns.qualify(t), null == e ? t.local ? function () {
            this.removeAttributeNS(t.space, t.local)
        } : function () {
            this.removeAttribute(t)
        } : "function" == typeof e ? t.local ? function () {
            var i = e.apply(this, arguments);
            null == i ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, i)
        } : function () {
            var i = e.apply(this, arguments);
            null == i ? this.removeAttribute(t) : this.setAttribute(t, i)
        } : t.local ? function () {
            this.setAttributeNS(t.space, t.local, e)
        } : function () {
            this.setAttribute(t, e)
        }
    }

    function P(t) {
        return t.trim().replace(/\s+/g, " ")
    }

    function _(t) {
        return new RegExp("(?:^|\\s+)" + to.requote(t) + "(?:\\s+|$)", "g")
    }

    function O(t) {
        return (t + "").trim().split(/^|\s+/)
    }

    function L(t, e) {
        var i = (t = O(t).map(N)).length;
        return "function" == typeof e ? function () {
            for (var n = -1, r = e.apply(this, arguments); ++n < i;) t[n](this, r)
        } : function () {
            for (var n = -1; ++n < i;) t[n](this, e)
        }
    }

    function N(t) {
        var e = _(t);
        return function (i, n) {
            if (r = i.classList) return n ? r.add(t) : r.remove(t);
            var r = i.getAttribute("class") || "";
            n ? (e.lastIndex = 0, e.test(r) || i.setAttribute("class", P(r + " " + t))) : i.setAttribute("class", P(r.replace(e, " ")))
        }
    }

    function z(t, e, i) {
        return null == e ? function () {
            this.style.removeProperty(t)
        } : "function" == typeof e ? function () {
            var n = e.apply(this, arguments);
            null == n ? this.style.removeProperty(t) : this.style.setProperty(t, n, i)
        } : function () {
            this.style.setProperty(t, e, i)
        }
    }

    function I(t, e) {
        return null == e ? function () {
            delete this[t]
        } : "function" == typeof e ? function () {
            var i = e.apply(this, arguments);
            null == i ? delete this[t] : this[t] = i
        } : function () {
            this[t] = e
        }
    }

    function R(t) {
        return "function" == typeof t ? t : (t = to.ns.qualify(t)).local ? function () {
            return this.ownerDocument.createElementNS(t.space, t.local)
        } : function () {
            var e = this.ownerDocument, i = this.namespaceURI;
            return i === Mo && e.documentElement.namespaceURI === Mo ? e.createElement(t) : e.createElementNS(i, t)
        }
    }

    function B() {
        var t = this.parentNode;
        t && t.removeChild(this)
    }

    function j(t) {
        return {__data__: t}
    }

    function W(t) {
        return function () {
            return xo(this, t)
        }
    }

    function H(t) {
        return arguments.length || (t = i), function (e, i) {
            return e && i ? t(e.__data__, i.__data__) : !e - !i
        }
    }

    function Y(t, e) {
        for (var i = 0, n = t.length; n > i; i++) for (var r, o = t[i], a = 0, s = o.length; s > a; a++) (r = o[a]) && e(r, a, i);
        return t
    }

    function G(t) {
        return mo(t, wo), t
    }

    function F(t, e, i) {
        function n() {
            var e = this[r];
            e && (this.removeEventListener(t, e, e.$), delete this[r])
        }

        var r = "__on" + t, o = t.indexOf("."), a = X;
        o > 0 && (t = t.slice(0, o));
        var s = ko.get(t);
        return s && (t = s, a = U), o ? e ? function () {
            var o = a(e, io(arguments));
            n.call(this), this.addEventListener(t, this[r] = o, o.$ = i), o._ = e
        } : n : e ? b : function () {
            var e, i = new RegExp("^__on([^.]+)" + to.requote(t) + "$");
            for (var n in this) if (e = n.match(i)) {
                var r = this[n];
                this.removeEventListener(e[1], r, r.$), delete this[n]
            }
        }
    }

    function X(t, e) {
        return function (i) {
            var n = to.event;
            to.event = i, e[0] = this.__data__;
            try {
                t.apply(this, e)
            } finally {
                to.event = n
            }
        }
    }

    function U(t, e) {
        var i = X(t, e);
        return function (t) {
            var e = this, n = t.relatedTarget;
            n && (n === e || 8 & n.compareDocumentPosition(e)) || i.call(e, t)
        }
    }

    function q(i) {
        var n = ".dragsuppress-" + ++To, r = "click" + n,
            o = to.select(e(i)).on("touchmove" + n, w).on("dragstart" + n, w).on("selectstart" + n, w);
        if (null == So && (So = !("onselectstart" in i) && x(i.style, "userSelect")), So) {
            var a = t(i).style, s = a[So];
            a[So] = "none"
        }
        return function (t) {
            if (o.on(n, null), So && (a[So] = s), t) {
                var e = function () {
                    o.on(r, null)
                };
                o.on(r, function () {
                    w(), e()
                }, !0), setTimeout(e, 0)
            }
        }
    }

    function $(t, i) {
        i.changedTouches && (i = i.changedTouches[0]);
        var n = t.ownerSVGElement || t;
        if (n.createSVGPoint) {
            var r = n.createSVGPoint();
            if (0 > Eo) {
                var o = e(t);
                if (o.scrollX || o.scrollY) {
                    var a = (n = to.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important"))[0][0].getScreenCTM();
                    Eo = !(a.f || a.e), n.remove()
                }
            }
            return Eo ? (r.x = i.pageX, r.y = i.pageY) : (r.x = i.clientX, r.y = i.clientY), [(r = r.matrixTransform(t.getScreenCTM().inverse())).x, r.y]
        }
        var s = t.getBoundingClientRect();
        return [i.clientX - s.left - t.clientLeft, i.clientY - s.top - t.clientTop]
    }

    function V() {
        return to.event.changedTouches[0].identifier
    }

    function K(t) {
        return t > 0 ? 1 : 0 > t ? -1 : 0
    }

    function Z(t, e, i) {
        return (e[0] - t[0]) * (i[1] - t[1]) - (e[1] - t[1]) * (i[0] - t[0])
    }

    function J(t) {
        return t > 1 ? 0 : -1 > t ? Po : Math.acos(t)
    }

    function Q(t) {
        return t > 1 ? Lo : -1 > t ? -Lo : Math.asin(t)
    }

    function tt(t) {
        return ((t = Math.exp(t)) + 1 / t) / 2
    }

    function et(t) {
        return (t = Math.sin(t / 2)) * t
    }

    function it() {
    }

    function nt(t, e, i) {
        return this instanceof nt ? (this.h = +t, this.s = +e, void (this.l = +i)) : arguments.length < 2 ? t instanceof nt ? new nt(t.h, t.s, t.l) : vt("" + t, yt, nt) : new nt(t, e, i)
    }

    function rt(t, e, i) {
        function n(t) {
            return Math.round(255 * function (t) {
                return t > 360 ? t -= 360 : 0 > t && (t += 360), 60 > t ? r + (o - r) * t / 60 : 180 > t ? o : 240 > t ? r + (o - r) * (240 - t) / 60 : r
            }(t))
        }

        var r, o;
        return t = isNaN(t) ? 0 : (t %= 360) < 0 ? t + 360 : t, e = isNaN(e) ? 0 : 0 > e ? 0 : e > 1 ? 1 : e, r = 2 * (i = 0 > i ? 0 : i > 1 ? 1 : i) - (o = .5 >= i ? i * (1 + e) : i + e - i * e), new ft(n(t + 120), n(t), n(t - 120))
    }

    function ot(t, e, i) {
        return this instanceof ot ? (this.h = +t, this.c = +e, void (this.l = +i)) : arguments.length < 2 ? t instanceof ot ? new ot(t.h, t.c, t.l) : ht(t instanceof st ? t.l : (t = xt((t = to.rgb(t)).r, t.g, t.b)).l, t.a, t.b) : new ot(t, e, i)
    }

    function at(t, e, i) {
        return isNaN(t) && (t = 0), isNaN(e) && (e = 0), new st(i, Math.cos(t *= No) * e, Math.sin(t) * e)
    }

    function st(t, e, i) {
        return this instanceof st ? (this.l = +t, this.a = +e, void (this.b = +i)) : arguments.length < 2 ? t instanceof st ? new st(t.l, t.a, t.b) : t instanceof ot ? at(t.h, t.c, t.l) : xt((t = ft(t)).r, t.g, t.b) : new st(t, e, i)
    }

    function lt(t, e, i) {
        var n = (t + 16) / 116, r = n + e / 500, o = n - i / 200;
        return new ft(dt(3.2404542 * (r = ct(r) * Go) - 1.5371385 * (n = ct(n) * Fo) - .4985314 * (o = ct(o) * Xo)), dt(-.969266 * r + 1.8760108 * n + .041556 * o), dt(.0556434 * r - .2040259 * n + 1.0572252 * o))
    }

    function ht(t, e, i) {
        return t > 0 ? new ot(Math.atan2(i, e) * zo, Math.sqrt(e * e + i * i), t) : new ot(NaN, NaN, t)
    }

    function ct(t) {
        return t > .206893034 ? t * t * t : (t - 4 / 29) / 7.787037
    }

    function ut(t) {
        return t > .008856 ? Math.pow(t, 1 / 3) : 7.787037 * t + 4 / 29
    }

    function dt(t) {
        return Math.round(255 * (.00304 >= t ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055))
    }

    function ft(t, e, i) {
        return this instanceof ft ? (this.r = ~~t, this.g = ~~e, void (this.b = ~~i)) : arguments.length < 2 ? t instanceof ft ? new ft(t.r, t.g, t.b) : vt("" + t, ft, rt) : new ft(t, e, i)
    }

    function pt(t) {
        return new ft(t >> 16, t >> 8 & 255, 255 & t)
    }

    function gt(t) {
        return pt(t) + ""
    }

    function mt(t) {
        return 16 > t ? "0" + Math.max(0, t).toString(16) : Math.min(255, t).toString(16)
    }

    function vt(t, e, i) {
        var n, r, o, a = 0, s = 0, l = 0;
        if (n = /([a-z]+)\((.*)\)/.exec(t = t.toLowerCase())) switch (r = n[2].split(","), n[1]) {
            case"hsl":
                return i(parseFloat(r[0]), parseFloat(r[1]) / 100, parseFloat(r[2]) / 100);
            case"rgb":
                return e(Mt(r[0]), Mt(r[1]), Mt(r[2]))
        }
        return (o = $o.get(t)) ? e(o.r, o.g, o.b) : (null == t || "#" !== t.charAt(0) || isNaN(o = parseInt(t.slice(1), 16)) || (4 === t.length ? (a = (3840 & o) >> 4, a |= a >> 4, s = 240 & o, s |= s >> 4, l = 15 & o, l |= l << 4) : 7 === t.length && (a = (16711680 & o) >> 16, s = (65280 & o) >> 8, l = 255 & o)), e(a, s, l))
    }

    function yt(t, e, i) {
        var n, r, o = Math.min(t /= 255, e /= 255, i /= 255), a = Math.max(t, e, i), s = a - o, l = (a + o) / 2;
        return s ? (r = .5 > l ? s / (a + o) : s / (2 - a - o), n = t == a ? (e - i) / s + (i > e ? 6 : 0) : e == a ? (i - t) / s + 2 : (t - e) / s + 4, n *= 60) : (n = NaN, r = l > 0 && 1 > l ? 0 : n), new nt(n, r, l)
    }

    function xt(t, e, i) {
        var n = ut((.4124564 * (t = bt(t)) + .3575761 * (e = bt(e)) + .1804375 * (i = bt(i))) / Go),
            r = ut((.2126729 * t + .7151522 * e + .072175 * i) / Fo);
        return st(116 * r - 16, 500 * (n - r), 200 * (r - ut((.0193339 * t + .119192 * e + .9503041 * i) / Xo)))
    }

    function bt(t) {
        return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
    }

    function Mt(t) {
        var e = parseFloat(t);
        return "%" === t.charAt(t.length - 1) ? Math.round(2.55 * e) : e
    }

    function At(t) {
        return "function" == typeof t ? t : function () {
            return t
        }
    }

    function wt(t) {
        return function (e, i, n) {
            return 2 === arguments.length && "function" == typeof i && (n = i, i = null), kt(e, i, t, n)
        }
    }

    function kt(t, e, i, n) {
        function r() {
            var t, e = l.status;
            if (!e && function (t) {
                var e = t.responseType;
                return e && "text" !== e ? t.response : t.responseText
            }(l) || e >= 200 && 300 > e || 304 === e) {
                try {
                    t = i.call(o, l)
                } catch (n) {
                    return void a.error.call(o, n)
                }
                a.load.call(o, t)
            } else a.error.call(o, l)
        }

        var o = {}, a = to.dispatch("beforesend", "progress", "load", "error"), s = {}, l = new XMLHttpRequest,
            h = null;
        return !this.XDomainRequest || "withCredentials" in l || !/^(http(s)?:)?\/\//.test(t) || (l = new XDomainRequest), "onload" in l ? l.onload = l.onerror = r : l.onreadystatechange = function () {
            l.readyState > 3 && r()
        }, l.onprogress = function (t) {
            var e = to.event;
            to.event = t;
            try {
                a.progress.call(o, l)
            } finally {
                to.event = e
            }
        }, o.header = function (t, e) {
            return t = (t + "").toLowerCase(), arguments.length < 2 ? s[t] : (null == e ? delete s[t] : s[t] = e + "", o)
        }, o.mimeType = function (t) {
            return arguments.length ? (e = null == t ? null : t + "", o) : e
        }, o.responseType = function (t) {
            return arguments.length ? (h = t, o) : h
        }, o.response = function (t) {
            return i = t, o
        }, ["get", "post"].forEach(function (t) {
            o[t] = function () {
                return o.send.apply(o, [t].concat(io(arguments)))
            }
        }), o.send = function (i, n, r) {
            if (2 === arguments.length && "function" == typeof n && (r = n, n = null), l.open(i, t, !0), null == e || "accept" in s || (s.accept = e + ",*/*"), l.setRequestHeader) for (var c in s) l.setRequestHeader(c, s[c]);
            return null != e && l.overrideMimeType && l.overrideMimeType(e), null != h && (l.responseType = h), null != r && o.on("error", r).on("load", function (t) {
                r(null, t)
            }), a.beforesend.call(o, l), l.send(null == n ? null : n), o
        }, o.abort = function () {
            return l.abort(), o
        }, to.rebind(o, a, "on"), null == n ? o : o.get(function (t) {
            return 1 === t.length ? function (e, i) {
                t(null == e ? i : null)
            } : t
        }(n))
    }

    function St(t, e, i) {
        var n = arguments.length;
        2 > n && (e = 0), 3 > n && (i = Date.now());
        var r = {c: t, t: i + e, n: null};
        return Ko ? Ko.n = r : Vo = r, Ko = r, Zo || (Jo = clearTimeout(Jo), Zo = 1, Qo(Tt)), r
    }

    function Tt() {
        var t = Et(), e = Ct() - t;
        e > 24 ? (isFinite(e) && (clearTimeout(Jo), Jo = setTimeout(Tt, e)), Zo = 0) : (Zo = 1, Qo(Tt))
    }

    function Et() {
        for (var t = Date.now(), e = Vo; e;) t >= e.t && e.c(t - e.t) && (e.c = null), e = e.n;
        return t
    }

    function Ct() {
        for (var t, e = Vo, i = 1 / 0; e;) e.c ? (e.t < i && (i = e.t), e = (t = e).n) : e = t ? t.n = e.n : Vo = e.n;
        return Ko = t, i
    }

    function Dt(t, e) {
        return e - (t ? Math.ceil(Math.log(t) / Math.LN10) : 1)
    }

    function Pt(t) {
        var e = t.decimal, i = t.thousands, n = t.grouping, r = t.currency, o = n && i ? function (t, e) {
            for (var r = t.length, o = [], a = 0, s = n[0], l = 0; r > 0 && s > 0 && (l + s + 1 > e && (s = Math.max(1, e - l)), o.push(t.substring(r -= s, r + s)), !((l += s + 1) > e));) s = n[a = (a + 1) % n.length];
            return o.reverse().join(i)
        } : v;
        return function (t) {
            var i = ea.exec(t), n = i[1] || " ", a = i[2] || ">", s = i[3] || "-", l = i[4] || "", h = i[5], c = +i[6],
                u = i[7], d = i[8], f = i[9], p = 1, g = "", m = "", v = !1, y = !0;
            switch (d && (d = +d.substring(1)), (h || "0" === n && "=" === a) && (h = n = "0", a = "="), f) {
                case"n":
                    u = !0, f = "g";
                    break;
                case"%":
                    p = 100, m = "%", f = "f";
                    break;
                case"p":
                    p = 100, m = "%", f = "r";
                    break;
                case"b":
                case"o":
                case"x":
                case"X":
                    "#" === l && (g = "0" + f.toLowerCase());
                case"c":
                    y = !1;
                case"d":
                    v = !0, d = 0;
                    break;
                case"s":
                    p = -1, f = "r"
            }
            "$" === l && (g = r[0], m = r[1]), "r" != f || d || (f = "g"), null != d && ("g" == f ? d = Math.max(1, Math.min(21, d)) : "e" != f && "f" != f || (d = Math.max(0, Math.min(20, d)))), f = ia.get(f) || _t;
            var x = h && u;
            return function (t) {
                var i = m;
                if (v && t % 1) return "";
                var r = 0 > t || 0 === t && 0 > 1 / t ? (t = -t, "-") : "-" === s ? "" : s;
                if (0 > p) {
                    var l = to.formatPrefix(t, d);
                    t = l.scale(t), i = l.symbol + m
                } else t *= p;
                var b, M, A = (t = f(t, d)).lastIndexOf(".");
                if (0 > A) {
                    var w = y ? t.lastIndexOf("e") : -1;
                    0 > w ? (b = t, M = "") : (b = t.substring(0, w), M = t.substring(w))
                } else b = t.substring(0, A), M = e + t.substring(A + 1);
                !h && u && (b = o(b, 1 / 0));
                var k = g.length + b.length + M.length + (x ? 0 : r.length),
                    S = c > k ? new Array(k = c - k + 1).join(n) : "";
                return x && (b = o(S + b, S.length ? c - M.length : 1 / 0)), r += g, t = b + M, ("<" === a ? r + t + S : ">" === a ? S + r + t : "^" === a ? S.substring(0, k >>= 1) + r + t + S.substring(k) : r + (x ? t : S + t)) + i
            }
        }
    }

    function _t(t) {
        return t + ""
    }

    function Ot() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0])
    }

    function Lt(t, e, i) {
        function n(e) {
            var i = t(e), n = o(i, 1);
            return n - e > e - i ? i : n
        }

        function r(i) {
            return e(i = t(new ra(i - 1)), 1), i
        }

        function o(t, i) {
            return e(t = new ra(+t), i), t
        }

        function a(t, n, o) {
            var a = r(t), s = [];
            if (o > 1) for (; n > a;) i(a) % o || s.push(new Date(+a)), e(a, 1); else for (; n > a;) s.push(new Date(+a)), e(a, 1);
            return s
        }

        t.floor = t, t.round = n, t.ceil = r, t.offset = o, t.range = a;
        var s = t.utc = Nt(t);
        return s.floor = s, s.round = Nt(n), s.ceil = Nt(r), s.offset = Nt(o), s.range = function (t, e, i) {
            try {
                ra = Ot;
                var n = new Ot;
                return n._ = t, a(n, e, i)
            } finally {
                ra = Date
            }
        }, t
    }

    function Nt(t) {
        return function (e, i) {
            try {
                ra = Ot;
                var n = new Ot;
                return n._ = e, t(n, i)._
            } finally {
                ra = Date
            }
        }
    }

    function zt(t) {
        function e(t) {
            function e(e) {
                for (var i, r, o, a = [], s = -1, l = 0; ++s < n;) 37 === t.charCodeAt(s) && (a.push(t.slice(l, s)), null != (r = aa[i = t.charAt(++s)]) && (i = t.charAt(++s)), (o = b[i]) && (i = o(e, null == r ? "e" === i ? " " : "0" : r)), a.push(i), l = s + 1);
                return a.push(t.slice(l, s)), a.join("")
            }

            var n = t.length;
            return e.parse = function (e) {
                var n = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null};
                if (i(n, t, e, 0) != e.length) return null;
                "p" in n && (n.H = n.H % 12 + 12 * n.p);
                var r = null != n.Z && ra !== Ot, o = new (r ? Ot : ra);
                return "j" in n ? o.setFullYear(n.y, 0, n.j) : "W" in n || "U" in n ? ("w" in n || (n.w = "W" in n ? 1 : 0), o.setFullYear(n.y, 0, 1), o.setFullYear(n.y, 0, "W" in n ? (n.w + 6) % 7 + 7 * n.W - (o.getDay() + 5) % 7 : n.w + 7 * n.U - (o.getDay() + 6) % 7)) : o.setFullYear(n.y, n.m, n.d), o.setHours(n.H + (n.Z / 100 | 0), n.M + n.Z % 100, n.S, n.L), r ? o._ : o
            }, e.toString = function () {
                return t
            }, e
        }

        function i(t, e, i, n) {
            for (var r, o, a, s = 0, l = e.length, h = i.length; l > s;) {
                if (n >= h) return -1;
                if (37 === (r = e.charCodeAt(s++))) {
                    if (a = e.charAt(s++), !(o = M[a in aa ? e.charAt(s++) : a]) || (n = o(t, i, n)) < 0) return -1
                } else if (r != i.charCodeAt(n++)) return -1
            }
            return n
        }

        var n = t.dateTime, r = t.date, o = t.time, a = t.periods, s = t.days, l = t.shortDays, h = t.months,
            c = t.shortMonths;
        e.utc = function (t) {
            function i(t) {
                try {
                    var e = new (ra = Ot);
                    return e._ = t, n(e)
                } finally {
                    ra = Date
                }
            }

            var n = e(t);
            return i.parse = function (t) {
                try {
                    ra = Ot;
                    var e = n.parse(t);
                    return e && e._
                } finally {
                    ra = Date
                }
            }, i.toString = n.toString, i
        }, e.multi = e.utc.multi = te;
        var u = to.map(), d = Rt(s), f = Bt(s), p = Rt(l), g = Bt(l), m = Rt(h), v = Bt(h), y = Rt(c), x = Bt(c);
        a.forEach(function (t, e) {
            u.set(t.toLowerCase(), e)
        });
        var b = {
            a: function (t) {
                return l[t.getDay()]
            }, A: function (t) {
                return s[t.getDay()]
            }, b: function (t) {
                return c[t.getMonth()]
            }, B: function (t) {
                return h[t.getMonth()]
            }, c: e(n), d: function (t, e) {
                return It(t.getDate(), e, 2)
            }, e: function (t, e) {
                return It(t.getDate(), e, 2)
            }, H: function (t, e) {
                return It(t.getHours(), e, 2)
            }, I: function (t, e) {
                return It(t.getHours() % 12 || 12, e, 2)
            }, j: function (t, e) {
                return It(1 + na.dayOfYear(t), e, 3)
            }, L: function (t, e) {
                return It(t.getMilliseconds(), e, 3)
            }, m: function (t, e) {
                return It(t.getMonth() + 1, e, 2)
            }, M: function (t, e) {
                return It(t.getMinutes(), e, 2)
            }, p: function (t) {
                return a[+(t.getHours() >= 12)]
            }, S: function (t, e) {
                return It(t.getSeconds(), e, 2)
            }, U: function (t, e) {
                return It(na.sundayOfYear(t), e, 2)
            }, w: function (t) {
                return t.getDay()
            }, W: function (t, e) {
                return It(na.mondayOfYear(t), e, 2)
            }, x: e(r), X: e(o), y: function (t, e) {
                return It(t.getFullYear() % 100, e, 2)
            }, Y: function (t, e) {
                return It(t.getFullYear() % 1e4, e, 4)
            }, Z: Jt, "%": function () {
                return "%"
            }
        }, M = {
            a: function (t, e, i) {
                p.lastIndex = 0;
                var n = p.exec(e.slice(i));
                return n ? (t.w = g.get(n[0].toLowerCase()), i + n[0].length) : -1
            }, A: function (t, e, i) {
                d.lastIndex = 0;
                var n = d.exec(e.slice(i));
                return n ? (t.w = f.get(n[0].toLowerCase()), i + n[0].length) : -1
            }, b: function (t, e, i) {
                y.lastIndex = 0;
                var n = y.exec(e.slice(i));
                return n ? (t.m = x.get(n[0].toLowerCase()), i + n[0].length) : -1
            }, B: function (t, e, i) {
                m.lastIndex = 0;
                var n = m.exec(e.slice(i));
                return n ? (t.m = v.get(n[0].toLowerCase()), i + n[0].length) : -1
            }, c: function (t, e, n) {
                return i(t, b.c.toString(), e, n)
            }, d: Ut, e: Ut, H: $t, I: $t, j: qt, L: Zt, m: Xt, M: Vt, p: function (t, e, i) {
                var n = u.get(e.slice(i, i += 2).toLowerCase());
                return null == n ? -1 : (t.p = n, i)
            }, S: Kt, U: Wt, w: jt, W: Ht, x: function (t, e, n) {
                return i(t, b.x.toString(), e, n)
            }, X: function (t, e, n) {
                return i(t, b.X.toString(), e, n)
            }, y: Gt, Y: Yt, Z: Ft, "%": Qt
        };
        return e
    }

    function It(t, e, i) {
        var n = 0 > t ? "-" : "", r = (n ? -t : t) + "", o = r.length;
        return n + (i > o ? new Array(i - o + 1).join(e) + r : r)
    }

    function Rt(t) {
        return new RegExp("^(?:" + t.map(to.requote).join("|") + ")", "i")
    }

    function Bt(t) {
        for (var e = new l, i = -1, n = t.length; ++i < n;) e.set(t[i].toLowerCase(), i);
        return e
    }

    function jt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 1));
        return n ? (t.w = +n[0], i + n[0].length) : -1
    }

    function Wt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i));
        return n ? (t.U = +n[0], i + n[0].length) : -1
    }

    function Ht(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i));
        return n ? (t.W = +n[0], i + n[0].length) : -1
    }

    function Yt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 4));
        return n ? (t.y = +n[0], i + n[0].length) : -1
    }

    function Gt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.y = function (t) {
            return t + (t > 68 ? 1900 : 2e3)
        }(+n[0]), i + n[0].length) : -1
    }

    function Ft(t, e, i) {
        return /^[+-]\d{4}$/.test(e = e.slice(i, i + 5)) ? (t.Z = -e, i + 5) : -1
    }

    function Xt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.m = n[0] - 1, i + n[0].length) : -1
    }

    function Ut(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.d = +n[0], i + n[0].length) : -1
    }

    function qt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 3));
        return n ? (t.j = +n[0], i + n[0].length) : -1
    }

    function $t(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.H = +n[0], i + n[0].length) : -1
    }

    function Vt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.M = +n[0], i + n[0].length) : -1
    }

    function Kt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 2));
        return n ? (t.S = +n[0], i + n[0].length) : -1
    }

    function Zt(t, e, i) {
        sa.lastIndex = 0;
        var n = sa.exec(e.slice(i, i + 3));
        return n ? (t.L = +n[0], i + n[0].length) : -1
    }

    function Jt(t) {
        var e = t.getTimezoneOffset(), i = e > 0 ? "-" : "+", n = co(e) / 60 | 0, r = co(e) % 60;
        return i + It(n, "0", 2) + It(r, "0", 2)
    }

    function Qt(t, e, i) {
        la.lastIndex = 0;
        var n = la.exec(e.slice(i, i + 1));
        return n ? i + n[0].length : -1
    }

    function te(t) {
        for (var e = t.length, i = -1; ++i < e;) t[i][0] = this(t[i][0]);
        return function (e) {
            for (var i = 0, n = t[i]; !n[1](e);) n = t[++i];
            return n[0](e)
        }
    }

    function ee() {
    }

    function ie(t, e, i) {
        var n = i.s = t + e, r = n - t, o = n - r;
        i.t = t - o + (e - r)
    }

    function ne(t, e) {
        t && da.hasOwnProperty(t.type) && da[t.type](t, e)
    }

    function re(t, e, i) {
        var n, r = -1, o = t.length - i;
        for (e.lineStart(); ++r < o;) n = t[r], e.point(n[0], n[1], n[2]);
        e.lineEnd()
    }

    function oe(t, e) {
        var i = -1, n = t.length;
        for (e.polygonStart(); ++i < n;) re(t[i], e, 1);
        e.polygonEnd()
    }

    function ae() {
        function t(t, e) {
            e = e * No / 2 + Po / 4;
            var i = (t *= No) - n, a = i >= 0 ? 1 : -1, s = a * i, l = Math.cos(e), h = Math.sin(e), c = o * h,
                u = r * l + c * Math.cos(s), d = c * a * Math.sin(s);
            pa.add(Math.atan2(d, u)), n = t, r = l, o = h
        }

        var e, i, n, r, o;
        ga.point = function (a, s) {
            ga.point = t, n = (e = a) * No, r = Math.cos(s = (i = s) * No / 2 + Po / 4), o = Math.sin(s)
        }, ga.lineEnd = function () {
            t(e, i)
        }
    }

    function se(t) {
        var e = t[0], i = t[1], n = Math.cos(i);
        return [n * Math.cos(e), n * Math.sin(e), Math.sin(i)]
    }

    function le(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function he(t, e) {
        return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
    }

    function ce(t, e) {
        t[0] += e[0], t[1] += e[1], t[2] += e[2]
    }

    function ue(t, e) {
        return [t[0] * e, t[1] * e, t[2] * e]
    }

    function de(t) {
        var e = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
        t[0] /= e, t[1] /= e, t[2] /= e
    }

    function fe(t) {
        return [Math.atan2(t[1], t[0]), Q(t[2])]
    }

    function pe(t, e) {
        return co(t[0] - e[0]) < Co && co(t[1] - e[1]) < Co
    }

    function ge(t, e) {
        t *= No;
        var i = Math.cos(e *= No);
        me(i * Math.cos(t), i * Math.sin(t), Math.sin(e))
    }

    function me(t, e, i) {
        ya += (t - ya) / ++ma, xa += (e - xa) / ma, ba += (i - ba) / ma
    }

    function ve() {
        function t(t, r) {
            t *= No;
            var o = Math.cos(r *= No), a = o * Math.cos(t), s = o * Math.sin(t), l = Math.sin(r),
                h = Math.atan2(Math.sqrt((h = i * l - n * s) * h + (h = n * a - e * l) * h + (h = e * s - i * a) * h), e * a + i * s + n * l);
            va += h, Ma += h * (e + (e = a)), Aa += h * (i + (i = s)), wa += h * (n + (n = l)), me(e, i, n)
        }

        var e, i, n;
        Ea.point = function (r, o) {
            r *= No;
            var a = Math.cos(o *= No);
            e = a * Math.cos(r), i = a * Math.sin(r), n = Math.sin(o), Ea.point = t, me(e, i, n)
        }
    }

    function ye() {
        Ea.point = ge
    }

    function xe() {
        function t(t, e) {
            t *= No;
            var i = Math.cos(e *= No), a = i * Math.cos(t), s = i * Math.sin(t), l = Math.sin(e), h = r * l - o * s,
                c = o * a - n * l, u = n * s - r * a, d = Math.sqrt(h * h + c * c + u * u), f = n * a + r * s + o * l,
                p = d && -J(f) / d, g = Math.atan2(d, f);
            ka += p * h, Sa += p * c, Ta += p * u, va += g, Ma += g * (n + (n = a)), Aa += g * (r + (r = s)), wa += g * (o + (o = l)), me(n, r, o)
        }

        var e, i, n, r, o;
        Ea.point = function (a, s) {
            e = a, i = s, Ea.point = t, a *= No;
            var l = Math.cos(s *= No);
            n = l * Math.cos(a), r = l * Math.sin(a), o = Math.sin(s), me(n, r, o)
        }, Ea.lineEnd = function () {
            t(e, i), Ea.lineEnd = ye, Ea.point = ge
        }
    }

    function be(t, e) {
        function i(i, n) {
            return i = t(i, n), e(i[0], i[1])
        }

        return t.invert && e.invert && (i.invert = function (i, n) {
            return (i = e.invert(i, n)) && t.invert(i[0], i[1])
        }), i
    }

    function Me() {
        return !0
    }

    function Ae(t, e, i, n, r) {
        var o = [], a = [];
        if (t.forEach(function (t) {
            if (!((e = t.length - 1) <= 0)) {
                var e, i = t[0], n = t[e];
                if (pe(i, n)) {
                    r.lineStart();
                    for (var s = 0; e > s; ++s) r.point((i = t[s])[0], i[1]);
                    return void r.lineEnd()
                }
                var l = new ke(i, t, null, !0), h = new ke(i, null, l, !1);
                l.o = h, o.push(l), a.push(h), l = new ke(n, t, null, !1), h = new ke(n, null, l, !0), l.o = h, o.push(l), a.push(h)
            }
        }), a.sort(e), we(o), we(a), o.length) {
            for (var s = 0, l = i, h = a.length; h > s; ++s) a[s].e = l = !l;
            for (var c, u, d = o[0]; ;) {
                for (var f = d, p = !0; f.v;) if ((f = f.n) === d) return;
                c = f.z, r.lineStart();
                do {
                    if (f.v = f.o.v = !0, f.e) {
                        if (p) for (s = 0, h = c.length; h > s; ++s) r.point((u = c[s])[0], u[1]); else n(f.x, f.n.x, 1, r);
                        f = f.n
                    } else {
                        if (p) for (s = (c = f.p.z).length - 1; s >= 0; --s) r.point((u = c[s])[0], u[1]); else n(f.x, f.p.x, -1, r);
                        f = f.p
                    }
                    c = (f = f.o).z, p = !p
                } while (!f.v);
                r.lineEnd()
            }
        }
    }

    function we(t) {
        if (e = t.length) {
            for (var e, i, n = 0, r = t[0]; ++n < e;) r.n = i = t[n], i.p = r, r = i;
            r.n = i = t[0], i.p = r
        }
    }

    function ke(t, e, i, n) {
        this.x = t, this.z = e, this.o = i, this.e = n, this.v = !1, this.n = this.p = null
    }

    function Se(t, e, i, n) {
        return function (r, o) {
            function a(e, i) {
                var n = r(e, i);
                t(e = n[0], i = n[1]) && o.point(e, i)
            }

            function s(t, e) {
                var i = r(t, e);
                m.point(i[0], i[1])
            }

            function l() {
                y.point = s, m.lineStart()
            }

            function h() {
                y.point = a, m.lineEnd()
            }

            function c(t, e) {
                g.push([t, e]);
                var i = r(t, e);
                b.point(i[0], i[1])
            }

            function u() {
                b.lineStart(), g = []
            }

            function d() {
                c(g[0][0], g[0][1]), b.lineEnd();
                var t, e = b.clean(), i = x.buffer(), n = i.length;
                if (g.pop(), p.push(g), g = null, n) if (1 & e) {
                    var r, a = -1;
                    if ((n = (t = i[0]).length - 1) > 0) {
                        for (M || (o.polygonStart(), M = !0), o.lineStart(); ++a < n;) o.point((r = t[a])[0], r[1]);
                        o.lineEnd()
                    }
                } else n > 1 && 2 & e && i.push(i.pop().concat(i.shift())), f.push(i.filter(Te))
            }

            var f, p, g, m = e(o), v = r.invert(n[0], n[1]), y = {
                point: a, lineStart: l, lineEnd: h, polygonStart: function () {
                    y.point = c, y.lineStart = u, y.lineEnd = d, f = [], p = []
                }, polygonEnd: function () {
                    y.point = a, y.lineStart = l, y.lineEnd = h, f = to.merge(f);
                    var t = function (t, e) {
                        var i = t[0], n = t[1], r = [Math.sin(i), -Math.cos(i), 0], o = 0, a = 0;
                        pa.reset();
                        for (var s = 0, l = e.length; l > s; ++s) {
                            var h = e[s], c = h.length;
                            if (c) for (var u = h[0], d = u[0], f = u[1] / 2 + Po / 4, p = Math.sin(f), g = Math.cos(f), m = 1; ;) {
                                m === c && (m = 0);
                                var v = (t = h[m])[0], y = t[1] / 2 + Po / 4, x = Math.sin(y), b = Math.cos(y),
                                    M = v - d, A = M >= 0 ? 1 : -1, w = A * M, k = w > Po, S = p * x;
                                if (pa.add(Math.atan2(S * A * Math.sin(w), g * b + S * Math.cos(w))), o += k ? M + A * _o : M, k ^ d >= i ^ v >= i) {
                                    var T = he(se(u), se(t));
                                    de(T);
                                    var E = he(r, T);
                                    de(E);
                                    var C = (k ^ M >= 0 ? -1 : 1) * Q(E[2]);
                                    (n > C || n === C && (T[0] || T[1])) && (a += k ^ M >= 0 ? 1 : -1)
                                }
                                if (!m++) break;
                                d = v, p = x, g = b, u = t
                            }
                        }
                        return (-Co > o || Co > o && -Co > pa) ^ 1 & a
                    }(v, p);
                    f.length ? (M || (o.polygonStart(), M = !0), Ae(f, Ce, t, i, o)) : t && (M || (o.polygonStart(), M = !0), o.lineStart(), i(null, null, 1, o), o.lineEnd()), M && (o.polygonEnd(), M = !1), f = p = null
                }, sphere: function () {
                    o.polygonStart(), o.lineStart(), i(null, null, 1, o), o.lineEnd(), o.polygonEnd()
                }
            }, x = Ee(), b = e(x), M = !1;
            return y
        }
    }

    function Te(t) {
        return t.length > 1
    }

    function Ee() {
        var t, e = [];
        return {
            lineStart: function () {
                e.push(t = [])
            }, point: function (e, i) {
                t.push([e, i])
            }, lineEnd: b, buffer: function () {
                var i = e;
                return e = [], t = null, i
            }, rejoin: function () {
                e.length > 1 && e.push(e.pop().concat(e.shift()))
            }
        }
    }

    function Ce(t, e) {
        return ((t = t.x)[0] < 0 ? t[1] - Lo - Co : Lo - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Lo - Co : Lo - e[1])
    }

    function De(t, e, i, n) {
        return function (r) {
            var o, a = r.a, s = r.b, l = a.x, h = a.y, c = 0, u = 1, d = s.x - l, f = s.y - h;
            if (o = t - l, d || !(o > 0)) {
                if (o /= d, 0 > d) {
                    if (c > o) return;
                    u > o && (u = o)
                } else if (d > 0) {
                    if (o > u) return;
                    o > c && (c = o)
                }
                if (o = i - l, d || !(0 > o)) {
                    if (o /= d, 0 > d) {
                        if (o > u) return;
                        o > c && (c = o)
                    } else if (d > 0) {
                        if (c > o) return;
                        u > o && (u = o)
                    }
                    if (o = e - h, f || !(o > 0)) {
                        if (o /= f, 0 > f) {
                            if (c > o) return;
                            u > o && (u = o)
                        } else if (f > 0) {
                            if (o > u) return;
                            o > c && (c = o)
                        }
                        if (o = n - h, f || !(0 > o)) {
                            if (o /= f, 0 > f) {
                                if (o > u) return;
                                o > c && (c = o)
                            } else if (f > 0) {
                                if (c > o) return;
                                u > o && (u = o)
                            }
                            return c > 0 && (r.a = {x: l + c * d, y: h + c * f}), 1 > u && (r.b = {
                                x: l + u * d,
                                y: h + u * f
                            }), r
                        }
                    }
                }
            }
        }
    }

    function Pe(t, e, i, n) {
        function r(n, r) {
            return co(n[0] - t) < Co ? r > 0 ? 0 : 3 : co(n[0] - i) < Co ? r > 0 ? 2 : 1 : co(n[1] - e) < Co ? r > 0 ? 1 : 0 : r > 0 ? 3 : 2
        }

        function o(t, e) {
            return a(t.x, e.x)
        }

        function a(t, e) {
            var i = r(t, 1), n = r(e, 1);
            return i !== n ? i - n : 0 === i ? e[1] - t[1] : 1 === i ? t[0] - e[0] : 2 === i ? t[1] - e[1] : e[0] - t[0]
        }

        return function (s) {
            function l(o, s, l, h) {
                var c = 0, u = 0;
                if (null == o || (c = r(o, l)) !== (u = r(s, l)) || a(o, s) < 0 ^ l > 0) do {
                    h.point(0 === c || 3 === c ? t : i, c > 1 ? n : e)
                } while ((c = (c + l + 4) % 4) !== u); else h.point(s[0], s[1])
            }

            function h(r, o) {
                return r >= t && i >= r && o >= e && n >= o
            }

            function c(t, e) {
                h(t, e) && s.point(t, e)
            }

            function u(t, e) {
                var i = h(t = Math.max(-Da, Math.min(Da, t)), e = Math.max(-Da, Math.min(Da, e)));
                if (f && p.push([t, e]), M) g = t, m = e, v = i, M = !1, i && (s.lineStart(), s.point(t, e)); else if (i && b) s.point(t, e); else {
                    var n = {a: {x: y, y: x}, b: {x: t, y: e}};
                    S(n) ? (b || (s.lineStart(), s.point(n.a.x, n.a.y)), s.point(n.b.x, n.b.y), i || s.lineEnd(), A = !1) : i && (s.lineStart(), s.point(t, e), A = !1)
                }
                y = t, x = e, b = i
            }

            var d, f, p, g, m, v, y, x, b, M, A, w = s, k = Ee(), S = De(t, e, i, n), T = {
                point: c, lineStart: function () {
                    T.point = u, f && f.push(p = []), M = !0, b = !1, y = x = NaN
                }, lineEnd: function () {
                    d && (u(g, m), v && b && k.rejoin(), d.push(k.buffer())), T.point = c, b && s.lineEnd()
                }, polygonStart: function () {
                    s = k, d = [], f = [], A = !0
                }, polygonEnd: function () {
                    s = w, d = to.merge(d);
                    var e = function (t) {
                        for (var e = 0, i = f.length, n = t[1], r = 0; i > r; ++r) for (var o, a = 1, s = f[r], l = s.length, h = s[0]; l > a; ++a) o = s[a], h[1] <= n ? o[1] > n && Z(h, o, t) > 0 && ++e : o[1] <= n && Z(h, o, t) < 0 && --e, h = o;
                        return 0 !== e
                    }([t, n]), i = A && e, r = d.length;
                    (i || r) && (s.polygonStart(), i && (s.lineStart(), l(null, null, 1, s), s.lineEnd()), r && Ae(d, o, e, l, s), s.polygonEnd()), d = f = p = null
                }
            };
            return T
        }
    }

    function _e(t) {
        var e = 0, i = Po / 3, n = Xe(t), r = n(e, i);
        return r.parallels = function (t) {
            return arguments.length ? n(e = t[0] * Po / 180, i = t[1] * Po / 180) : [e / Po * 180, i / Po * 180]
        }, r
    }

    function Oe(t, e) {
        function i(t, e) {
            var i = Math.sqrt(o - 2 * r * Math.sin(e)) / r;
            return [i * Math.sin(t *= r), a - i * Math.cos(t)]
        }

        var n = Math.sin(t), r = (n + Math.sin(e)) / 2, o = 1 + n * (2 * r - n), a = Math.sqrt(o) / r;
        return i.invert = function (t, e) {
            var i = a - e;
            return [Math.atan2(t, i) / r, Q((o - (t * t + i * i) * r * r) / (2 * r))]
        }, i
    }

    function Le() {
        function t(t, e) {
            _a += r * t - n * e, n = t, r = e
        }

        var e, i, n, r;
        Ia.point = function (o, a) {
            Ia.point = t, e = n = o, i = r = a
        }, Ia.lineEnd = function () {
            t(e, i)
        }
    }

    function Ne() {
        function t(t, e) {
            a.push("M", t, ",", e, o)
        }

        function e(t, e) {
            a.push("M", t, ",", e), s.point = i
        }

        function i(t, e) {
            a.push("L", t, ",", e)
        }

        function n() {
            s.point = t
        }

        function r() {
            a.push("Z")
        }

        var o = ze(4.5), a = [], s = {
            point: t, lineStart: function () {
                s.point = e
            }, lineEnd: n, polygonStart: function () {
                s.lineEnd = r
            }, polygonEnd: function () {
                s.lineEnd = n, s.point = t
            }, pointRadius: function (t) {
                return o = ze(t), s
            }, result: function () {
                if (a.length) {
                    var t = a.join("");
                    return a = [], t
                }
            }
        };
        return s
    }

    function ze(t) {
        return "m0," + t + "a" + t + "," + t + " 0 1,1 0," + -2 * t + "a" + t + "," + t + " 0 1,1 0," + 2 * t + "z"
    }

    function Ie(t, e) {
        ya += t, xa += e, ++ba
    }

    function Re() {
        function t(t, n) {
            var r = t - e, o = n - i, a = Math.sqrt(r * r + o * o);
            Ma += a * (e + t) / 2, Aa += a * (i + n) / 2, wa += a, Ie(e = t, i = n)
        }

        var e, i;
        Ba.point = function (n, r) {
            Ba.point = t, Ie(e = n, i = r)
        }
    }

    function Be() {
        Ba.point = Ie
    }

    function je() {
        function t(t, e) {
            var i = t - n, o = e - r, a = Math.sqrt(i * i + o * o);
            Ma += a * (n + t) / 2, Aa += a * (r + e) / 2, wa += a, ka += (a = r * t - n * e) * (n + t), Sa += a * (r + e), Ta += 3 * a, Ie(n = t, r = e)
        }

        var e, i, n, r;
        Ba.point = function (o, a) {
            Ba.point = t, Ie(e = n = o, i = r = a)
        }, Ba.lineEnd = function () {
            t(e, i)
        }
    }

    function We(t) {
        function e(e, i) {
            t.moveTo(e + a, i), t.arc(e, i, a, 0, _o)
        }

        function i(e, i) {
            t.moveTo(e, i), s.point = n
        }

        function n(e, i) {
            t.lineTo(e, i)
        }

        function r() {
            s.point = e
        }

        function o() {
            t.closePath()
        }

        var a = 4.5, s = {
            point: e, lineStart: function () {
                s.point = i
            }, lineEnd: r, polygonStart: function () {
                s.lineEnd = o
            }, polygonEnd: function () {
                s.lineEnd = r, s.point = e
            }, pointRadius: function (t) {
                return a = t, s
            }, result: b
        };
        return s
    }

    function He(t) {
        function e(t) {
            return (s ? n : i)(t)
        }

        function i(e) {
            return Ge(e, function (i, n) {
                i = t(i, n), e.point(i[0], i[1])
            })
        }

        function n(e) {
            function i(i, n) {
                i = t(i, n), e.point(i[0], i[1])
            }

            function n() {
                y = NaN, w.point = o, e.lineStart()
            }

            function o(i, n) {
                var o = se([i, n]), a = t(i, n);
                r(y, x, v, b, M, A, y = a[0], x = a[1], v = i, b = o[0], M = o[1], A = o[2], s, e), e.point(y, x)
            }

            function a() {
                w.point = i, e.lineEnd()
            }

            function l() {
                n(), w.point = h, w.lineEnd = c
            }

            function h(t, e) {
                o(u = t, e), d = y, f = x, p = b, g = M, m = A, w.point = o
            }

            function c() {
                r(y, x, v, b, M, A, d, f, u, p, g, m, s, e), w.lineEnd = a, a()
            }

            var u, d, f, p, g, m, v, y, x, b, M, A, w = {
                point: i, lineStart: n, lineEnd: a, polygonStart: function () {
                    e.polygonStart(), w.lineStart = l
                }, polygonEnd: function () {
                    e.polygonEnd(), w.lineStart = n
                }
            };
            return w
        }

        function r(e, i, n, s, l, h, c, u, d, f, p, g, m, v) {
            var y = c - e, x = u - i, b = y * y + x * x;
            if (b > 4 * o && m--) {
                var M = s + f, A = l + p, w = h + g, k = Math.sqrt(M * M + A * A + w * w), S = Math.asin(w /= k),
                    T = co(co(w) - 1) < Co || co(n - d) < Co ? (n + d) / 2 : Math.atan2(A, M), E = t(T, S), C = E[0],
                    D = E[1], P = C - e, _ = D - i, O = x * P - y * _;
                (O * O / b > o || co((y * P + x * _) / b - .5) > .3 || a > s * f + l * p + h * g) && (r(e, i, n, s, l, h, C, D, T, M /= k, A /= k, w, m, v), v.point(C, D), r(C, D, T, M, A, w, c, u, d, f, p, g, m, v))
            }
        }

        var o = .5, a = Math.cos(30 * No), s = 16;
        return e.precision = function (t) {
            return arguments.length ? (s = (o = t * t) > 0 && 16, e) : Math.sqrt(o)
        }, e
    }

    function Ye(t) {
        this.stream = t
    }

    function Ge(t, e) {
        return {
            point: e, sphere: function () {
                t.sphere()
            }, lineStart: function () {
                t.lineStart()
            }, lineEnd: function () {
                t.lineEnd()
            }, polygonStart: function () {
                t.polygonStart()
            }, polygonEnd: function () {
                t.polygonEnd()
            }
        }
    }

    function Fe(t) {
        return Xe(function () {
            return t
        })()
    }

    function Xe(t) {
        function e(t) {
            return [(t = s(t[0] * No, t[1] * No))[0] * d + l, h - t[1] * d]
        }

        function i(t) {
            return (t = s.invert((t[0] - l) / d, (h - t[1]) / d)) && [t[0] * zo, t[1] * zo]
        }

        function n() {
            s = be(a = Ve(y, x, b), o);
            var t = o(g, m);
            return l = f - t[0] * d, h = p + t[1] * d, r()
        }

        function r() {
            return c && (c.valid = !1, c = null), e
        }

        var o, a, s, l, h, c, u = He(function (t, e) {
            return [(t = o(t, e))[0] * d + l, h - t[1] * d]
        }), d = 150, f = 480, p = 250, g = 0, m = 0, y = 0, x = 0, b = 0, M = Ca, A = v, w = null, k = null;
        return e.stream = function (t) {
            return c && (c.valid = !1), (c = Ue(M(a, u(A(t))))).valid = !0, c
        }, e.clipAngle = function (t) {
            return arguments.length ? (M = null == t ? (w = t, Ca) : function (t) {
                function e(t, e) {
                    return Math.cos(t) * Math.cos(e) > r
                }

                function i(t, e, i) {
                    var n = [1, 0, 0], o = he(se(t), se(e)), a = le(o, o), s = o[0], l = a - s * s;
                    if (!l) return !i && t;
                    var h = r * a / l, c = -r * s / l, u = he(n, o), d = ue(n, h);
                    ce(d, ue(o, c));
                    var f = u, p = le(d, f), g = le(f, f), m = p * p - g * (le(d, d) - 1);
                    if (!(0 > m)) {
                        var v = Math.sqrt(m), y = ue(f, (-p - v) / g);
                        if (ce(y, d), y = fe(y), !i) return y;
                        var x, b = t[0], M = e[0], A = t[1], w = e[1];
                        b > M && (x = b, b = M, M = x);
                        var k = M - b, S = co(k - Po) < Co;
                        if (!S && A > w && (x = A, A = w, w = x), S || Co > k ? S ? A + w > 0 ^ y[1] < (co(y[0] - b) < Co ? A : w) : A <= y[1] && y[1] <= w : k > Po ^ (b <= y[0] && y[0] <= M)) {
                            var T = ue(f, (-p + v) / g);
                            return ce(T, d), [y, fe(T)]
                        }
                    }
                }

                function n(e, i) {
                    var n = o ? t : Po - t, r = 0;
                    return -n > e ? r |= 1 : e > n && (r |= 2), -n > i ? r |= 4 : i > n && (r |= 8), r
                }

                var r = Math.cos(t), o = r > 0, a = co(r) > Co;
                return Se(e, function (t) {
                    var r, s, l, h, c;
                    return {
                        lineStart: function () {
                            h = l = !1, c = 1
                        }, point: function (u, d) {
                            var f, p = [u, d], g = e(u, d),
                                m = o ? g ? 0 : n(u, d) : g ? n(u + (0 > u ? Po : -Po), d) : 0;
                            if (!r && (h = l = g) && t.lineStart(), g !== l && (f = i(r, p), (pe(r, f) || pe(p, f)) && (p[0] += Co, p[1] += Co, g = e(p[0], p[1]))), g !== l) c = 0, g ? (t.lineStart(), f = i(p, r), t.point(f[0], f[1])) : (f = i(r, p), t.point(f[0], f[1]), t.lineEnd()), r = f; else if (a && r && o ^ g) {
                                var v;
                                m & s || !(v = i(p, r, !0)) || (c = 0, o ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1])))
                            }
                            !g || r && pe(r, p) || t.point(p[0], p[1]), r = p, l = g, s = m
                        }, lineEnd: function () {
                            l && t.lineEnd(), r = null
                        }, clean: function () {
                            return c | (h && l) << 1
                        }
                    }
                }, Qe(t, 6 * No), o ? [0, -t] : [-Po, t - Po])
            }((w = +t) * No), r()) : w
        }, e.clipExtent = function (t) {
            return arguments.length ? (k = t, A = t ? Pe(t[0][0], t[0][1], t[1][0], t[1][1]) : v, r()) : k
        }, e.scale = function (t) {
            return arguments.length ? (d = +t, n()) : d
        }, e.translate = function (t) {
            return arguments.length ? (f = +t[0], p = +t[1], n()) : [f, p]
        }, e.center = function (t) {
            return arguments.length ? (g = t[0] % 360 * No, m = t[1] % 360 * No, n()) : [g * zo, m * zo]
        }, e.rotate = function (t) {
            return arguments.length ? (y = t[0] % 360 * No, x = t[1] % 360 * No, b = t.length > 2 ? t[2] % 360 * No : 0, n()) : [y * zo, x * zo, b * zo]
        }, to.rebind(e, u, "precision"), function () {
            return o = t.apply(this, arguments), e.invert = o.invert && i, n()
        }
    }

    function Ue(t) {
        return Ge(t, function (e, i) {
            t.point(e * No, i * No)
        })
    }

    function qe(t, e) {
        return [t, e]
    }

    function $e(t, e) {
        return [t > Po ? t - _o : -Po > t ? t + _o : t, e]
    }

    function Ve(t, e, i) {
        return t ? e || i ? be(Ze(t), Je(e, i)) : Ze(t) : e || i ? Je(e, i) : $e
    }

    function Ke(t) {
        return function (e, i) {
            return [(e += t) > Po ? e - _o : -Po > e ? e + _o : e, i]
        }
    }

    function Ze(t) {
        var e = Ke(t);
        return e.invert = Ke(-t), e
    }

    function Je(t, e) {
        function i(t, e) {
            var i = Math.cos(e), s = Math.cos(t) * i, l = Math.sin(t) * i, h = Math.sin(e), c = h * n + s * r;
            return [Math.atan2(l * o - c * a, s * n - h * r), Q(c * o + l * a)]
        }

        var n = Math.cos(t), r = Math.sin(t), o = Math.cos(e), a = Math.sin(e);
        return i.invert = function (t, e) {
            var i = Math.cos(e), s = Math.cos(t) * i, l = Math.sin(t) * i, h = Math.sin(e), c = h * o - l * a;
            return [Math.atan2(l * o + h * a, s * n + c * r), Q(c * n - s * r)]
        }, i
    }

    function Qe(t, e) {
        var i = Math.cos(t), n = Math.sin(t);
        return function (r, o, a, s) {
            var l = a * e;
            null != r ? (r = ti(i, r), o = ti(i, o), (a > 0 ? o > r : r > o) && (r += a * _o)) : (r = t + a * _o, o = t - .5 * l);
            for (var h, c = r; a > 0 ? c > o : o > c; c -= l) s.point((h = fe([i, -n * Math.cos(c), -n * Math.sin(c)]))[0], h[1])
        }
    }

    function ti(t, e) {
        var i = se(e);
        i[0] -= t, de(i);
        var n = J(-i[1]);
        return ((-i[2] < 0 ? -n : n) + 2 * Math.PI - Co) % (2 * Math.PI)
    }

    function ei(t, e, i) {
        var n = to.range(t, e - Co, i).concat(e);
        return function (t) {
            return n.map(function (e) {
                return [t, e]
            })
        }
    }

    function ii(t, e, i) {
        var n = to.range(t, e - Co, i).concat(e);
        return function (t) {
            return n.map(function (e) {
                return [e, t]
            })
        }
    }

    function ni(t) {
        return t.source
    }

    function ri(t) {
        return t.target
    }

    function oi(t, e) {
        function i(e, i) {
            var n = Math.cos(e), r = Math.cos(i), o = t(n * r);
            return [o * r * Math.sin(e), o * Math.sin(i)]
        }

        return i.invert = function (t, i) {
            var n = Math.sqrt(t * t + i * i), r = e(n), o = Math.sin(r), a = Math.cos(r);
            return [Math.atan2(t * o, n * a), Math.asin(n && i * o / n)]
        }, i
    }

    function ai(t, e) {
        function i(t, e) {
            a > 0 ? -Lo + Co > e && (e = -Lo + Co) : e > Lo - Co && (e = Lo - Co);
            var i = a / Math.pow(r(e), o);
            return [i * Math.sin(o * t), a - i * Math.cos(o * t)]
        }

        var n = Math.cos(t), r = function (t) {
            return Math.tan(Po / 4 + t / 2)
        }, o = t === e ? Math.sin(t) : Math.log(n / Math.cos(e)) / Math.log(r(e) / r(t)), a = n * Math.pow(r(t), o) / o;
        return o ? (i.invert = function (t, e) {
            var i = a - e, n = K(o) * Math.sqrt(t * t + i * i);
            return [Math.atan2(t, i) / o, 2 * Math.atan(Math.pow(a / n, 1 / o)) - Lo]
        }, i) : li
    }

    function si(t, e) {
        function i(t, e) {
            var i = o - e;
            return [i * Math.sin(r * t), o - i * Math.cos(r * t)]
        }

        var n = Math.cos(t), r = t === e ? Math.sin(t) : (n - Math.cos(e)) / (e - t), o = n / r + t;
        return co(r) < Co ? qe : (i.invert = function (t, e) {
            var i = o - e;
            return [Math.atan2(t, i) / r, o - K(r) * Math.sqrt(t * t + i * i)]
        }, i)
    }

    function li(t, e) {
        return [t, Math.log(Math.tan(Po / 4 + e / 2))]
    }

    function hi(t) {
        var e, i = Fe(t), n = i.scale, r = i.translate, o = i.clipExtent;
        return i.scale = function () {
            var t = n.apply(i, arguments);
            return t === i ? e ? i.clipExtent(null) : i : t
        }, i.translate = function () {
            var t = r.apply(i, arguments);
            return t === i ? e ? i.clipExtent(null) : i : t
        }, i.clipExtent = function (t) {
            var a = o.apply(i, arguments);
            if (a === i) {
                if (e = null == t) {
                    var s = Po * n(), l = r();
                    o([[l[0] - s, l[1] - s], [l[0] + s, l[1] + s]])
                }
            } else e && (a = null);
            return a
        }, i.clipExtent(null)
    }

    function ci(t, e) {
        return [Math.log(Math.tan(Po / 4 + e / 2)), -t]
    }

    function ui(t) {
        return t[0]
    }

    function di(t) {
        return t[1]
    }

    function fi(t) {
        for (var e = t.length, i = [0, 1], n = 2, r = 2; e > r; r++) {
            for (; n > 1 && Z(t[i[n - 2]], t[i[n - 1]], t[r]) <= 0;) --n;
            i[n++] = r
        }
        return i.slice(0, n)
    }

    function pi(t, e) {
        return t[0] - e[0] || t[1] - e[1]
    }

    function gi(t, e, i) {
        return (i[0] - e[0]) * (t[1] - e[1]) < (i[1] - e[1]) * (t[0] - e[0])
    }

    function mi(t, e, i, n) {
        var r = t[0], o = i[0], a = e[0] - r, s = n[0] - o, l = t[1], h = i[1], c = e[1] - l, u = n[1] - h,
            d = (s * (l - h) - u * (r - o)) / (u * a - s * c);
        return [r + d * a, l + d * c]
    }

    function vi(t) {
        var e = t[0], i = t[t.length - 1];
        return !(e[0] - i[0] || e[1] - i[1])
    }

    function yi() {
        Ri(this), this.edge = this.site = this.circle = null
    }

    function xi(t) {
        var e = Ja.pop() || new yi;
        return e.site = t, e
    }

    function bi(t) {
        Di(t), Va.remove(t), Ja.push(t), Ri(t)
    }

    function Mi(t) {
        var e = t.circle, i = e.x, n = e.cy, r = {x: i, y: n}, o = t.P, a = t.N, s = [t];
        bi(t);
        for (var l = o; l.circle && co(i - l.circle.x) < Co && co(n - l.circle.cy) < Co;) o = l.P, s.unshift(l), bi(l), l = o;
        s.unshift(l), Di(l);
        for (var h = a; h.circle && co(i - h.circle.x) < Co && co(n - h.circle.cy) < Co;) a = h.N, s.push(h), bi(h), h = a;
        s.push(h), Di(h);
        var c, u = s.length;
        for (c = 1; u > c; ++c) h = s[c], l = s[c - 1], Ni(h.edge, l.site, h.site, r);
        l = s[0], (h = s[u - 1]).edge = Oi(l.site, h.site, null, r), Ci(l), Ci(h)
    }

    function Ai(t) {
        for (var e, i, n, r, o = t.x, a = t.y, s = Va._; s;) if ((n = wi(s, a) - o) > Co) s = s.L; else {
            if (!((r = o - ki(s, a)) > Co)) {
                n > -Co ? (e = s.P, i = s) : r > -Co ? (e = s, i = s.N) : e = i = s;
                break
            }
            if (!s.R) {
                e = s;
                break
            }
            s = s.R
        }
        var l = xi(t);
        if (Va.insert(e, l), e || i) {
            if (e === i) return Di(e), i = xi(e.site), Va.insert(l, i), l.edge = i.edge = Oi(e.site, l.site), Ci(e), void Ci(i);
            if (!i) return void (l.edge = Oi(e.site, l.site));
            Di(e), Di(i);
            var h = e.site, c = h.x, u = h.y, d = t.x - c, f = t.y - u, p = i.site, g = p.x - c, m = p.y - u,
                v = 2 * (d * m - f * g), y = d * d + f * f, x = g * g + m * m,
                b = {x: (m * y - f * x) / v + c, y: (d * x - g * y) / v + u};
            Ni(i.edge, h, p, b), l.edge = Oi(h, t, null, b), i.edge = Oi(t, p, null, b), Ci(e), Ci(i)
        }
    }

    function wi(t, e) {
        var i = t.site, n = i.x, r = i.y, o = r - e;
        if (!o) return n;
        var a = t.P;
        if (!a) return -1 / 0;
        var s = (i = a.site).x, l = i.y, h = l - e;
        if (!h) return s;
        var c = s - n, u = 1 / o - 1 / h, d = c / h;
        return u ? (-d + Math.sqrt(d * d - 2 * u * (c * c / (-2 * h) - l + h / 2 + r - o / 2))) / u + n : (n + s) / 2
    }

    function ki(t, e) {
        var i = t.N;
        if (i) return wi(i, e);
        var n = t.site;
        return n.y === e ? n.x : 1 / 0
    }

    function Si(t) {
        this.site = t, this.edges = []
    }

    function Ti(t, e) {
        return e.angle - t.angle
    }

    function Ei() {
        Ri(this), this.x = this.y = this.arc = this.site = this.cy = null
    }

    function Ci(t) {
        var e = t.P, i = t.N;
        if (e && i) {
            var n = e.site, r = t.site, o = i.site;
            if (n !== o) {
                var a = r.x, s = r.y, l = n.x - a, h = n.y - s, c = o.x - a, u = 2 * (l * (m = o.y - s) - h * c);
                if (!(u >= -Do)) {
                    var d = l * l + h * h, f = c * c + m * m, p = (m * d - h * f) / u, g = (l * f - c * d) / u,
                        m = g + s, v = Qa.pop() || new Ei;
                    v.arc = t, v.site = r, v.x = p + a, v.y = m + Math.sqrt(p * p + g * g), v.cy = m, t.circle = v;
                    for (var y = null, x = Za._; x;) if (v.y < x.y || v.y === x.y && v.x <= x.x) {
                        if (!x.L) {
                            y = x.P;
                            break
                        }
                        x = x.L
                    } else {
                        if (!x.R) {
                            y = x;
                            break
                        }
                        x = x.R
                    }
                    Za.insert(y, v), y || (Ka = v)
                }
            }
        }
    }

    function Di(t) {
        var e = t.circle;
        e && (e.P || (Ka = e.N), Za.remove(e), Qa.push(e), Ri(e), t.circle = null)
    }

    function Pi(t, e) {
        var i = t.b;
        if (i) return !0;
        var n, r, o = t.a, a = e[0][0], s = e[1][0], l = e[0][1], h = e[1][1], c = t.l, u = t.r, d = c.x, f = c.y,
            p = u.x, g = u.y, m = (d + p) / 2, v = (f + g) / 2;
        if (g === f) {
            if (a > m || m >= s) return;
            if (d > p) {
                if (o) {
                    if (o.y >= h) return
                } else o = {x: m, y: l};
                i = {x: m, y: h}
            } else {
                if (o) {
                    if (o.y < l) return
                } else o = {x: m, y: h};
                i = {x: m, y: l}
            }
        } else if (r = v - (n = (d - p) / (g - f)) * m, -1 > n || n > 1) if (d > p) {
            if (o) {
                if (o.y >= h) return
            } else o = {x: (l - r) / n, y: l};
            i = {x: (h - r) / n, y: h}
        } else {
            if (o) {
                if (o.y < l) return
            } else o = {x: (h - r) / n, y: h};
            i = {x: (l - r) / n, y: l}
        } else if (g > f) {
            if (o) {
                if (o.x >= s) return
            } else o = {x: a, y: n * a + r};
            i = {x: s, y: n * s + r}
        } else {
            if (o) {
                if (o.x < a) return
            } else o = {x: s, y: n * s + r};
            i = {x: a, y: n * a + r}
        }
        return t.a = o, t.b = i, !0
    }

    function _i(t, e) {
        this.l = t, this.r = e, this.a = this.b = null
    }

    function Oi(t, e, i, n) {
        var r = new _i(t, e);
        return qa.push(r), i && Ni(r, t, e, i), n && Ni(r, e, t, n), $a[t.i].edges.push(new zi(r, t, e)), $a[e.i].edges.push(new zi(r, e, t)), r
    }

    function Li(t, e, i) {
        var n = new _i(t, null);
        return n.a = e, n.b = i, qa.push(n), n
    }

    function Ni(t, e, i, n) {
        t.a || t.b ? t.l === i ? t.b = n : t.a = n : (t.a = n, t.l = e, t.r = i)
    }

    function zi(t, e, i) {
        var n = t.a, r = t.b;
        this.edge = t, this.site = e, this.angle = i ? Math.atan2(i.y - e.y, i.x - e.x) : t.l === e ? Math.atan2(r.x - n.x, n.y - r.y) : Math.atan2(n.x - r.x, r.y - n.y)
    }

    function Ii() {
        this._ = null
    }

    function Ri(t) {
        t.U = t.C = t.L = t.R = t.P = t.N = null
    }

    function Bi(t, e) {
        var i = e, n = e.R, r = i.U;
        r ? r.L === i ? r.L = n : r.R = n : t._ = n, n.U = r, i.U = n, i.R = n.L, i.R && (i.R.U = i), n.L = i
    }

    function ji(t, e) {
        var i = e, n = e.L, r = i.U;
        r ? r.L === i ? r.L = n : r.R = n : t._ = n, n.U = r, i.U = n, i.L = n.R, i.L && (i.L.U = i), n.R = i
    }

    function Wi(t) {
        for (; t.L;) t = t.L;
        return t
    }

    function Hi(t, e) {
        var i, n, r, o = t.sort(Yi).pop();
        for (qa = [], $a = new Array(t.length), Va = new Ii, Za = new Ii; ;) if (r = Ka, o && (!r || o.y < r.y || o.y === r.y && o.x < r.x)) o.x === i && o.y === n || ($a[o.i] = new Si(o), Ai(o), i = o.x, n = o.y), o = t.pop(); else {
            if (!r) break;
            Mi(r.arc)
        }
        e && (function (t) {
            for (var e, i = qa, n = De(t[0][0], t[0][1], t[1][0], t[1][1]), r = i.length; r--;) (!Pi(e = i[r], t) || !n(e) || co(e.a.x - e.b.x) < Co && co(e.a.y - e.b.y) < Co) && (e.a = e.b = null, i.splice(r, 1))
        }(e), function (t) {
            for (var e, i, n, r, o, a, s, l, h, c, u = t[0][0], d = t[1][0], f = t[0][1], p = t[1][1], g = $a, m = g.length; m--;) if ((o = g[m]) && o.prepare()) for (l = (s = o.edges).length, a = 0; l > a;) n = (c = s[a].end()).x, r = c.y, e = (h = s[++a % l].start()).x, i = h.y, (co(n - e) > Co || co(r - i) > Co) && (s.splice(a, 0, new zi(Li(o.site, c, co(n - u) < Co && p - r > Co ? {
                x: u,
                y: co(e - u) < Co ? i : p
            } : co(r - p) < Co && d - n > Co ? {x: co(i - p) < Co ? e : d, y: p} : co(n - d) < Co && r - f > Co ? {
                x: d,
                y: co(e - d) < Co ? i : f
            } : co(r - f) < Co && n - u > Co ? {x: co(i - f) < Co ? e : u, y: f} : null), o.site, null)), ++l)
        }(e));
        var a = {cells: $a, edges: qa};
        return Va = Za = qa = $a = null, a
    }

    function Yi(t, e) {
        return e.y - t.y || e.x - t.x
    }

    function Gi(t, e, i) {
        return (t.x - i.x) * (e.y - t.y) - (t.x - e.x) * (i.y - t.y)
    }

    function Fi(t) {
        return t.x
    }

    function Xi(t) {
        return t.y
    }

    function Ui(t, e) {
        t = to.rgb(t), e = to.rgb(e);
        var i = t.r, n = t.g, r = t.b, o = e.r - i, a = e.g - n, s = e.b - r;
        return function (t) {
            return "#" + mt(Math.round(i + o * t)) + mt(Math.round(n + a * t)) + mt(Math.round(r + s * t))
        }
    }

    function qi(t, e) {
        var i, n = {}, r = {};
        for (i in t) i in e ? n[i] = Ki(t[i], e[i]) : r[i] = t[i];
        for (i in e) i in t || (r[i] = e[i]);
        return function (t) {
            for (i in n) r[i] = n[i](t);
            return r
        }
    }

    function $i(t, e) {
        return t = +t, e = +e, function (i) {
            return t * (1 - i) + e * i
        }
    }

    function Vi(t, e) {
        var i, n, r, o = es.lastIndex = is.lastIndex = 0, a = -1, s = [], l = [];
        for (t += "", e += ""; (i = es.exec(t)) && (n = is.exec(e));) (r = n.index) > o && (r = e.slice(o, r), s[a] ? s[a] += r : s[++a] = r), (i = i[0]) === (n = n[0]) ? s[a] ? s[a] += n : s[++a] = n : (s[++a] = null, l.push({
            i: a,
            x: $i(i, n)
        })), o = is.lastIndex;
        return o < e.length && (r = e.slice(o), s[a] ? s[a] += r : s[++a] = r), s.length < 2 ? l[0] ? (e = l[0].x, function (t) {
            return e(t) + ""
        }) : function () {
            return e
        } : (e = l.length, function (t) {
            for (var i, n = 0; e > n; ++n) s[(i = l[n]).i] = i.x(t);
            return s.join("")
        })
    }

    function Ki(t, e) {
        for (var i, n = to.interpolators.length; --n >= 0 && !(i = to.interpolators[n](t, e));) ;
        return i
    }

    function Zi(t, e) {
        var i, n = [], r = [], o = t.length, a = e.length, s = Math.min(t.length, e.length);
        for (i = 0; s > i; ++i) n.push(Ki(t[i], e[i]));
        for (; o > i; ++i) r[i] = t[i];
        for (; a > i; ++i) r[i] = e[i];
        return function (t) {
            for (i = 0; s > i; ++i) r[i] = n[i](t);
            return r
        }
    }

    function Ji(t) {
        return function (e) {
            return 1 - t(1 - e)
        }
    }

    function Qi(t) {
        return function (e) {
            return .5 * (.5 > e ? t(2 * e) : 2 - t(2 - 2 * e))
        }
    }

    function tn(t) {
        return t * t
    }

    function en(t) {
        return t * t * t
    }

    function nn(t) {
        if (0 >= t) return 0;
        if (t >= 1) return 1;
        var e = t * t, i = e * t;
        return 4 * (.5 > t ? i : 3 * (t - e) + i - .75)
    }

    function rn(t) {
        return 1 - Math.cos(t * Lo)
    }

    function on(t) {
        return Math.pow(2, 10 * (t - 1))
    }

    function an(t) {
        return 1 - Math.sqrt(1 - t * t)
    }

    function sn(t) {
        return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
    }

    function ln(t, e) {
        return e -= t, function (i) {
            return Math.round(t + e * i)
        }
    }

    function hn(t) {
        var e = [t.a, t.b], i = [t.c, t.d], n = un(e), r = cn(e, i), o = un(function (t, e, i) {
            return t[0] += i * e[0], t[1] += i * e[1], t
        }(i, e, -r)) || 0;
        e[0] * i[1] < i[0] * e[1] && (e[0] *= -1, e[1] *= -1, n *= -1, r *= -1), this.rotate = (n ? Math.atan2(e[1], e[0]) : Math.atan2(-i[0], i[1])) * zo, this.translate = [t.e, t.f], this.scale = [n, o], this.skew = o ? Math.atan2(r, o) * zo : 0
    }

    function cn(t, e) {
        return t[0] * e[0] + t[1] * e[1]
    }

    function un(t) {
        var e = Math.sqrt(cn(t, t));
        return e && (t[0] /= e, t[1] /= e), e
    }

    function dn(t) {
        return t.length ? t.pop() + "," : ""
    }

    function fn(t, e) {
        var i = [], n = [];
        return t = to.transform(t), e = to.transform(e), function (t, e, i, n) {
            if (t[0] !== e[0] || t[1] !== e[1]) {
                var r = i.push("translate(", null, ",", null, ")");
                n.push({i: r - 4, x: $i(t[0], e[0])}, {i: r - 2, x: $i(t[1], e[1])})
            } else (e[0] || e[1]) && i.push("translate(" + e + ")")
        }(t.translate, e.translate, i, n), function (t, e, i, n) {
            t !== e ? (t - e > 180 ? e += 360 : e - t > 180 && (t += 360), n.push({
                i: i.push(dn(i) + "rotate(", null, ")") - 2,
                x: $i(t, e)
            })) : e && i.push(dn(i) + "rotate(" + e + ")")
        }(t.rotate, e.rotate, i, n), function (t, e, i, n) {
            t !== e ? n.push({
                i: i.push(dn(i) + "skewX(", null, ")") - 2,
                x: $i(t, e)
            }) : e && i.push(dn(i) + "skewX(" + e + ")")
        }(t.skew, e.skew, i, n), function (t, e, i, n) {
            if (t[0] !== e[0] || t[1] !== e[1]) {
                var r = i.push(dn(i) + "scale(", null, ",", null, ")");
                n.push({i: r - 4, x: $i(t[0], e[0])}, {i: r - 2, x: $i(t[1], e[1])})
            } else 1 === e[0] && 1 === e[1] || i.push(dn(i) + "scale(" + e + ")")
        }(t.scale, e.scale, i, n), t = e = null, function (t) {
            for (var e, r = -1, o = n.length; ++r < o;) i[(e = n[r]).i] = e.x(t);
            return i.join("")
        }
    }

    function pn(t, e) {
        return e = (e -= t = +t) || 1 / e, function (i) {
            return (i - t) / e
        }
    }

    function gn(t, e) {
        return e = (e -= t = +t) || 1 / e, function (i) {
            return Math.max(0, Math.min(1, (i - t) / e))
        }
    }

    function mn(t) {
        for (var e = t.source, i = t.target, n = function (t, e) {
            if (t === e) return t;
            for (var i = vn(t), n = vn(e), r = i.pop(), o = n.pop(), a = null; r === o;) a = r, r = i.pop(), o = n.pop();
            return a
        }(e, i), r = [e]; e !== n;) e = e.parent, r.push(e);
        for (var o = r.length; i !== n;) r.splice(o, 0, i), i = i.parent;
        return r
    }

    function vn(t) {
        for (var e = [], i = t.parent; null != i;) e.push(t), t = i, i = i.parent;
        return e.push(t), e
    }

    function yn(t) {
        t.fixed |= 2
    }

    function xn(t) {
        t.fixed &= -7
    }

    function bn(t) {
        t.fixed |= 4, t.px = t.x, t.py = t.y
    }

    function Mn(t) {
        t.fixed &= -5
    }

    function An(t, e) {
        return to.rebind(t, e, "sort", "children", "value"), t.nodes = t, t.links = Cn, t
    }

    function wn(t, e) {
        for (var i = [t]; null != (t = i.pop());) if (e(t), (r = t.children) && (n = r.length)) for (var n, r; --n >= 0;) i.push(r[n])
    }

    function kn(t, e) {
        for (var i = [t], n = []; null != (t = i.pop());) if (n.push(t), (o = t.children) && (r = o.length)) for (var r, o, a = -1; ++a < r;) i.push(o[a]);
        for (; null != (t = n.pop());) e(t)
    }

    function Sn(t) {
        return t.children
    }

    function Tn(t) {
        return t.value
    }

    function En(t, e) {
        return e.value - t.value
    }

    function Cn(t) {
        return to.merge(t.map(function (t) {
            return (t.children || []).map(function (e) {
                return {source: t, target: e}
            })
        }))
    }

    function Dn(t) {
        return t.x
    }

    function Pn(t) {
        return t.y
    }

    function _n(t, e, i) {
        t.y0 = e, t.y = i
    }

    function On(t) {
        return to.range(t.length)
    }

    function Ln(t) {
        for (var e = -1, i = t[0].length, n = []; ++e < i;) n[e] = 0;
        return n
    }

    function Nn(t) {
        for (var e, i = 1, n = 0, r = t[0][1], o = t.length; o > i; ++i) (e = t[i][1]) > r && (n = i, r = e);
        return n
    }

    function zn(t) {
        return t.reduce(In, 0)
    }

    function In(t, e) {
        return t + e[1]
    }

    function Rn(t, e) {
        return Bn(t, Math.ceil(Math.log(e.length) / Math.LN2 + 1))
    }

    function Bn(t, e) {
        for (var i = -1, n = +t[0], r = (t[1] - n) / e, o = []; ++i <= e;) o[i] = r * i + n;
        return o
    }

    function jn(t) {
        return [to.min(t), to.max(t)]
    }

    function Wn(t, e) {
        return t.value - e.value
    }

    function Hn(t, e) {
        var i = t._pack_next;
        t._pack_next = e, e._pack_prev = t, e._pack_next = i, i._pack_prev = e
    }

    function Yn(t, e) {
        t._pack_next = e, e._pack_prev = t
    }

    function Gn(t, e) {
        var i = e.x - t.x, n = e.y - t.y, r = t.r + e.r;
        return .999 * r * r > i * i + n * n
    }

    function Fn(t) {
        function e(t) {
            c = Math.min(t.x - t.r, c), u = Math.max(t.x + t.r, u), d = Math.min(t.y - t.r, d), f = Math.max(t.y + t.r, f)
        }

        if ((i = t.children) && (h = i.length)) {
            var i, n, r, o, a, s, l, h, c = 1 / 0, u = -1 / 0, d = 1 / 0, f = -1 / 0;
            if (i.forEach(Xn), (n = i[0]).x = -n.r, n.y = 0, e(n), h > 1 && ((r = i[1]).x = r.r, r.y = 0, e(r), h > 2)) for (qn(n, r, o = i[2]), e(o), Hn(n, o), n._pack_prev = o, Hn(o, r), r = n._pack_next, a = 3; h > a; a++) {
                qn(n, r, o = i[a]);
                var p = 0, g = 1, m = 1;
                for (s = r._pack_next; s !== r; s = s._pack_next, g++) if (Gn(s, o)) {
                    p = 1;
                    break
                }
                if (1 == p) for (l = n._pack_prev; l !== s._pack_prev && !Gn(l, o); l = l._pack_prev, m++) ;
                p ? (m > g || g == m && r.r < n.r ? Yn(n, r = s) : Yn(n = l, r), a--) : (Hn(n, o), r = o, e(o))
            }
            var v = (c + u) / 2, y = (d + f) / 2, x = 0;
            for (a = 0; h > a; a++) (o = i[a]).x -= v, o.y -= y, x = Math.max(x, o.r + Math.sqrt(o.x * o.x + o.y * o.y));
            t.r = x, i.forEach(Un)
        }
    }

    function Xn(t) {
        t._pack_next = t._pack_prev = t
    }

    function Un(t) {
        delete t._pack_next, delete t._pack_prev
    }

    function qn(t, e, i) {
        var n = t.r + i.r, r = e.x - t.x, o = e.y - t.y;
        if (n && (r || o)) {
            var a = e.r + i.r, s = r * r + o * o, l = .5 + ((n *= n) - (a *= a)) / (2 * s),
                h = Math.sqrt(Math.max(0, 2 * a * (n + s) - (n -= s) * n - a * a)) / (2 * s);
            i.x = t.x + l * r + h * o, i.y = t.y + l * o - h * r
        } else i.x = t.x + n, i.y = t.y
    }

    function $n(t, e) {
        return t.parent == e.parent ? 1 : 2
    }

    function Vn(t) {
        var e = t.children;
        return e.length ? e[0] : t.t
    }

    function Kn(t) {
        var e, i = t.children;
        return (e = i.length) ? i[e - 1] : t.t
    }

    function Zn(t, e, i) {
        var n = i / (e.i - t.i);
        e.c -= n, e.s += i, t.c += n, e.z += i, e.m += i
    }

    function Jn(t, e, i) {
        return t.a.parent === e.parent ? t.a : i
    }

    function Qn(t) {
        return {x: t.x, y: t.y, dx: t.dx, dy: t.dy}
    }

    function tr(t, e) {
        var i = t.x + e[3], n = t.y + e[0], r = t.dx - e[1] - e[3], o = t.dy - e[0] - e[2];
        return 0 > r && (i += r / 2, r = 0), 0 > o && (n += o / 2, o = 0), {x: i, y: n, dx: r, dy: o}
    }

    function er(t) {
        var e = t[0], i = t[t.length - 1];
        return i > e ? [e, i] : [i, e]
    }

    function ir(t) {
        return t.rangeExtent ? t.rangeExtent() : er(t.range())
    }

    function nr(t, e, i, n) {
        var r = i(t[0], t[1]), o = n(e[0], e[1]);
        return function (t) {
            return o(r(t))
        }
    }

    function rr(t, e) {
        var i, n = 0, r = t.length - 1, o = t[n], a = t[r];
        return o > a && (i = n, n = r, r = i, i = o, o = a, a = i), t[n] = e.floor(o), t[r] = e.ceil(a), t
    }

    function or(t) {
        return t ? {
            floor: function (e) {
                return Math.floor(e / t) * t
            }, ceil: function (e) {
                return Math.ceil(e / t) * t
            }
        } : fs
    }

    function ar(t, e, i, n) {
        var r = [], o = [], a = 0, s = Math.min(t.length, e.length) - 1;
        for (t[s] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++a <= s;) r.push(i(t[a - 1], t[a])), o.push(n(e[a - 1], e[a]));
        return function (e) {
            var i = to.bisect(t, e, 1, s) - 1;
            return o[i](r[i](e))
        }
    }

    function sr(t, e) {
        return to.rebind(t, e, "range", "rangeRound", "interpolate", "clamp")
    }

    function lr(t, e) {
        return rr(t, or(hr(t, e)[2])), rr(t, or(hr(t, e)[2])), t
    }

    function hr(t, e) {
        null == e && (e = 10);
        var i = er(t), n = i[1] - i[0], r = Math.pow(10, Math.floor(Math.log(n / e) / Math.LN10)), o = e / n * r;
        return .15 >= o ? r *= 10 : .35 >= o ? r *= 5 : .75 >= o && (r *= 2), i[0] = Math.ceil(i[0] / r) * r, i[1] = Math.floor(i[1] / r) * r + .5 * r, i[2] = r, i
    }

    function cr(t, e) {
        return to.range.apply(to, hr(t, e))
    }

    function ur(t, e, i) {
        var n = hr(t, e);
        if (i) {
            var r = ea.exec(i);
            if (r.shift(), "s" === r[8]) {
                var o = to.formatPrefix(Math.max(co(n[0]), co(n[1])));
                return r[7] || (r[7] = "." + dr(o.scale(n[2]))), r[8] = "f", i = to.format(r.join("")), function (t) {
                    return i(o.scale(t)) + o.symbol
                }
            }
            r[7] || (r[7] = "." + function (t, e) {
                var i = dr(e[2]);
                return t in ps ? Math.abs(i - dr(Math.max(co(e[0]), co(e[1])))) + +("e" !== t) : i - 2 * ("%" === t)
            }(r[8], n)), i = r.join("")
        } else i = ",." + dr(n[2]) + "f";
        return to.format(i)
    }

    function dr(t) {
        return -Math.floor(Math.log(t) / Math.LN10 + .01)
    }

    function fr(t) {
        return function (e) {
            return 0 > e ? -Math.pow(-e, t) : Math.pow(e, t)
        }
    }

    function pr() {
        return 0
    }

    function gr(t) {
        return t.innerRadius
    }

    function mr(t) {
        return t.outerRadius
    }

    function vr(t) {
        return t.startAngle
    }

    function yr(t) {
        return t.endAngle
    }

    function xr(t) {
        return t && t.padAngle
    }

    function br(t, e, i, n) {
        return (t - i) * e - (e - n) * t > 0 ? 0 : 1
    }

    function Mr(t, e, i, n, r) {
        var o = t[0] - e[0], a = t[1] - e[1], s = (r ? n : -n) / Math.sqrt(o * o + a * a), l = s * a, h = -s * o,
            c = t[0] + l, u = t[1] + h, d = e[0] + l, f = e[1] + h, p = (c + d) / 2, g = (u + f) / 2, m = d - c,
            v = f - u, y = m * m + v * v, x = i - n, b = c * f - d * u,
            M = (0 > v ? -1 : 1) * Math.sqrt(Math.max(0, x * x * y - b * b)), A = (b * v - m * M) / y,
            w = (-b * m - v * M) / y, k = (b * v + m * M) / y, S = (-b * m + v * M) / y, T = A - p, E = w - g,
            C = k - p, D = S - g;
        return T * T + E * E > C * C + D * D && (A = k, w = S), [[A - l, w - h], [A * i / x, w * i / x]]
    }

    function Ar(t) {
        function e(e) {
            function a() {
                h.push("M", o(t(c), s))
            }

            for (var l, h = [], c = [], u = -1, d = e.length, f = At(i), p = At(n); ++u < d;) r.call(this, l = e[u], u) ? c.push([+f.call(this, l, u), +p.call(this, l, u)]) : c.length && (a(), c = []);
            return c.length && a(), h.length ? h.join("") : null
        }

        var i = ui, n = di, r = Me, o = wr, a = o.key, s = .7;
        return e.x = function (t) {
            return arguments.length ? (i = t, e) : i
        }, e.y = function (t) {
            return arguments.length ? (n = t, e) : n
        }, e.defined = function (t) {
            return arguments.length ? (r = t, e) : r
        }, e.interpolate = function (t) {
            return arguments.length ? (a = "function" == typeof t ? o = t : (o = As.get(t) || wr).key, e) : a
        }, e.tension = function (t) {
            return arguments.length ? (s = t, e) : s
        }, e
    }

    function wr(t) {
        return t.length > 1 ? t.join("L") : t + "Z"
    }

    function kr(t) {
        return t.join("L") + "Z"
    }

    function Sr(t) {
        for (var e = 0, i = t.length, n = t[0], r = [n[0], ",", n[1]]; ++e < i;) r.push("V", (n = t[e])[1], "H", n[0]);
        return r.join("")
    }

    function Tr(t) {
        for (var e = 0, i = t.length, n = t[0], r = [n[0], ",", n[1]]; ++e < i;) r.push("H", (n = t[e])[0], "V", n[1]);
        return r.join("")
    }

    function Er(t, e) {
        if (e.length < 1 || t.length != e.length && t.length != e.length + 2) return wr(t);
        var i = t.length != e.length, n = "", r = t[0], o = t[1], a = e[0], s = a, l = 1;
        if (i && (n += "Q" + (o[0] - 2 * a[0] / 3) + "," + (o[1] - 2 * a[1] / 3) + "," + o[0] + "," + o[1], r = t[1], l = 2), e.length > 1) {
            s = e[1], o = t[l], l++, n += "C" + (r[0] + a[0]) + "," + (r[1] + a[1]) + "," + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1];
            for (var h = 2; h < e.length; h++, l++) o = t[l], s = e[h], n += "S" + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1]
        }
        if (i) {
            var c = t[l];
            n += "Q" + (o[0] + 2 * s[0] / 3) + "," + (o[1] + 2 * s[1] / 3) + "," + c[0] + "," + c[1]
        }
        return n
    }

    function Cr(t, e) {
        for (var i, n = [], r = (1 - e) / 2, o = t[0], a = t[1], s = 1, l = t.length; ++s < l;) i = o, o = a, a = t[s], n.push([r * (a[0] - i[0]), r * (a[1] - i[1])]);
        return n
    }

    function Dr(t) {
        if (t.length < 3) return wr(t);
        var e = 1, i = t.length, n = t[0], r = n[0], o = n[1], a = [r, r, r, (n = t[1])[0]], s = [o, o, o, n[1]],
            l = [r, ",", o, "L", Pr(Ss, a), ",", Pr(Ss, s)];
        for (t.push(t[i - 1]); ++e <= i;) n = t[e], a.shift(), a.push(n[0]), s.shift(), s.push(n[1]), _r(l, a, s);
        return t.pop(), l.push("L", n), l.join("")
    }

    function Pr(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
    }

    function _r(t, e, i) {
        t.push("C", Pr(ws, e), ",", Pr(ws, i), ",", Pr(ks, e), ",", Pr(ks, i), ",", Pr(Ss, e), ",", Pr(Ss, i))
    }

    function Or(t, e) {
        return (e[1] - t[1]) / (e[0] - t[0])
    }

    function Lr(t) {
        for (var e, i, n, r, o = [], a = function (t) {
            for (var e = 0, i = t.length - 1, n = [], r = t[0], o = t[1], a = n[0] = Or(r, o); ++e < i;) n[e] = (a + (a = Or(r = o, o = t[e + 1]))) / 2;
            return n[e] = a, n
        }(t), s = -1, l = t.length - 1; ++s < l;) e = Or(t[s], t[s + 1]), co(e) < Co ? a[s] = a[s + 1] = 0 : (r = (i = a[s] / e) * i + (n = a[s + 1] / e) * n) > 9 && (r = 3 * e / Math.sqrt(r), a[s] = r * i, a[s + 1] = r * n);
        for (s = -1; ++s <= l;) r = (t[Math.min(l, s + 1)][0] - t[Math.max(0, s - 1)][0]) / (6 * (1 + a[s] * a[s])), o.push([r || 0, a[s] * r || 0]);
        return o
    }

    function Nr(t) {
        for (var e, i, n, r = -1, o = t.length; ++r < o;) i = (e = t[r])[0], n = e[1] - Lo, e[0] = i * Math.cos(n), e[1] = i * Math.sin(n);
        return t
    }

    function zr(t) {
        function e(e) {
            function l() {
                g.push("M", s(t(v), u), c, h(t(m.reverse()), u), "Z")
            }

            for (var d, f, p, g = [], m = [], v = [], y = -1, x = e.length, b = At(i), M = At(r), A = i === n ? function () {
                return f
            } : At(n), w = r === o ? function () {
                return p
            } : At(o); ++y < x;) a.call(this, d = e[y], y) ? (m.push([f = +b.call(this, d, y), p = +M.call(this, d, y)]), v.push([+A.call(this, d, y), +w.call(this, d, y)])) : m.length && (l(), m = [], v = []);
            return m.length && l(), g.length ? g.join("") : null
        }

        var i = ui, n = ui, r = 0, o = di, a = Me, s = wr, l = s.key, h = s, c = "L", u = .7;
        return e.x = function (t) {
            return arguments.length ? (i = n = t, e) : n
        }, e.x0 = function (t) {
            return arguments.length ? (i = t, e) : i
        }, e.x1 = function (t) {
            return arguments.length ? (n = t, e) : n
        }, e.y = function (t) {
            return arguments.length ? (r = o = t, e) : o
        }, e.y0 = function (t) {
            return arguments.length ? (r = t, e) : r
        }, e.y1 = function (t) {
            return arguments.length ? (o = t, e) : o
        }, e.defined = function (t) {
            return arguments.length ? (a = t, e) : a
        }, e.interpolate = function (t) {
            return arguments.length ? (l = "function" == typeof t ? s = t : (s = As.get(t) || wr).key, h = s.reverse || s, c = s.closed ? "M" : "L", e) : l
        }, e.tension = function (t) {
            return arguments.length ? (u = t, e) : u
        }, e
    }

    function Ir(t) {
        return t.radius
    }

    function Rr(t) {
        return [t.x, t.y]
    }

    function Br() {
        return 64
    }

    function jr() {
        return "circle"
    }

    function Wr(t) {
        var e = Math.sqrt(t / Po);
        return "M0," + e + "A" + e + "," + e + " 0 1,1 0," + -e + "A" + e + "," + e + " 0 1,1 0," + e + "Z"
    }

    function Hr(t) {
        return function () {
            var e, i, n;
            (e = this[t]) && (n = e[i = e.active]) && (n.timer.c = null, n.timer.t = NaN, --e.count ? delete e[i] : delete this[t], e.active += .5, n.event && n.event.interrupt.call(this, this.__data__, n.index))
        }
    }

    function Yr(t, e, i) {
        return mo(t, Os), t.namespace = e, t.id = i, t
    }

    function Gr(t, e, i, n) {
        var r = t.id, o = t.namespace;
        return Y(t, "function" == typeof i ? function (t, a, s) {
            t[o][r].tween.set(e, n(i.call(t, t.__data__, a, s)))
        } : (i = n(i), function (t) {
            t[o][r].tween.set(e, i)
        }))
    }

    function Fr(t) {
        return null == t && (t = ""), function () {
            this.textContent = t
        }
    }

    function Xr(t) {
        return null == t ? "__transition__" : "__transition_" + t + "__"
    }

    function Ur(t, e, i, n, r) {
        function o(i) {
            var r = f.active, o = f[r];
            for (var l in o && (o.timer.c = null, o.timer.t = NaN, --f.count, delete f[r], o.event && o.event.interrupt.call(t, t.__data__, o.index)), f) if (n > +l) {
                var g = f[l];
                g.timer.c = null, g.timer.t = NaN, --f.count, delete f[l]
            }
            h.c = a, St(function () {
                return h.c && a(i || 1) && (h.c = null, h.t = NaN), 1
            }, 0, s), f.active = n, p.event && p.event.start.call(t, t.__data__, e), d = [], p.tween.forEach(function (i, n) {
                (n = n.call(t, t.__data__, e)) && d.push(n)
            }), u = p.ease, c = p.duration
        }

        function a(r) {
            for (var o = r / c, a = u(o), s = d.length; s > 0;) d[--s].call(t, a);
            return o >= 1 ? (p.event && p.event.end.call(t, t.__data__, e), --f.count ? delete f[n] : delete t[i], 1) : void 0
        }

        var s, h, c, u, d, f = t[i] || (t[i] = {active: 0, count: 0}), p = f[n];
        p || (s = r.time, h = St(function (t) {
            var e = p.delay;
            return h.t = e + s, t >= e ? o(t - e) : void (h.c = o)
        }, 0, s), p = f[n] = {
            tween: new l,
            time: s,
            timer: h,
            delay: r.delay,
            duration: r.duration,
            ease: r.ease,
            index: e
        }, r = null, ++f.count)
    }

    function qr(t, e, i) {
        t.attr("transform", function (t) {
            var n = e(t);
            return "translate(" + (isFinite(n) ? n : i(t)) + ",0)"
        })
    }

    function $r(t, e, i) {
        t.attr("transform", function (t) {
            var n = e(t);
            return "translate(0," + (isFinite(n) ? n : i(t)) + ")"
        })
    }

    function Vr(t) {
        return t.toISOString()
    }

    function Kr(t, e, i) {
        function n(e) {
            return t(e)
        }

        function r(t, i) {
            var n = (t[1] - t[0]) / i, r = to.bisect(Hs, n);
            return r == Hs.length ? [e.year, hr(t.map(function (t) {
                return t / 31536e6
            }), i)[2]] : r ? e[n / Hs[r - 1] < Hs[r] / n ? r - 1 : r] : [Fs, hr(t, i)[2]]
        }

        return n.invert = function (e) {
            return Zr(t.invert(e))
        }, n.domain = function (e) {
            return arguments.length ? (t.domain(e), n) : t.domain().map(Zr)
        }, n.nice = function (t, e) {
            function i(i) {
                return !isNaN(i) && !t.range(i, Zr(+i + 1), e).length
            }

            var o = n.domain(), a = er(o), s = null == t ? r(a, 10) : "number" == typeof t && r(a, t);
            return s && (t = s[0], e = s[1]), n.domain(rr(o, e > 1 ? {
                floor: function (e) {
                    for (; i(e = t.floor(e));) e = Zr(e - 1);
                    return e
                }, ceil: function (e) {
                    for (; i(e = t.ceil(e));) e = Zr(+e + 1);
                    return e
                }
            } : t))
        }, n.ticks = function (t, e) {
            var i = er(n.domain()),
                o = null == t ? r(i, 10) : "number" == typeof t ? r(i, t) : !t.range && [{range: t}, e];
            return o && (t = o[0], e = o[1]), t.range(i[0], Zr(+i[1] + 1), 1 > e ? 1 : e)
        }, n.tickFormat = function () {
            return i
        }, n.copy = function () {
            return Kr(t.copy(), e, i)
        }, sr(n, t)
    }

    function Zr(t) {
        return new Date(t)
    }

    function Jr(t) {
        return JSON.parse(t.responseText)
    }

    function Qr(t) {
        var e = no.createRange();
        return e.selectNode(no.body), e.createContextualFragment(t.responseText)
    }

    var to = {version: "3.5.17"}, eo = [].slice, io = function (t) {
        return eo.call(t)
    }, no = this.document;
    if (no) try {
        io(no.documentElement.childNodes)[0].nodeType
    } catch (qs) {
        io = function (t) {
            for (var e = t.length, i = new Array(e); e--;) i[e] = t[e];
            return i
        }
    }
    if (Date.now || (Date.now = function () {
        return +new Date
    }), no) try {
        no.createElement("DIV").style.setProperty("opacity", 0, "")
    } catch ($s) {
        var ro = this.Element.prototype, oo = ro.setAttribute, ao = ro.setAttributeNS,
            so = this.CSSStyleDeclaration.prototype, lo = so.setProperty;
        ro.setAttribute = function (t, e) {
            oo.call(this, t, e + "")
        }, ro.setAttributeNS = function (t, e, i) {
            ao.call(this, t, e, i + "")
        }, so.setProperty = function (t, e, i) {
            lo.call(this, t, e + "", i)
        }
    }
    to.ascending = i, to.descending = function (t, e) {
        return t > e ? -1 : e > t ? 1 : e >= t ? 0 : NaN
    }, to.min = function (t, e) {
        var i, n, r = -1, o = t.length;
        if (1 === arguments.length) {
            for (; ++r < o;) if (null != (n = t[r]) && n >= n) {
                i = n;
                break
            }
            for (; ++r < o;) null != (n = t[r]) && i > n && (i = n)
        } else {
            for (; ++r < o;) if (null != (n = e.call(t, t[r], r)) && n >= n) {
                i = n;
                break
            }
            for (; ++r < o;) null != (n = e.call(t, t[r], r)) && i > n && (i = n)
        }
        return i
    }, to.max = function (t, e) {
        var i, n, r = -1, o = t.length;
        if (1 === arguments.length) {
            for (; ++r < o;) if (null != (n = t[r]) && n >= n) {
                i = n;
                break
            }
            for (; ++r < o;) null != (n = t[r]) && n > i && (i = n)
        } else {
            for (; ++r < o;) if (null != (n = e.call(t, t[r], r)) && n >= n) {
                i = n;
                break
            }
            for (; ++r < o;) null != (n = e.call(t, t[r], r)) && n > i && (i = n)
        }
        return i
    }, to.extent = function (t, e) {
        var i, n, r, o = -1, a = t.length;
        if (1 === arguments.length) {
            for (; ++o < a;) if (null != (n = t[o]) && n >= n) {
                i = r = n;
                break
            }
            for (; ++o < a;) null != (n = t[o]) && (i > n && (i = n), n > r && (r = n))
        } else {
            for (; ++o < a;) if (null != (n = e.call(t, t[o], o)) && n >= n) {
                i = r = n;
                break
            }
            for (; ++o < a;) null != (n = e.call(t, t[o], o)) && (i > n && (i = n), n > r && (r = n))
        }
        return [i, r]
    }, to.sum = function (t, e) {
        var i, n = 0, o = t.length, a = -1;
        if (1 === arguments.length) for (; ++a < o;) r(i = +t[a]) && (n += i); else for (; ++a < o;) r(i = +e.call(t, t[a], a)) && (n += i);
        return n
    }, to.mean = function (t, e) {
        var i, o = 0, a = t.length, s = -1, l = a;
        if (1 === arguments.length) for (; ++s < a;) r(i = n(t[s])) ? o += i : --l; else for (; ++s < a;) r(i = n(e.call(t, t[s], s))) ? o += i : --l;
        return l ? o / l : void 0
    }, to.quantile = function (t, e) {
        var i = (t.length - 1) * e + 1, n = Math.floor(i), r = +t[n - 1], o = i - n;
        return o ? r + o * (t[n] - r) : r
    }, to.median = function (t, e) {
        var o, a = [], s = t.length, l = -1;
        if (1 === arguments.length) for (; ++l < s;) r(o = n(t[l])) && a.push(o); else for (; ++l < s;) r(o = n(e.call(t, t[l], l))) && a.push(o);
        return a.length ? to.quantile(a.sort(i), .5) : void 0
    }, to.variance = function (t, e) {
        var i, o, a = t.length, s = 0, l = 0, h = -1, c = 0;
        if (1 === arguments.length) for (; ++h < a;) r(i = n(t[h])) && (l += (o = i - s) * (i - (s += o / ++c))); else for (; ++h < a;) r(i = n(e.call(t, t[h], h))) && (l += (o = i - s) * (i - (s += o / ++c)));
        return c > 1 ? l / (c - 1) : void 0
    }, to.deviation = function () {
        var t = to.variance.apply(this, arguments);
        return t ? Math.sqrt(t) : t
    };
    var ho = o(i);
    to.bisectLeft = ho.left, to.bisect = to.bisectRight = ho.right, to.bisector = function (t) {
        return o(1 === t.length ? function (e, n) {
            return i(t(e), n)
        } : t)
    }, to.shuffle = function (t, e, i) {
        (o = arguments.length) < 3 && (i = t.length, 2 > o && (e = 0));
        for (var n, r, o = i - e; o;) r = Math.random() * o-- | 0, n = t[o + e], t[o + e] = t[r + e], t[r + e] = n;
        return t
    }, to.permute = function (t, e) {
        for (var i = e.length, n = new Array(i); i--;) n[i] = t[e[i]];
        return n
    }, to.pairs = function (t) {
        for (var e = 0, i = t.length - 1, n = t[0], r = new Array(0 > i ? 0 : i); i > e;) r[e] = [n, n = t[++e]];
        return r
    }, to.transpose = function (t) {
        if (!(r = t.length)) return [];
        for (var e = -1, i = to.min(t, a), n = new Array(i); ++e < i;) for (var r, o = -1, s = n[e] = new Array(r); ++o < r;) s[o] = t[o][e];
        return n
    }, to.zip = function () {
        return to.transpose(arguments)
    }, to.keys = function (t) {
        var e = [];
        for (var i in t) e.push(i);
        return e
    }, to.values = function (t) {
        var e = [];
        for (var i in t) e.push(t[i]);
        return e
    }, to.entries = function (t) {
        var e = [];
        for (var i in t) e.push({key: i, value: t[i]});
        return e
    }, to.merge = function (t) {
        for (var e, i, n, r = t.length, o = -1, a = 0; ++o < r;) a += t[o].length;
        for (i = new Array(a); --r >= 0;) for (e = (n = t[r]).length; --e >= 0;) i[--a] = n[e];
        return i
    };
    var co = Math.abs;
    to.range = function (t, e, i) {
        if (arguments.length < 3 && (i = 1, arguments.length < 2 && (e = t, t = 0)), (e - t) / i == 1 / 0) throw new Error("infinite range");
        var n, r = [], o = function (t) {
            for (var e = 1; t * e % 1;) e *= 10;
            return e
        }(co(i)), a = -1;
        if (t *= o, e *= o, 0 > (i *= o)) for (; (n = t + i * ++a) > e;) r.push(n / o); else for (; (n = t + i * ++a) < e;) r.push(n / o);
        return r
    }, to.map = function (t, e) {
        var i = new l;
        if (t instanceof l) t.forEach(function (t, e) {
            i.set(t, e)
        }); else if (Array.isArray(t)) {
            var n, r = -1, o = t.length;
            if (1 === arguments.length) for (; ++r < o;) i.set(r, t[r]); else for (; ++r < o;) i.set(e.call(t, n = t[r], r), n)
        } else for (var a in t) i.set(a, t[a]);
        return i
    };
    var uo = "__proto__", fo = "\0";
    s(l, {
        has: u, get: function (t) {
            return this._[h(t)]
        }, set: function (t, e) {
            return this._[h(t)] = e
        }, remove: d, keys: f, values: function () {
            var t = [];
            for (var e in this._) t.push(this._[e]);
            return t
        }, entries: function () {
            var t = [];
            for (var e in this._) t.push({key: c(e), value: this._[e]});
            return t
        }, size: p, empty: g, forEach: function (t) {
            for (var e in this._) t.call(this, c(e), this._[e])
        }
    }), to.nest = function () {
        function t(o, a, s) {
            if (s >= r.length) return i ? i.call(n, a) : e ? a.sort(e) : a;
            for (var h, c, u, d, f = -1, p = a.length, g = r[s++], m = new l; ++f < p;) (d = m.get(h = g(c = a[f]))) ? d.push(c) : m.set(h, [c]);
            return o ? (c = o(), u = function (e, i) {
                c.set(e, t(o, i, s))
            }) : (c = {}, u = function (e, i) {
                c[e] = t(o, i, s)
            }), m.forEach(u), c
        }

        var e, i, n = {}, r = [], o = [];
        return n.map = function (e, i) {
            return t(i, e, 0)
        }, n.entries = function (e) {
            return function t(e, i) {
                if (i >= r.length) return e;
                var n = [], a = o[i++];
                return e.forEach(function (e, r) {
                    n.push({key: e, values: t(r, i)})
                }), a ? n.sort(function (t, e) {
                    return a(t.key, e.key)
                }) : n
            }(t(to.map, e, 0), 0)
        }, n.key = function (t) {
            return r.push(t), n
        }, n.sortKeys = function (t) {
            return o[r.length - 1] = t, n
        }, n.sortValues = function (t) {
            return e = t, n
        }, n.rollup = function (t) {
            return i = t, n
        }, n
    }, to.set = function (t) {
        var e = new m;
        if (t) for (var i = 0, n = t.length; n > i; ++i) e.add(t[i]);
        return e
    }, s(m, {
        has: u, add: function (t) {
            return this._[h(t += "")] = !0, t
        }, remove: d, values: f, size: p, empty: g, forEach: function (t) {
            for (var e in this._) t.call(this, c(e))
        }
    }), to.behavior = {}, to.rebind = function (t, e) {
        for (var i, n = 1, r = arguments.length; ++n < r;) t[i = arguments[n]] = y(t, e, e[i]);
        return t
    };
    var po = ["webkit", "ms", "moz", "Moz", "o", "O"];
    to.dispatch = function () {
        for (var t = new M, e = -1, i = arguments.length; ++e < i;) t[arguments[e]] = A(t);
        return t
    }, M.prototype.on = function (t, e) {
        var i = t.indexOf("."), n = "";
        if (i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), t) return arguments.length < 2 ? this[t].on(n) : this[t].on(n, e);
        if (2 === arguments.length) {
            if (null == e) for (t in this) this.hasOwnProperty(t) && this[t].on(n, null);
            return this
        }
    }, to.event = null, to.requote = function (t) {
        return t.replace(go, "\\$&")
    };
    var go = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, mo = {}.__proto__ ? function (t, e) {
        t.__proto__ = e
    } : function (t, e) {
        for (var i in e) t[i] = e[i]
    }, vo = function (t, e) {
        return e.querySelector(t)
    }, yo = function (t, e) {
        return e.querySelectorAll(t)
    }, xo = function (t, e) {
        var i = t.matches || t[x(t, "matchesSelector")];
        return (xo = function (t, e) {
            return i.call(t, e)
        })(t, e)
    };
    "function" == typeof Sizzle && (vo = function (t, e) {
        return Sizzle(t, e)[0] || null
    }, yo = Sizzle, xo = Sizzle.matchesSelector), to.selection = function () {
        return to.select(no.documentElement)
    };
    var bo = to.selection.prototype = [];
    bo.select = function (t) {
        var e, i, n, r, o = [];
        t = E(t);
        for (var a = -1, s = this.length; ++a < s;) {
            o.push(e = []), e.parentNode = (n = this[a]).parentNode;
            for (var l = -1, h = n.length; ++l < h;) (r = n[l]) ? (e.push(i = t.call(r, r.__data__, l, a)), i && "__data__" in r && (i.__data__ = r.__data__)) : e.push(null)
        }
        return T(o)
    }, bo.selectAll = function (t) {
        var e, i, n = [];
        t = C(t);
        for (var r = -1, o = this.length; ++r < o;) for (var a = this[r], s = -1, l = a.length; ++s < l;) (i = a[s]) && (n.push(e = io(t.call(i, i.__data__, s, r))), e.parentNode = i);
        return T(n)
    };
    var Mo = "http://www.w3.org/1999/xhtml", Ao = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: Mo,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    to.ns = {
        prefix: Ao, qualify: function (t) {
            var e = t.indexOf(":"), i = t;
            return e >= 0 && "xmlns" !== (i = t.slice(0, e)) && (t = t.slice(e + 1)), Ao.hasOwnProperty(i) ? {
                space: Ao[i],
                local: t
            } : t
        }
    }, bo.attr = function (t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) {
                var i = this.node();
                return (t = to.ns.qualify(t)).local ? i.getAttributeNS(t.space, t.local) : i.getAttribute(t)
            }
            for (e in t) this.each(D(e, t[e]));
            return this
        }
        return this.each(D(t, e))
    }, bo.classed = function (t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) {
                var i = this.node(), n = (t = O(t)).length, r = -1;
                if (e = i.classList) {
                    for (; ++r < n;) if (!e.contains(t[r])) return !1
                } else for (e = i.getAttribute("class"); ++r < n;) if (!_(t[r]).test(e)) return !1;
                return !0
            }
            for (e in t) this.each(L(e, t[e]));
            return this
        }
        return this.each(L(t, e))
    }, bo.style = function (t, i, n) {
        var r = arguments.length;
        if (3 > r) {
            if ("string" != typeof t) {
                for (n in 2 > r && (i = ""), t) this.each(z(n, t[n], i));
                return this
            }
            if (2 > r) {
                var o = this.node();
                return e(o).getComputedStyle(o, null).getPropertyValue(t)
            }
            n = ""
        }
        return this.each(z(t, i, n))
    }, bo.property = function (t, e) {
        if (arguments.length < 2) {
            if ("string" == typeof t) return this.node()[t];
            for (e in t) this.each(I(e, t[e]));
            return this
        }
        return this.each(I(t, e))
    }, bo.text = function (t) {
        return arguments.length ? this.each("function" == typeof t ? function () {
            var e = t.apply(this, arguments);
            this.textContent = null == e ? "" : e
        } : null == t ? function () {
            this.textContent = ""
        } : function () {
            this.textContent = t
        }) : this.node().textContent
    }, bo.html = function (t) {
        return arguments.length ? this.each("function" == typeof t ? function () {
            var e = t.apply(this, arguments);
            this.innerHTML = null == e ? "" : e
        } : null == t ? function () {
            this.innerHTML = ""
        } : function () {
            this.innerHTML = t
        }) : this.node().innerHTML
    }, bo.append = function (t) {
        return t = R(t), this.select(function () {
            return this.appendChild(t.apply(this, arguments))
        })
    }, bo.insert = function (t, e) {
        return t = R(t), e = E(e), this.select(function () {
            return this.insertBefore(t.apply(this, arguments), e.apply(this, arguments) || null)
        })
    }, bo.remove = function () {
        return this.each(B)
    }, bo.data = function (t, e) {
        function i(t, i) {
            var n, r, o, a = t.length, u = i.length, d = Math.min(a, u), f = new Array(u), p = new Array(u),
                g = new Array(a);
            if (e) {
                var m, v = new l, y = new Array(a);
                for (n = -1; ++n < a;) (r = t[n]) && (v.has(m = e.call(r, r.__data__, n)) ? g[n] = r : v.set(m, r), y[n] = m);
                for (n = -1; ++n < u;) (r = v.get(m = e.call(i, o = i[n], n))) ? !0 !== r && (f[n] = r, r.__data__ = o) : p[n] = j(o), v.set(m, !0);
                for (n = -1; ++n < a;) n in y && !0 !== v.get(y[n]) && (g[n] = t[n])
            } else {
                for (n = -1; ++n < d;) r = t[n], o = i[n], r ? (r.__data__ = o, f[n] = r) : p[n] = j(o);
                for (; u > n; ++n) p[n] = j(i[n]);
                for (; a > n; ++n) g[n] = t[n]
            }
            p.update = f, p.parentNode = f.parentNode = g.parentNode = t.parentNode, s.push(p), h.push(f), c.push(g)
        }

        var n, r, o = -1, a = this.length;
        if (!arguments.length) {
            for (t = new Array(a = (n = this[0]).length); ++o < a;) (r = n[o]) && (t[o] = r.__data__);
            return t
        }
        var s = G([]), h = T([]), c = T([]);
        if ("function" == typeof t) for (; ++o < a;) i(n = this[o], t.call(n, n.parentNode.__data__, o)); else for (; ++o < a;) i(n = this[o], t);
        return h.enter = function () {
            return s
        }, h.exit = function () {
            return c
        }, h
    }, bo.datum = function (t) {
        return arguments.length ? this.property("__data__", t) : this.property("__data__")
    }, bo.filter = function (t) {
        var e, i, n, r = [];
        "function" != typeof t && (t = W(t));
        for (var o = 0, a = this.length; a > o; o++) {
            r.push(e = []), e.parentNode = (i = this[o]).parentNode;
            for (var s = 0, l = i.length; l > s; s++) (n = i[s]) && t.call(n, n.__data__, s, o) && e.push(n)
        }
        return T(r)
    }, bo.order = function () {
        for (var t = -1, e = this.length; ++t < e;) for (var i, n = this[t], r = n.length - 1, o = n[r]; --r >= 0;) (i = n[r]) && (o && o !== i.nextSibling && o.parentNode.insertBefore(i, o), o = i);
        return this
    }, bo.sort = function (t) {
        t = H.apply(this, arguments);
        for (var e = -1, i = this.length; ++e < i;) this[e].sort(t);
        return this.order()
    }, bo.each = function (t) {
        return Y(this, function (e, i, n) {
            t.call(e, e.__data__, i, n)
        })
    }, bo.call = function (t) {
        var e = io(arguments);
        return t.apply(e[0] = this, e), this
    }, bo.empty = function () {
        return !this.node()
    }, bo.node = function () {
        for (var t = 0, e = this.length; e > t; t++) for (var i = this[t], n = 0, r = i.length; r > n; n++) {
            var o = i[n];
            if (o) return o
        }
        return null
    }, bo.size = function () {
        var t = 0;
        return Y(this, function () {
            ++t
        }), t
    };
    var wo = [];
    to.selection.enter = G, to.selection.enter.prototype = wo, wo.append = bo.append, wo.empty = bo.empty, wo.node = bo.node, wo.call = bo.call, wo.size = bo.size, wo.select = function (t) {
        for (var e, i, n, r, o, a = [], s = -1, l = this.length; ++s < l;) {
            n = (r = this[s]).update, a.push(e = []), e.parentNode = r.parentNode;
            for (var h = -1, c = r.length; ++h < c;) (o = r[h]) ? (e.push(n[h] = i = t.call(r.parentNode, o.__data__, h, s)), i.__data__ = o.__data__) : e.push(null)
        }
        return T(a)
    }, wo.insert = function (t, e) {
        return arguments.length < 2 && (e = function (t) {
            var e, i;
            return function (n, r, o) {
                var a, s = t[o].update, l = s.length;
                for (o != i && (i = o, e = 0), r >= e && (e = r + 1); !(a = s[e]) && ++e < l;) ;
                return a
            }
        }(this)), bo.insert.call(this, t, e)
    }, to.select = function (e) {
        var i;
        return "string" == typeof e ? (i = [vo(e, no)]).parentNode = no.documentElement : (i = [e]).parentNode = t(e), T([i])
    }, to.selectAll = function (t) {
        var e;
        return "string" == typeof t ? (e = io(yo(t, no))).parentNode = no.documentElement : (e = io(t)).parentNode = null, T([e])
    }, bo.on = function (t, e, i) {
        var n = arguments.length;
        if (3 > n) {
            if ("string" != typeof t) {
                for (i in 2 > n && (e = !1), t) this.each(F(i, t[i], e));
                return this
            }
            if (2 > n) return (n = this.node()["__on" + t]) && n._;
            i = !1
        }
        return this.each(F(t, e, i))
    };
    var ko = to.map({mouseenter: "mouseover", mouseleave: "mouseout"});
    no && ko.forEach(function (t) {
        "on" + t in no && ko.remove(t)
    });
    var So, To = 0;
    to.mouse = function (t) {
        return $(t, k())
    };
    var Eo = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    to.touch = function (t, e, i) {
        if (arguments.length < 3 && (i = e, e = k().changedTouches), e) for (var n, r = 0, o = e.length; o > r; ++r) if ((n = e[r]).identifier === i) return $(t, n)
    }, to.behavior.drag = function () {
        function t() {
            this.on("mousedown.drag", o).on("touchstart.drag", a)
        }

        function i(t, e, i, o, a) {
            return function () {
                var s, l = this, h = to.event.target.correspondingElement || to.event.target, c = l.parentNode,
                    u = n.of(l, arguments), d = 0, f = t(), p = ".drag" + (null == f ? "" : "-" + f),
                    g = to.select(i(h)).on(o + p, function () {
                        var t, i, n = e(c, f);
                        n && (t = n[0] - v[0], i = n[1] - v[1], d |= t | i, v = n, u({
                            type: "drag",
                            x: n[0] + s[0],
                            y: n[1] + s[1],
                            dx: t,
                            dy: i
                        }))
                    }).on(a + p, function () {
                        e(c, f) && (g.on(o + p, null).on(a + p, null), m(d), u({type: "dragend"}))
                    }), m = q(h), v = e(c, f);
                r ? s = [(s = r.apply(l, arguments)).x - v[0], s.y - v[1]] : s = [0, 0], u({type: "dragstart"})
            }
        }

        var n = S(t, "drag", "dragstart", "dragend"), r = null, o = i(b, to.mouse, e, "mousemove", "mouseup"),
            a = i(V, to.touch, v, "touchmove", "touchend");
        return t.origin = function (e) {
            return arguments.length ? (r = e, t) : r
        }, to.rebind(t, n, "on")
    }, to.touches = function (t, e) {
        return arguments.length < 2 && (e = k().touches), e ? io(e).map(function (e) {
            var i = $(t, e);
            return i.identifier = e.identifier, i
        }) : []
    };
    var Co = 1e-6, Do = Co * Co, Po = Math.PI, _o = 2 * Po, Oo = _o - Co, Lo = Po / 2, No = Po / 180, zo = 180 / Po,
        Io = Math.SQRT2;
    to.interpolateZoom = function (t, e) {
        var i, n, r = t[0], o = t[1], a = t[2], s = e[0], l = e[1], h = e[2], c = s - r, u = l - o, d = c * c + u * u;
        if (Do > d) n = Math.log(h / a) / Io, i = function (t) {
            return [r + t * c, o + t * u, a * Math.exp(Io * t * n)]
        }; else {
            var f = Math.sqrt(d), p = (h * h - a * a + 4 * d) / (2 * a * 2 * f),
                g = (h * h - a * a - 4 * d) / (2 * h * 2 * f), m = Math.log(Math.sqrt(p * p + 1) - p),
                v = Math.log(Math.sqrt(g * g + 1) - g);
            n = (v - m) / Io, i = function (t) {
                var e = t * n, i = tt(m), s = a / (2 * f) * (i * function (t) {
                    return ((t = Math.exp(2 * t)) - 1) / (t + 1)
                }(Io * e + m) - function (t) {
                    return ((t = Math.exp(t)) - 1 / t) / 2
                }(m));
                return [r + s * c, o + s * u, a * i / tt(Io * e + m)]
            }
        }
        return i.duration = 1e3 * n, i
    }, to.behavior.zoom = function () {
        function t(t) {
            t.on(P, c).on(Bo + ".zoom", d).on("dblclick.zoom", f).on(L, u)
        }

        function i(t) {
            return [(t[0] - k.x) / k.k, (t[1] - k.y) / k.k]
        }

        function n(t) {
            k.k = Math.max(E[0], Math.min(E[1], t))
        }

        function r(t, e) {
            e = function (t) {
                return [t[0] * k.k + k.x, t[1] * k.k + k.y]
            }(e), k.x += t[0] - e[0], k.y += t[1] - e[1]
        }

        function o(e, i, o, a) {
            e.__chart__ = {
                x: k.x,
                y: k.y,
                k: k.k
            }, n(Math.pow(2, a)), r(g = i, o), e = to.select(e), C > 0 && (e = e.transition().duration(C)), e.call(t.event)
        }

        function a() {
            b && b.domain(x.range().map(function (t) {
                return (t - k.x) / k.k
            }).map(x.invert)), A && A.domain(M.range().map(function (t) {
                return (t - k.y) / k.k
            }).map(M.invert))
        }

        function s(t) {
            D++ || t({type: "zoomstart"})
        }

        function l(t) {
            a(), t({type: "zoom", scale: k.k, translate: [k.x, k.y]})
        }

        function h(t) {
            --D || (t({type: "zoomend"}), g = null)
        }

        function c() {
            var t = this, n = N.of(t, arguments), o = 0, a = to.select(e(t)).on(_, function () {
                o = 1, r(to.mouse(t), c), l(n)
            }).on(O, function () {
                a.on(_, null).on(O, null), u(o), h(n)
            }), c = i(to.mouse(t)), u = q(t);
            _s.call(t), s(n)
        }

        function u() {
            function t() {
                var t = to.touches(p);
                return f = k.k, t.forEach(function (t) {
                    t.identifier in m && (m[t.identifier] = i(t))
                }), t
            }

            function e() {
                var e = to.event.target;
                to.select(e).on(b, a).on(M, d), A.push(e);
                for (var i = to.event.changedTouches, n = 0, r = i.length; r > n; ++n) m[i[n].identifier] = null;
                var s = t(), l = Date.now();
                if (1 === s.length) {
                    if (500 > l - y) {
                        var h = s[0];
                        o(p, h, m[h.identifier], Math.floor(Math.log(k.k) / Math.LN2) + 1), w()
                    }
                    y = l
                } else if (s.length > 1) {
                    h = s[0];
                    var c = s[1], u = h[0] - c[0], f = h[1] - c[1];
                    v = u * u + f * f
                }
            }

            function a() {
                var t, e, i, o, a = to.touches(p);
                _s.call(p);
                for (var s = 0, h = a.length; h > s; ++s, o = null) if (i = a[s], o = m[i.identifier]) {
                    if (e) break;
                    t = i, e = o
                }
                if (o) {
                    var c = (c = i[0] - t[0]) * c + (c = i[1] - t[1]) * c, u = v && Math.sqrt(c / v);
                    t = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], e = [(e[0] + o[0]) / 2, (e[1] + o[1]) / 2], n(u * f)
                }
                y = null, r(t, e), l(g)
            }

            function d() {
                if (to.event.touches.length) {
                    for (var e = to.event.changedTouches, i = 0, n = e.length; n > i; ++i) delete m[e[i].identifier];
                    for (var r in m) return void t()
                }
                to.selectAll(A).on(x, null), S.on(P, c).on(L, u), T(), h(g)
            }

            var f, p = this, g = N.of(p, arguments), m = {}, v = 0,
                x = ".zoom-" + to.event.changedTouches[0].identifier, b = "touchmove" + x, M = "touchend" + x, A = [],
                S = to.select(p), T = q(p);
            e(), s(g), S.on(P, null).on(L, e)
        }

        function d() {
            var t = N.of(this, arguments);
            v ? clearTimeout(v) : (_s.call(this), p = i(g = m || to.mouse(this)), s(t)), v = setTimeout(function () {
                v = null, h(t)
            }, 50), w(), n(Math.pow(2, .002 * Ro()) * k.k), r(g, p), l(t)
        }

        function f() {
            var t = to.mouse(this), e = Math.log(k.k) / Math.LN2;
            o(this, t, i(t), to.event.shiftKey ? Math.ceil(e) - 1 : Math.floor(e) + 1)
        }

        var p, g, m, v, y, x, b, M, A, k = {x: 0, y: 0, k: 1}, T = [960, 500], E = jo, C = 250, D = 0,
            P = "mousedown.zoom", _ = "mousemove.zoom", O = "mouseup.zoom", L = "touchstart.zoom",
            N = S(t, "zoomstart", "zoom", "zoomend");
        return Bo || (Bo = "onwheel" in no ? (Ro = function () {
            return -to.event.deltaY * (to.event.deltaMode ? 120 : 1)
        }, "wheel") : "onmousewheel" in no ? (Ro = function () {
            return to.event.wheelDelta
        }, "mousewheel") : (Ro = function () {
            return -to.event.detail
        }, "MozMousePixelScroll")), t.event = function (t) {
            t.each(function () {
                var t = N.of(this, arguments), e = k;
                Ds ? to.select(this).transition().each("start.zoom", function () {
                    k = this.__chart__ || {x: 0, y: 0, k: 1}, s(t)
                }).tween("zoom:zoom", function () {
                    var i = T[0], n = T[1], r = g ? g[0] : i / 2, o = g ? g[1] : n / 2,
                        a = to.interpolateZoom([(r - k.x) / k.k, (o - k.y) / k.k, i / k.k], [(r - e.x) / e.k, (o - e.y) / e.k, i / e.k]);
                    return function (e) {
                        var n = a(e), s = i / n[2];
                        this.__chart__ = k = {x: r - n[0] * s, y: o - n[1] * s, k: s}, l(t)
                    }
                }).each("interrupt.zoom", function () {
                    h(t)
                }).each("end.zoom", function () {
                    h(t)
                }) : (this.__chart__ = k, s(t), l(t), h(t))
            })
        }, t.translate = function (e) {
            return arguments.length ? (k = {x: +e[0], y: +e[1], k: k.k}, a(), t) : [k.x, k.y]
        }, t.scale = function (e) {
            return arguments.length ? (k = {x: k.x, y: k.y, k: null}, n(+e), a(), t) : k.k
        }, t.scaleExtent = function (e) {
            return arguments.length ? (E = null == e ? jo : [+e[0], +e[1]], t) : E
        }, t.center = function (e) {
            return arguments.length ? (m = e && [+e[0], +e[1]], t) : m
        }, t.size = function (e) {
            return arguments.length ? (T = e && [+e[0], +e[1]], t) : T
        }, t.duration = function (e) {
            return arguments.length ? (C = +e, t) : C
        }, t.x = function (e) {
            return arguments.length ? (b = e, x = e.copy(), k = {x: 0, y: 0, k: 1}, t) : b
        }, t.y = function (e) {
            return arguments.length ? (A = e, M = e.copy(), k = {x: 0, y: 0, k: 1}, t) : A
        }, to.rebind(t, N, "on")
    };
    var Ro, Bo, jo = [0, 1 / 0];
    to.color = it, it.prototype.toString = function () {
        return this.rgb() + ""
    }, to.hsl = nt;
    var Wo = nt.prototype = new it;
    Wo.brighter = function (t) {
        return t = Math.pow(.7, arguments.length ? t : 1), new nt(this.h, this.s, this.l / t)
    }, Wo.darker = function (t) {
        return t = Math.pow(.7, arguments.length ? t : 1), new nt(this.h, this.s, t * this.l)
    }, Wo.rgb = function () {
        return rt(this.h, this.s, this.l)
    }, to.hcl = ot;
    var Ho = ot.prototype = new it;
    Ho.brighter = function (t) {
        return new ot(this.h, this.c, Math.min(100, this.l + Yo * (arguments.length ? t : 1)))
    }, Ho.darker = function (t) {
        return new ot(this.h, this.c, Math.max(0, this.l - Yo * (arguments.length ? t : 1)))
    }, Ho.rgb = function () {
        return at(this.h, this.c, this.l).rgb()
    }, to.lab = st;
    var Yo = 18, Go = .95047, Fo = 1, Xo = 1.08883, Uo = st.prototype = new it;
    Uo.brighter = function (t) {
        return new st(Math.min(100, this.l + Yo * (arguments.length ? t : 1)), this.a, this.b)
    }, Uo.darker = function (t) {
        return new st(Math.max(0, this.l - Yo * (arguments.length ? t : 1)), this.a, this.b)
    }, Uo.rgb = function () {
        return lt(this.l, this.a, this.b)
    }, to.rgb = ft;
    var qo = ft.prototype = new it;
    qo.brighter = function (t) {
        t = Math.pow(.7, arguments.length ? t : 1);
        var e = this.r, i = this.g, n = this.b, r = 30;
        return e || i || n ? (e && r > e && (e = r), i && r > i && (i = r), n && r > n && (n = r), new ft(Math.min(255, e / t), Math.min(255, i / t), Math.min(255, n / t))) : new ft(r, r, r)
    }, qo.darker = function (t) {
        return new ft((t = Math.pow(.7, arguments.length ? t : 1)) * this.r, t * this.g, t * this.b)
    }, qo.hsl = function () {
        return yt(this.r, this.g, this.b)
    }, qo.toString = function () {
        return "#" + mt(this.r) + mt(this.g) + mt(this.b)
    };
    var $o = to.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    $o.forEach(function (t, e) {
        $o.set(t, pt(e))
    }), to.functor = At, to.xhr = wt(v), to.dsv = function (t, e) {
        function i(t, i, o) {
            arguments.length < 3 && (o = i, i = null);
            var a = kt(t, e, null == i ? n : r(i), o);
            return a.row = function (t) {
                return arguments.length ? a.response(null == (i = t) ? n : r(t)) : i
            }, a
        }

        function n(t) {
            return i.parse(t.responseText)
        }

        function r(t) {
            return function (e) {
                return i.parse(e.responseText, t)
            }
        }

        function o(e) {
            return e.map(a).join(t)
        }

        function a(t) {
            return s.test(t) ? '"' + t.replace(/\"/g, '""') + '"' : t
        }

        var s = new RegExp('["' + t + "\n]"), l = t.charCodeAt(0);
        return i.parse = function (t, e) {
            var n;
            return i.parseRows(t, function (t, i) {
                if (n) return n(t, i - 1);
                var r = new Function("d", "return {" + t.map(function (t, e) {
                    return JSON.stringify(t) + ": d[" + e + "]"
                }).join(",") + "}");
                n = e ? function (t, i) {
                    return e(r(t), i)
                } : r
            })
        }, i.parseRows = function (t, e) {
            function i() {
                if (c >= h) return a;
                if (r) return r = !1, o;
                var e = c;
                if (34 === t.charCodeAt(e)) {
                    for (var i = e; i++ < h;) if (34 === t.charCodeAt(i)) {
                        if (34 !== t.charCodeAt(i + 1)) break;
                        ++i
                    }
                    return c = i + 2, 13 === (n = t.charCodeAt(i + 1)) ? (r = !0, 10 === t.charCodeAt(i + 2) && ++c) : 10 === n && (r = !0), t.slice(e + 1, i).replace(/""/g, '"')
                }
                for (; h > c;) {
                    var n, s = 1;
                    if (10 === (n = t.charCodeAt(c++))) r = !0; else if (13 === n) r = !0, 10 === t.charCodeAt(c) && (++c, ++s); else if (n !== l) continue;
                    return t.slice(e, c - s)
                }
                return t.slice(e)
            }

            for (var n, r, o = {}, a = {}, s = [], h = t.length, c = 0, u = 0; (n = i()) !== a;) {
                for (var d = []; n !== o && n !== a;) d.push(n), n = i();
                e && null == (d = e(d, u++)) || s.push(d)
            }
            return s
        }, i.format = function (e) {
            if (Array.isArray(e[0])) return i.formatRows(e);
            var n = new m, r = [];
            return e.forEach(function (t) {
                for (var e in t) n.has(e) || r.push(n.add(e))
            }), [r.map(a).join(t)].concat(e.map(function (e) {
                return r.map(function (t) {
                    return a(e[t])
                }).join(t)
            })).join("\n")
        }, i.formatRows = function (t) {
            return t.map(o).join("\n")
        }, i
    }, to.csv = to.dsv(",", "text/csv"), to.tsv = to.dsv("\t", "text/tab-separated-values");
    var Vo, Ko, Zo, Jo, Qo = this[x(this, "requestAnimationFrame")] || function (t) {
        setTimeout(t, 17)
    };
    to.timer = function () {
        St.apply(this, arguments)
    }, to.timer.flush = function () {
        Et(), Ct()
    }, to.round = function (t, e) {
        return e ? Math.round(t * (e = Math.pow(10, e))) / e : Math.round(t)
    };
    var ta = ["y", "z", "a", "f", "p", "n", "\xb5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(function (t, e) {
        var i = Math.pow(10, 3 * co(8 - e));
        return {
            scale: e > 8 ? function (t) {
                return t / i
            } : function (t) {
                return t * i
            }, symbol: t
        }
    });
    to.formatPrefix = function (t, e) {
        var i = 0;
        return (t = +t) && (0 > t && (t *= -1), e && (t = to.round(t, Dt(t, e))), i = 1 + Math.floor(1e-12 + Math.log(t) / Math.LN10), i = Math.max(-24, Math.min(24, 3 * Math.floor((i - 1) / 3)))), ta[8 + i / 3]
    };
    var ea = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, ia = to.map({
        b: function (t) {
            return t.toString(2)
        }, c: function (t) {
            return String.fromCharCode(t)
        }, o: function (t) {
            return t.toString(8)
        }, x: function (t) {
            return t.toString(16)
        }, X: function (t) {
            return t.toString(16).toUpperCase()
        }, g: function (t, e) {
            return t.toPrecision(e)
        }, e: function (t, e) {
            return t.toExponential(e)
        }, f: function (t, e) {
            return t.toFixed(e)
        }, r: function (t, e) {
            return (t = to.round(t, Dt(t, e))).toFixed(Math.max(0, Math.min(20, Dt(t * (1 + 1e-15), e))))
        }
    }), na = to.time = {}, ra = Date;
    Ot.prototype = {
        getDate: function () {
            return this._.getUTCDate()
        }, getDay: function () {
            return this._.getUTCDay()
        }, getFullYear: function () {
            return this._.getUTCFullYear()
        }, getHours: function () {
            return this._.getUTCHours()
        }, getMilliseconds: function () {
            return this._.getUTCMilliseconds()
        }, getMinutes: function () {
            return this._.getUTCMinutes()
        }, getMonth: function () {
            return this._.getUTCMonth()
        }, getSeconds: function () {
            return this._.getUTCSeconds()
        }, getTime: function () {
            return this._.getTime()
        }, getTimezoneOffset: function () {
            return 0
        }, valueOf: function () {
            return this._.valueOf()
        }, setDate: function () {
            oa.setUTCDate.apply(this._, arguments)
        }, setDay: function () {
            oa.setUTCDay.apply(this._, arguments)
        }, setFullYear: function () {
            oa.setUTCFullYear.apply(this._, arguments)
        }, setHours: function () {
            oa.setUTCHours.apply(this._, arguments)
        }, setMilliseconds: function () {
            oa.setUTCMilliseconds.apply(this._, arguments)
        }, setMinutes: function () {
            oa.setUTCMinutes.apply(this._, arguments)
        }, setMonth: function () {
            oa.setUTCMonth.apply(this._, arguments)
        }, setSeconds: function () {
            oa.setUTCSeconds.apply(this._, arguments)
        }, setTime: function () {
            oa.setTime.apply(this._, arguments)
        }
    };
    var oa = Date.prototype;
    na.year = Lt(function (t) {
        return (t = na.day(t)).setMonth(0, 1), t
    }, function (t, e) {
        t.setFullYear(t.getFullYear() + e)
    }, function (t) {
        return t.getFullYear()
    }), na.years = na.year.range, na.years.utc = na.year.utc.range, na.day = Lt(function (t) {
        var e = new ra(2e3, 0);
        return e.setFullYear(t.getFullYear(), t.getMonth(), t.getDate()), e
    }, function (t, e) {
        t.setDate(t.getDate() + e)
    }, function (t) {
        return t.getDate() - 1
    }), na.days = na.day.range, na.days.utc = na.day.utc.range, na.dayOfYear = function (t) {
        var e = na.year(t);
        return Math.floor((t - e - 6e4 * (t.getTimezoneOffset() - e.getTimezoneOffset())) / 864e5)
    }, ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (t, e) {
        e = 7 - e;
        var i = na[t] = Lt(function (t) {
            return (t = na.day(t)).setDate(t.getDate() - (t.getDay() + e) % 7), t
        }, function (t, e) {
            t.setDate(t.getDate() + 7 * Math.floor(e))
        }, function (t) {
            var i = na.year(t).getDay();
            return Math.floor((na.dayOfYear(t) + (i + e) % 7) / 7) - (i !== e)
        });
        na[t + "s"] = i.range, na[t + "s"].utc = i.utc.range, na[t + "OfYear"] = function (t) {
            var i = na.year(t).getDay();
            return Math.floor((na.dayOfYear(t) + (i + e) % 7) / 7)
        }
    }), na.week = na.sunday, na.weeks = na.sunday.range, na.weeks.utc = na.sunday.utc.range, na.weekOfYear = na.sundayOfYear;
    var aa = {"-": "", _: " ", 0: "0"}, sa = /^\s*\d+/, la = /^%/;
    to.locale = function (t) {
        return {numberFormat: Pt(t), timeFormat: zt(t)}
    };
    var ha = to.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    to.format = ha.numberFormat, to.geo = {}, ee.prototype = {
        s: 0, t: 0, add: function (t) {
            ie(t, this.t, ca), ie(ca.s, this.s, this), this.s ? this.t += ca.t : this.s = ca.t
        }, reset: function () {
            this.s = this.t = 0
        }, valueOf: function () {
            return this.s
        }
    };
    var ca = new ee;
    to.geo.stream = function (t, e) {
        t && ua.hasOwnProperty(t.type) ? ua[t.type](t, e) : ne(t, e)
    };
    var ua = {
        Feature: function (t, e) {
            ne(t.geometry, e)
        }, FeatureCollection: function (t, e) {
            for (var i = t.features, n = -1, r = i.length; ++n < r;) ne(i[n].geometry, e)
        }
    }, da = {
        Sphere: function (t, e) {
            e.sphere()
        }, Point: function (t, e) {
            t = t.coordinates, e.point(t[0], t[1], t[2])
        }, MultiPoint: function (t, e) {
            for (var i = t.coordinates, n = -1, r = i.length; ++n < r;) t = i[n], e.point(t[0], t[1], t[2])
        }, LineString: function (t, e) {
            re(t.coordinates, e, 0)
        }, MultiLineString: function (t, e) {
            for (var i = t.coordinates, n = -1, r = i.length; ++n < r;) re(i[n], e, 0)
        }, Polygon: function (t, e) {
            oe(t.coordinates, e)
        }, MultiPolygon: function (t, e) {
            for (var i = t.coordinates, n = -1, r = i.length; ++n < r;) oe(i[n], e)
        }, GeometryCollection: function (t, e) {
            for (var i = t.geometries, n = -1, r = i.length; ++n < r;) ne(i[n], e)
        }
    };
    to.geo.area = function (t) {
        return fa = 0, to.geo.stream(t, ga), fa
    };
    var fa, pa = new ee, ga = {
        sphere: function () {
            fa += 4 * Po
        }, point: b, lineStart: b, lineEnd: b, polygonStart: function () {
            pa.reset(), ga.lineStart = ae
        }, polygonEnd: function () {
            var t = 2 * pa;
            fa += 0 > t ? 4 * Po + t : t, ga.lineStart = ga.lineEnd = ga.point = b
        }
    };
    to.geo.bounds = function () {
        function t(t, e) {
            x.push(b = [c = t, d = t]), u > e && (u = e), e > f && (f = e)
        }

        function e(e, i) {
            var n = se([e * No, i * No]);
            if (v) {
                var r = he(v, n), o = he([r[1], -r[0], 0], r);
                de(o), o = fe(o);
                var a = e - p, l = a > 0 ? 1 : -1, h = o[0] * zo * l, g = co(a) > 180;
                if (g ^ (h > l * p && l * e > h)) (m = o[1] * zo) > f && (f = m); else if (g ^ ((h = (h + 360) % 360 - 180) > l * p && l * e > h)) {
                    var m = -o[1] * zo;
                    u > m && (u = m)
                } else u > i && (u = i), i > f && (f = i);
                g ? p > e ? s(c, e) > s(c, d) && (d = e) : s(e, d) > s(c, d) && (c = e) : d >= c ? (c > e && (c = e), e > d && (d = e)) : e > p ? s(c, e) > s(c, d) && (d = e) : s(e, d) > s(c, d) && (c = e)
            } else t(e, i);
            v = n, p = e
        }

        function i() {
            M.point = e
        }

        function n() {
            b[0] = c, b[1] = d, M.point = t, v = null
        }

        function r(t, i) {
            if (v) {
                var n = t - p;
                y += co(n) > 180 ? n + (n > 0 ? 360 : -360) : n
            } else g = t, m = i;
            ga.point(t, i), e(t, i)
        }

        function o() {
            ga.lineStart()
        }

        function a() {
            r(g, m), ga.lineEnd(), co(y) > Co && (c = -(d = 180)), b[0] = c, b[1] = d, v = null
        }

        function s(t, e) {
            return (e -= t) < 0 ? e + 360 : e
        }

        function l(t, e) {
            return t[0] - e[0]
        }

        function h(t, e) {
            return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t
        }

        var c, u, d, f, p, g, m, v, y, x, b, M = {
            point: t, lineStart: i, lineEnd: n, polygonStart: function () {
                M.point = r, M.lineStart = o, M.lineEnd = a, y = 0, ga.polygonStart()
            }, polygonEnd: function () {
                ga.polygonEnd(), M.point = t, M.lineStart = i, M.lineEnd = n, 0 > pa ? (c = -(d = 180), u = -(f = 90)) : y > Co ? f = 90 : -Co > y && (u = -90), b[0] = c, b[1] = d
            }
        };
        return function (t) {
            if (f = d = -(c = u = 1 / 0), x = [], to.geo.stream(t, M), o = x.length) {
                x.sort(l);
                for (var e = 1, i = [p = x[0]]; o > e; ++e) h((r = x[e])[0], p) || h(r[1], p) ? (s(p[0], r[1]) > s(p[0], p[1]) && (p[1] = r[1]), s(r[0], p[1]) > s(p[0], p[1]) && (p[0] = r[0])) : i.push(p = r);
                for (var n, r, o, a = -1 / 0, p = (e = 0, i[o = i.length - 1]); o >= e; p = r, ++e) r = i[e], (n = s(p[1], r[0])) > a && (a = n, c = r[0], d = p[1])
            }
            return x = b = null, c === 1 / 0 || u === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[c, u], [d, f]]
        }
    }(), to.geo.centroid = function (t) {
        ma = va = ya = xa = ba = Ma = Aa = wa = ka = Sa = Ta = 0, to.geo.stream(t, Ea);
        var e = ka, i = Sa, n = Ta, r = e * e + i * i + n * n;
        return Do > r && (e = Ma, i = Aa, n = wa, Co > va && (e = ya, i = xa, n = ba), Do > (r = e * e + i * i + n * n)) ? [NaN, NaN] : [Math.atan2(i, e) * zo, Q(n / Math.sqrt(r)) * zo]
    };
    var ma, va, ya, xa, ba, Ma, Aa, wa, ka, Sa, Ta, Ea = {
        sphere: b, point: ge, lineStart: ve, lineEnd: ye, polygonStart: function () {
            Ea.lineStart = xe
        }, polygonEnd: function () {
            Ea.lineStart = ve
        }
    }, Ca = Se(Me, function (t) {
        var e, i = NaN, n = NaN, r = NaN;
        return {
            lineStart: function () {
                t.lineStart(), e = 1
            }, point: function (o, a) {
                var s = o > 0 ? Po : -Po, l = co(o - i);
                co(l - Po) < Co ? (t.point(i, n = (n + a) / 2 > 0 ? Lo : -Lo), t.point(r, n), t.lineEnd(), t.lineStart(), t.point(s, n), t.point(o, n), e = 0) : r !== s && l >= Po && (co(i - r) < Co && (i -= r * Co), co(o - s) < Co && (o -= s * Co), n = function (t, e, i, n) {
                    var r, o, a = Math.sin(t - i);
                    return co(a) > Co ? Math.atan((Math.sin(e) * (o = Math.cos(n)) * Math.sin(i) - Math.sin(n) * (r = Math.cos(e)) * Math.sin(t)) / (r * o * a)) : (e + n) / 2
                }(i, n, o, a), t.point(r, n), t.lineEnd(), t.lineStart(), t.point(s, n), e = 0), t.point(i = o, n = a), r = s
            }, lineEnd: function () {
                t.lineEnd(), i = n = NaN
            }, clean: function () {
                return 2 - e
            }
        }
    }, function (t, e, i, n) {
        var r;
        if (null == t) r = i * Lo, n.point(-Po, r), n.point(0, r), n.point(Po, r), n.point(Po, 0), n.point(Po, -r), n.point(0, -r), n.point(-Po, -r), n.point(-Po, 0), n.point(-Po, r); else if (co(t[0] - e[0]) > Co) {
            var o = t[0] < e[0] ? Po : -Po;
            r = i * o / 2, n.point(-o, r), n.point(0, r), n.point(o, r)
        } else n.point(e[0], e[1])
    }, [-Po, -Po / 2]), Da = 1e9;
    to.geo.clipExtent = function () {
        var t, e, i, n, r, o, a = {
            stream: function (t) {
                return r && (r.valid = !1), (r = o(t)).valid = !0, r
            }, extent: function (s) {
                return arguments.length ? (o = Pe(t = +s[0][0], e = +s[0][1], i = +s[1][0], n = +s[1][1]), r && (r.valid = !1, r = null), a) : [[t, e], [i, n]]
            }
        };
        return a.extent([[0, 0], [960, 500]])
    }, (to.geo.conicEqualArea = function () {
        return _e(Oe)
    }).raw = Oe, to.geo.albers = function () {
        return to.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
    }, to.geo.albersUsa = function () {
        function t(t) {
            var o = t[0], a = t[1];
            return e = null, i(o, a), e || (n(o, a), e) || r(o, a), e
        }

        var e, i, n, r, o = to.geo.albers(),
            a = to.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            s = to.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), l = {
                point: function (t, i) {
                    e = [t, i]
                }
            };
        return t.invert = function (t) {
            var e = o.scale(), i = o.translate(), n = (t[0] - i[0]) / e, r = (t[1] - i[1]) / e;
            return (r >= .12 && .234 > r && n >= -.425 && -.214 > n ? a : r >= .166 && .234 > r && n >= -.214 && -.115 > n ? s : o).invert(t)
        }, t.stream = function (t) {
            var e = o.stream(t), i = a.stream(t), n = s.stream(t);
            return {
                point: function (t, r) {
                    e.point(t, r), i.point(t, r), n.point(t, r)
                }, sphere: function () {
                    e.sphere(), i.sphere(), n.sphere()
                }, lineStart: function () {
                    e.lineStart(), i.lineStart(), n.lineStart()
                }, lineEnd: function () {
                    e.lineEnd(), i.lineEnd(), n.lineEnd()
                }, polygonStart: function () {
                    e.polygonStart(), i.polygonStart(), n.polygonStart()
                }, polygonEnd: function () {
                    e.polygonEnd(), i.polygonEnd(), n.polygonEnd()
                }
            }
        }, t.precision = function (e) {
            return arguments.length ? (o.precision(e), a.precision(e), s.precision(e), t) : o.precision()
        }, t.scale = function (e) {
            return arguments.length ? (o.scale(e), a.scale(.35 * e), s.scale(e), t.translate(o.translate())) : o.scale()
        }, t.translate = function (e) {
            if (!arguments.length) return o.translate();
            var h = o.scale(), c = +e[0], u = +e[1];
            return i = o.translate(e).clipExtent([[c - .455 * h, u - .238 * h], [c + .455 * h, u + .238 * h]]).stream(l).point, n = a.translate([c - .307 * h, u + .201 * h]).clipExtent([[c - .425 * h + Co, u + .12 * h + Co], [c - .214 * h - Co, u + .234 * h - Co]]).stream(l).point, r = s.translate([c - .205 * h, u + .212 * h]).clipExtent([[c - .214 * h + Co, u + .166 * h + Co], [c - .115 * h - Co, u + .234 * h - Co]]).stream(l).point, t
        }, t.scale(1070)
    };
    var Pa, _a, Oa, La, Na, za, Ia = {
        point: b, lineStart: b, lineEnd: b, polygonStart: function () {
            _a = 0, Ia.lineStart = Le
        }, polygonEnd: function () {
            Ia.lineStart = Ia.lineEnd = Ia.point = b, Pa += co(_a / 2)
        }
    }, Ra = {
        point: function (t, e) {
            Oa > t && (Oa = t), t > Na && (Na = t), La > e && (La = e), e > za && (za = e)
        }, lineStart: b, lineEnd: b, polygonStart: b, polygonEnd: b
    }, Ba = {
        point: Ie, lineStart: Re, lineEnd: Be, polygonStart: function () {
            Ba.lineStart = je
        }, polygonEnd: function () {
            Ba.point = Ie, Ba.lineStart = Re, Ba.lineEnd = Be
        }
    };
    to.geo.path = function () {
        function t(t) {
            return t && ("function" == typeof s && o.pointRadius(+s.apply(this, arguments)), a && a.valid || (a = r(o)), to.geo.stream(t, a)), o.result()
        }

        function e() {
            return a = null, t
        }

        var i, n, r, o, a, s = 4.5;
        return t.area = function (t) {
            return Pa = 0, to.geo.stream(t, r(Ia)), Pa
        }, t.centroid = function (t) {
            return ya = xa = ba = Ma = Aa = wa = ka = Sa = Ta = 0, to.geo.stream(t, r(Ba)), Ta ? [ka / Ta, Sa / Ta] : wa ? [Ma / wa, Aa / wa] : ba ? [ya / ba, xa / ba] : [NaN, NaN]
        }, t.bounds = function (t) {
            return Na = za = -(Oa = La = 1 / 0), to.geo.stream(t, r(Ra)), [[Oa, La], [Na, za]]
        }, t.projection = function (t) {
            return arguments.length ? (r = (i = t) ? t.stream || function (t) {
                var e = He(function (e, i) {
                    return t([e * zo, i * zo])
                });
                return function (t) {
                    return Ue(e(t))
                }
            }(t) : v, e()) : i
        }, t.context = function (t) {
            return arguments.length ? (o = null == (n = t) ? new Ne : new We(t), "function" != typeof s && o.pointRadius(s), e()) : n
        }, t.pointRadius = function (e) {
            return arguments.length ? (s = "function" == typeof e ? e : (o.pointRadius(+e), +e), t) : s
        }, t.projection(to.geo.albersUsa()).context(null)
    }, to.geo.transform = function (t) {
        return {
            stream: function (e) {
                var i = new Ye(e);
                for (var n in t) i[n] = t[n];
                return i
            }
        }
    }, Ye.prototype = {
        point: function (t, e) {
            this.stream.point(t, e)
        }, sphere: function () {
            this.stream.sphere()
        }, lineStart: function () {
            this.stream.lineStart()
        }, lineEnd: function () {
            this.stream.lineEnd()
        }, polygonStart: function () {
            this.stream.polygonStart()
        }, polygonEnd: function () {
            this.stream.polygonEnd()
        }
    }, to.geo.projection = Fe, to.geo.projectionMutator = Xe, (to.geo.equirectangular = function () {
        return Fe(qe)
    }).raw = qe.invert = qe, to.geo.rotation = function (t) {
        function e(e) {
            return (e = t(e[0] * No, e[1] * No))[0] *= zo, e[1] *= zo, e
        }

        return t = Ve(t[0] % 360 * No, t[1] * No, t.length > 2 ? t[2] * No : 0), e.invert = function (e) {
            return (e = t.invert(e[0] * No, e[1] * No))[0] *= zo, e[1] *= zo, e
        }, e
    }, $e.invert = qe, to.geo.circle = function () {
        function t() {
            var t = "function" == typeof n ? n.apply(this, arguments) : n, e = Ve(-t[0] * No, -t[1] * No, 0).invert,
                r = [];
            return i(null, null, 1, {
                point: function (t, i) {
                    r.push(t = e(t, i)), t[0] *= zo, t[1] *= zo
                }
            }), {type: "Polygon", coordinates: [r]}
        }

        var e, i, n = [0, 0], r = 6;
        return t.origin = function (e) {
            return arguments.length ? (n = e, t) : n
        }, t.angle = function (n) {
            return arguments.length ? (i = Qe((e = +n) * No, r * No), t) : e
        }, t.precision = function (n) {
            return arguments.length ? (i = Qe(e * No, (r = +n) * No), t) : r
        }, t.angle(90)
    }, to.geo.distance = function (t, e) {
        var i, n = (e[0] - t[0]) * No, r = t[1] * No, o = e[1] * No, a = Math.sin(n), s = Math.cos(n), l = Math.sin(r),
            h = Math.cos(r), c = Math.sin(o), u = Math.cos(o);
        return Math.atan2(Math.sqrt((i = u * a) * i + (i = h * c - l * u * s) * i), l * c + h * u * s)
    }, to.geo.graticule = function () {
        function t() {
            return {type: "MultiLineString", coordinates: e()}
        }

        function e() {
            return to.range(Math.ceil(o / m) * m, r, m).map(d).concat(to.range(Math.ceil(h / v) * v, l, v).map(f)).concat(to.range(Math.ceil(n / p) * p, i, p).filter(function (t) {
                return co(t % m) > Co
            }).map(c)).concat(to.range(Math.ceil(s / g) * g, a, g).filter(function (t) {
                return co(t % v) > Co
            }).map(u))
        }

        var i, n, r, o, a, s, l, h, c, u, d, f, p = 10, g = p, m = 90, v = 360, y = 2.5;
        return t.lines = function () {
            return e().map(function (t) {
                return {type: "LineString", coordinates: t}
            })
        }, t.outline = function () {
            return {
                type: "Polygon",
                coordinates: [d(o).concat(f(l).slice(1), d(r).reverse().slice(1), f(h).reverse().slice(1))]
            }
        }, t.extent = function (e) {
            return arguments.length ? t.majorExtent(e).minorExtent(e) : t.minorExtent()
        }, t.majorExtent = function (e) {
            return arguments.length ? (o = +e[0][0], r = +e[1][0], h = +e[0][1], l = +e[1][1], o > r && (e = o, o = r, r = e), h > l && (e = h, h = l, l = e), t.precision(y)) : [[o, h], [r, l]]
        }, t.minorExtent = function (e) {
            return arguments.length ? (n = +e[0][0], i = +e[1][0], s = +e[0][1], a = +e[1][1], n > i && (e = n, n = i, i = e), s > a && (e = s, s = a, a = e), t.precision(y)) : [[n, s], [i, a]]
        }, t.step = function (e) {
            return arguments.length ? t.majorStep(e).minorStep(e) : t.minorStep()
        }, t.majorStep = function (e) {
            return arguments.length ? (m = +e[0], v = +e[1], t) : [m, v]
        }, t.minorStep = function (e) {
            return arguments.length ? (p = +e[0], g = +e[1], t) : [p, g]
        }, t.precision = function (e) {
            return arguments.length ? (y = +e, c = ei(s, a, 90), u = ii(n, i, y), d = ei(h, l, 90), f = ii(o, r, y), t) : y
        }, t.majorExtent([[-180, -90 + Co], [180, 90 - Co]]).minorExtent([[-180, -80 - Co], [180, 80 + Co]])
    }, to.geo.greatArc = function () {
        function t() {
            return {type: "LineString", coordinates: [e || n.apply(this, arguments), i || r.apply(this, arguments)]}
        }

        var e, i, n = ni, r = ri;
        return t.distance = function () {
            return to.geo.distance(e || n.apply(this, arguments), i || r.apply(this, arguments))
        }, t.source = function (i) {
            return arguments.length ? (n = i, e = "function" == typeof i ? null : i, t) : n
        }, t.target = function (e) {
            return arguments.length ? (r = e, i = "function" == typeof e ? null : e, t) : r
        }, t.precision = function () {
            return arguments.length ? t : 0
        }, t
    }, to.geo.interpolate = function (t, e) {
        return function (t, e, i, n) {
            var r = Math.cos(e), o = Math.sin(e), a = Math.cos(n), s = Math.sin(n), l = r * Math.cos(t),
                h = r * Math.sin(t), c = a * Math.cos(i), u = a * Math.sin(i),
                d = 2 * Math.asin(Math.sqrt(et(n - e) + r * a * et(i - t))), f = 1 / Math.sin(d), p = d ? function (t) {
                    var e = Math.sin(t *= d) * f, i = Math.sin(d - t) * f, n = i * l + e * c, r = i * h + e * u,
                        a = i * o + e * s;
                    return [Math.atan2(r, n) * zo, Math.atan2(a, Math.sqrt(n * n + r * r)) * zo]
                } : function () {
                    return [t * zo, e * zo]
                };
            return p.distance = d, p
        }(t[0] * No, t[1] * No, e[0] * No, e[1] * No)
    }, to.geo.length = function (t) {
        return ja = 0, to.geo.stream(t, Wa), ja
    };
    var ja, Wa = {
        sphere: b, point: b, lineStart: function () {
            function t(t, r) {
                var o = Math.sin(r *= No), a = Math.cos(r), s = co((t *= No) - e), l = Math.cos(s);
                ja += Math.atan2(Math.sqrt((s = a * Math.sin(s)) * s + (s = n * o - i * a * l) * s), i * o + n * a * l), e = t, i = o, n = a
            }

            var e, i, n;
            Wa.point = function (r, o) {
                e = r * No, i = Math.sin(o *= No), n = Math.cos(o), Wa.point = t
            }, Wa.lineEnd = function () {
                Wa.point = Wa.lineEnd = b
            }
        }, lineEnd: b, polygonStart: b, polygonEnd: b
    }, Ha = oi(function (t) {
        return Math.sqrt(2 / (1 + t))
    }, function (t) {
        return 2 * Math.asin(t / 2)
    });
    (to.geo.azimuthalEqualArea = function () {
        return Fe(Ha)
    }).raw = Ha;
    var Ya = oi(function (t) {
        var e = Math.acos(t);
        return e && e / Math.sin(e)
    }, v);
    (to.geo.azimuthalEquidistant = function () {
        return Fe(Ya)
    }).raw = Ya, (to.geo.conicConformal = function () {
        return _e(ai)
    }).raw = ai, (to.geo.conicEquidistant = function () {
        return _e(si)
    }).raw = si;
    var Ga = oi(function (t) {
        return 1 / t
    }, Math.atan);
    (to.geo.gnomonic = function () {
        return Fe(Ga)
    }).raw = Ga, li.invert = function (t, e) {
        return [t, 2 * Math.atan(Math.exp(e)) - Lo]
    }, (to.geo.mercator = function () {
        return hi(li)
    }).raw = li;
    var Fa = oi(function () {
        return 1
    }, Math.asin);
    (to.geo.orthographic = function () {
        return Fe(Fa)
    }).raw = Fa;
    var Xa = oi(function (t) {
        return 1 / (1 + t)
    }, function (t) {
        return 2 * Math.atan(t)
    });
    (to.geo.stereographic = function () {
        return Fe(Xa)
    }).raw = Xa, ci.invert = function (t, e) {
        return [-e, 2 * Math.atan(Math.exp(t)) - Lo]
    }, (to.geo.transverseMercator = function () {
        var t = hi(ci), e = t.center, i = t.rotate;
        return t.center = function (t) {
            return t ? e([-t[1], t[0]]) : [(t = e())[1], -t[0]]
        }, t.rotate = function (t) {
            return t ? i([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = i())[0], t[1], t[2] - 90]
        }, i([0, 0, 90])
    }).raw = ci, to.geom = {}, to.geom.hull = function (t) {
        function e(t) {
            if (t.length < 3) return [];
            var e, r = At(i), o = At(n), a = t.length, s = [], l = [];
            for (e = 0; a > e; e++) s.push([+r.call(this, t[e], e), +o.call(this, t[e], e), e]);
            for (s.sort(pi), e = 0; a > e; e++) l.push([s[e][0], -s[e][1]]);
            var h = fi(s), c = fi(l), u = c[0] === h[0], d = c[c.length - 1] === h[h.length - 1], f = [];
            for (e = h.length - 1; e >= 0; --e) f.push(t[s[h[e]][2]]);
            for (e = +u; e < c.length - d; ++e) f.push(t[s[c[e]][2]]);
            return f
        }

        var i = ui, n = di;
        return arguments.length ? e(t) : (e.x = function (t) {
            return arguments.length ? (i = t, e) : i
        }, e.y = function (t) {
            return arguments.length ? (n = t, e) : n
        }, e)
    }, to.geom.polygon = function (t) {
        return mo(t, Ua), t
    };
    var Ua = to.geom.polygon.prototype = [];
    Ua.area = function () {
        for (var t, e = -1, i = this.length, n = this[i - 1], r = 0; ++e < i;) t = n, n = this[e], r += t[1] * n[0] - t[0] * n[1];
        return .5 * r
    }, Ua.centroid = function (t) {
        var e, i, n = -1, r = this.length, o = 0, a = 0, s = this[r - 1];
        for (arguments.length || (t = -1 / (6 * this.area())); ++n < r;) e = s, s = this[n], i = e[0] * s[1] - s[0] * e[1], o += (e[0] + s[0]) * i, a += (e[1] + s[1]) * i;
        return [o * t, a * t]
    }, Ua.clip = function (t) {
        for (var e, i, n, r, o, a, s = vi(t), l = -1, h = this.length - vi(this), c = this[h - 1]; ++l < h;) {
            for (e = t.slice(), t.length = 0, r = this[l], o = e[(n = e.length - s) - 1], i = -1; ++i < n;) gi(a = e[i], c, r) ? (gi(o, c, r) || t.push(mi(o, a, c, r)), t.push(a)) : gi(o, c, r) && t.push(mi(o, a, c, r)), o = a;
            s && t.push(t[0]), c = r
        }
        return t
    };
    var qa, $a, Va, Ka, Za, Ja = [], Qa = [];
    Si.prototype.prepare = function () {
        for (var t, e = this.edges, i = e.length; i--;) (t = e[i].edge).b && t.a || e.splice(i, 1);
        return e.sort(Ti), e.length
    }, zi.prototype = {
        start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b
        }, end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a
        }
    }, Ii.prototype = {
        insert: function (t, e) {
            var i, n, r;
            if (t) {
                if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {
                    for (t = t.R; t.L;) t = t.L;
                    t.L = e
                } else t.R = e;
                i = t
            } else this._ ? (t = Wi(this._), e.P = null, e.N = t, t.P = t.L = e, i = t) : (e.P = e.N = null, this._ = e, i = null);
            for (e.L = e.R = null, e.U = i, e.C = !0, t = e; i && i.C;) i === (n = i.U).L ? (r = n.R) && r.C ? (i.C = r.C = !1, n.C = !0, t = n) : (t === i.R && (Bi(this, i), i = (t = i).U), i.C = !1, n.C = !0, ji(this, n)) : (r = n.L) && r.C ? (i.C = r.C = !1, n.C = !0, t = n) : (t === i.L && (ji(this, i), i = (t = i).U), i.C = !1, n.C = !0, Bi(this, n)), i = t.U;
            this._.C = !1
        }, remove: function (t) {
            t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;
            var e, i, n, r = t.U, o = t.L, a = t.R;
            if (i = o ? a ? Wi(a) : o : a, r ? r.L === t ? r.L = i : r.R = i : this._ = i, o && a ? (n = i.C, i.C = t.C, i.L = o, o.U = i, i !== a ? (r = i.U, i.U = t.U, t = i.R, r.L = t, i.R = a, a.U = i) : (i.U = r, r = i, t = i.R)) : (n = t.C, t = i), t && (t.U = r), !n) {
                if (t && t.C) return void (t.C = !1);
                do {
                    if (t === this._) break;
                    if (t === r.L) {
                        if ((e = r.R).C && (e.C = !1, r.C = !0, Bi(this, r), e = r.R), e.L && e.L.C || e.R && e.R.C) {
                            e.R && e.R.C || (e.L.C = !1, e.C = !0, ji(this, e), e = r.R), e.C = r.C, r.C = e.R.C = !1, Bi(this, r), t = this._;
                            break
                        }
                    } else if ((e = r.L).C && (e.C = !1, r.C = !0, ji(this, r), e = r.L), e.L && e.L.C || e.R && e.R.C) {
                        e.L && e.L.C || (e.R.C = !1, e.C = !0, Bi(this, e), e = r.L), e.C = r.C, r.C = e.L.C = !1, ji(this, r), t = this._;
                        break
                    }
                    e.C = !0, t = r, r = r.U
                } while (!t.C);
                t && (t.C = !1)
            }
        }
    }, to.geom.voronoi = function (t) {
        function e(t) {
            var e = new Array(t.length), n = s[0][0], r = s[0][1], o = s[1][0], a = s[1][1];
            return Hi(i(t), s).cells.forEach(function (i, s) {
                var l = i.edges, h = i.site;
                (e[s] = l.length ? l.map(function (t) {
                    var e = t.start();
                    return [e.x, e.y]
                }) : h.x >= n && h.x <= o && h.y >= r && h.y <= a ? [[n, a], [o, a], [o, r], [n, r]] : []).point = t[s]
            }), e
        }

        function i(t) {
            return t.map(function (t, e) {
                return {x: Math.round(o(t, e) / Co) * Co, y: Math.round(a(t, e) / Co) * Co, i: e}
            })
        }

        var n = ui, r = di, o = n, a = r, s = ts;
        return t ? e(t) : (e.links = function (t) {
            return Hi(i(t)).edges.filter(function (t) {
                return t.l && t.r
            }).map(function (e) {
                return {source: t[e.l.i], target: t[e.r.i]}
            })
        }, e.triangles = function (t) {
            var e = [];
            return Hi(i(t)).cells.forEach(function (i, n) {
                for (var r, o = i.site, a = i.edges.sort(Ti), s = -1, l = a.length, h = a[l - 1].edge, c = h.l === o ? h.r : h.l; ++s < l;) h, r = c, c = (h = a[s].edge).l === o ? h.r : h.l, n < r.i && n < c.i && Gi(o, r, c) < 0 && e.push([t[n], t[r.i], t[c.i]])
            }), e
        }, e.x = function (t) {
            return arguments.length ? (o = At(n = t), e) : n
        }, e.y = function (t) {
            return arguments.length ? (a = At(r = t), e) : r
        }, e.clipExtent = function (t) {
            return arguments.length ? (s = null == t ? ts : t, e) : s === ts ? null : s
        }, e.size = function (t) {
            return arguments.length ? e.clipExtent(t && [[0, 0], t]) : s === ts ? null : s && s[1]
        }, e)
    };
    var ts = [[-1e6, -1e6], [1e6, 1e6]];
    to.geom.delaunay = function (t) {
        return to.geom.voronoi().triangles(t)
    }, to.geom.quadtree = function (t, e, i, n, r) {
        function o(t) {
            function o(t, e, i, n, r, o, a, s) {
                if (!isNaN(i) && !isNaN(n)) if (t.leaf) {
                    var l = t.x, c = t.y;
                    if (null != l) if (co(l - i) + co(c - n) < .01) h(t, e, i, n, r, o, a, s); else {
                        var u = t.point;
                        t.x = t.y = t.point = null, h(t, u, l, c, r, o, a, s), h(t, e, i, n, r, o, a, s)
                    } else t.x = i, t.y = n, t.point = e
                } else h(t, e, i, n, r, o, a, s)
            }

            function h(t, e, i, n, r, a, s, l) {
                var h = .5 * (r + s), c = .5 * (a + l), u = i >= h, d = n >= c, f = d << 1 | u;
                t.leaf = !1, u ? r = h : s = h, d ? a = c : l = c, o(t = t.nodes[f] || (t.nodes[f] = {
                    leaf: !0,
                    nodes: [],
                    point: null,
                    x: null,
                    y: null
                }), e, i, n, r, a, s, l)
            }

            var c, u, d, f, p, g, m, v, y, x = At(s), b = At(l);
            if (null != e) g = e, m = i, v = n, y = r; else if (v = y = -(g = m = 1 / 0), u = [], d = [], p = t.length, a) for (f = 0; p > f; ++f) (c = t[f]).x < g && (g = c.x), c.y < m && (m = c.y), c.x > v && (v = c.x), c.y > y && (y = c.y), u.push(c.x), d.push(c.y); else for (f = 0; p > f; ++f) {
                var M = +x(c = t[f], f), A = +b(c, f);
                g > M && (g = M), m > A && (m = A), M > v && (v = M), A > y && (y = A), u.push(M), d.push(A)
            }
            var w = v - g, k = y - m;
            w > k ? y = m + w : v = g + k;
            var S = {
                leaf: !0, nodes: [], point: null, x: null, y: null, add: function (t) {
                    o(S, t, +x(t, ++f), +b(t, f), g, m, v, y)
                }
            };
            if (S.visit = function (t) {
                !function t(e, i, n, r, o, a) {
                    if (!e(i, n, r, o, a)) {
                        var s = .5 * (n + o), l = .5 * (r + a), h = i.nodes;
                        h[0] && t(e, h[0], n, r, s, l), h[1] && t(e, h[1], s, r, o, l), h[2] && t(e, h[2], n, l, s, a), h[3] && t(e, h[3], s, l, o, a)
                    }
                }(t, S, g, m, v, y)
            }, S.find = function (t) {
                return function (t, e, i, n, r, o, a) {
                    var s, l = 1 / 0;
                    return function t(h, c, u, d, f) {
                        if (!(c > o || u > a || n > d || r > f)) {
                            if (p = h.point) {
                                var p, g = e - h.x, m = i - h.y, v = g * g + m * m;
                                if (l > v) {
                                    var y = Math.sqrt(l = v);
                                    n = e - y, r = i - y, o = e + y, a = i + y, s = p
                                }
                            }
                            for (var x = h.nodes, b = .5 * (c + d), M = .5 * (u + f), A = (i >= M) << 1 | e >= b, w = A + 4; w > A; ++A) if (h = x[3 & A]) switch (3 & A) {
                                case 0:
                                    t(h, c, u, b, M);
                                    break;
                                case 1:
                                    t(h, b, u, d, M);
                                    break;
                                case 2:
                                    t(h, c, M, b, f);
                                    break;
                                case 3:
                                    t(h, b, M, d, f)
                            }
                        }
                    }(t, n, r, o, a), s
                }(S, t[0], t[1], g, m, v, y)
            }, f = -1, null == e) {
                for (; ++f < p;) o(S, t[f], u[f], d[f], g, m, v, y);
                --f
            } else t.forEach(S.add);
            return u = d = t = c = null, S
        }

        var a, s = ui, l = di;
        return (a = arguments.length) ? (s = Fi, l = Xi, 3 === a && (r = i, n = e, i = e = 0), o(t)) : (o.x = function (t) {
            return arguments.length ? (s = t, o) : s
        }, o.y = function (t) {
            return arguments.length ? (l = t, o) : l
        }, o.extent = function (t) {
            return arguments.length ? (null == t ? e = i = n = r = null : (e = +t[0][0], i = +t[0][1], n = +t[1][0], r = +t[1][1]), o) : null == e ? null : [[e, i], [n, r]]
        }, o.size = function (t) {
            return arguments.length ? (null == t ? e = i = n = r = null : (e = i = 0, n = +t[0], r = +t[1]), o) : null == e ? null : [n - e, r - i]
        }, o)
    }, to.interpolateRgb = Ui, to.interpolateObject = qi, to.interpolateNumber = $i, to.interpolateString = Vi;
    var es = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, is = new RegExp(es.source, "g");
    to.interpolate = Ki, to.interpolators = [function (t, e) {
        var i = typeof e;
        return ("string" === i ? $o.has(e.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(e) ? Ui : Vi : e instanceof it ? Ui : Array.isArray(e) ? Zi : "object" === i && isNaN(e) ? qi : $i)(t, e)
    }], to.interpolateArray = Zi;
    var ns = function () {
        return v
    }, rs = to.map({
        linear: ns, poly: function (t) {
            return function (e) {
                return Math.pow(e, t)
            }
        }, quad: function () {
            return tn
        }, cubic: function () {
            return en
        }, sin: function () {
            return rn
        }, exp: function () {
            return on
        }, circle: function () {
            return an
        }, elastic: function (t, e) {
            var i;
            return arguments.length < 2 && (e = .45), arguments.length ? i = e / _o * Math.asin(1 / t) : (t = 1, i = e / 4), function (n) {
                return 1 + t * Math.pow(2, -10 * n) * Math.sin((n - i) * _o / e)
            }
        }, back: function (t) {
            return t || (t = 1.70158), function (e) {
                return e * e * ((t + 1) * e - t)
            }
        }, bounce: function () {
            return sn
        }
    }), os = to.map({
        in: v, out: Ji, "in-out": Qi, "out-in": function (t) {
            return Qi(Ji(t))
        }
    });
    to.ease = function (t) {
        var e = t.indexOf("-"), i = e >= 0 ? t.slice(0, e) : t, n = e >= 0 ? t.slice(e + 1) : "in";
        return i = rs.get(i) || ns, function (t) {
            return function (e) {
                return 0 >= e ? 0 : e >= 1 ? 1 : t(e)
            }
        }((n = os.get(n) || v)(i.apply(null, eo.call(arguments, 1))))
    }, to.interpolateHcl = function (t, e) {
        t = to.hcl(t), e = to.hcl(e);
        var i = t.h, n = t.c, r = t.l, o = e.h - i, a = e.c - n, s = e.l - r;
        return isNaN(a) && (a = 0, n = isNaN(n) ? e.c : n), isNaN(o) ? (o = 0, i = isNaN(i) ? e.h : i) : o > 180 ? o -= 360 : -180 > o && (o += 360), function (t) {
            return at(i + o * t, n + a * t, r + s * t) + ""
        }
    }, to.interpolateHsl = function (t, e) {
        t = to.hsl(t), e = to.hsl(e);
        var i = t.h, n = t.s, r = t.l, o = e.h - i, a = e.s - n, s = e.l - r;
        return isNaN(a) && (a = 0, n = isNaN(n) ? e.s : n), isNaN(o) ? (o = 0, i = isNaN(i) ? e.h : i) : o > 180 ? o -= 360 : -180 > o && (o += 360), function (t) {
            return rt(i + o * t, n + a * t, r + s * t) + ""
        }
    }, to.interpolateLab = function (t, e) {
        t = to.lab(t), e = to.lab(e);
        var i = t.l, n = t.a, r = t.b, o = e.l - i, a = e.a - n, s = e.b - r;
        return function (t) {
            return lt(i + o * t, n + a * t, r + s * t) + ""
        }
    }, to.interpolateRound = ln, to.transform = function (t) {
        var e = no.createElementNS(to.ns.prefix.svg, "g");
        return (to.transform = function (t) {
            if (null != t) {
                e.setAttribute("transform", t);
                var i = e.transform.baseVal.consolidate()
            }
            return new hn(i ? i.matrix : as)
        })(t)
    }, hn.prototype.toString = function () {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
    };
    var as = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
    to.interpolateTransform = fn, to.layout = {}, to.layout.bundle = function () {
        return function (t) {
            for (var e = [], i = -1, n = t.length; ++i < n;) e.push(mn(t[i]));
            return e
        }
    }, to.layout.chord = function () {
        function t() {
            var t, h, u, d, f, p = {}, g = [], m = to.range(o), v = [];
            for (i = [], n = [], t = 0, d = -1; ++d < o;) {
                for (h = 0, f = -1; ++f < o;) h += r[d][f];
                g.push(h), v.push(to.range(o)), t += h
            }
            for (a && m.sort(function (t, e) {
                return a(g[t], g[e])
            }), s && v.forEach(function (t, e) {
                t.sort(function (t, i) {
                    return s(r[e][t], r[e][i])
                })
            }), t = (_o - c * o) / t, h = 0, d = -1; ++d < o;) {
                for (u = h, f = -1; ++f < o;) {
                    var y = m[d], x = v[y][f], b = r[y][x], M = h, A = h += b * t;
                    p[y + "-" + x] = {index: y, subindex: x, startAngle: M, endAngle: A, value: b}
                }
                n[y] = {index: y, startAngle: u, endAngle: h, value: g[y]}, h += c
            }
            for (d = -1; ++d < o;) for (f = d - 1; ++f < o;) {
                var w = p[d + "-" + f], k = p[f + "-" + d];
                (w.value || k.value) && i.push(w.value < k.value ? {source: k, target: w} : {source: w, target: k})
            }
            l && e()
        }

        function e() {
            i.sort(function (t, e) {
                return l((t.source.value + t.target.value) / 2, (e.source.value + e.target.value) / 2)
            })
        }

        var i, n, r, o, a, s, l, h = {}, c = 0;
        return h.matrix = function (t) {
            return arguments.length ? (o = (r = t) && r.length, i = n = null, h) : r
        }, h.padding = function (t) {
            return arguments.length ? (c = t, i = n = null, h) : c
        }, h.sortGroups = function (t) {
            return arguments.length ? (a = t, i = n = null, h) : a
        }, h.sortSubgroups = function (t) {
            return arguments.length ? (s = t, i = null, h) : s
        }, h.sortChords = function (t) {
            return arguments.length ? (l = t, i && e(), h) : l
        }, h.chords = function () {
            return i || t(), i
        }, h.groups = function () {
            return n || t(), n
        }, h
    }, to.layout.force = function () {
        function t(t) {
            return function (e, i, n, r) {
                if (e.point !== t) {
                    var o = e.cx - t.x, a = e.cy - t.y, s = r - i, l = o * o + a * a;
                    if (l > s * s / y) {
                        if (g > l) {
                            var h = e.charge / l;
                            t.px -= o * h, t.py -= a * h
                        }
                        return !0
                    }
                    if (e.point && l && g > l) {
                        h = e.pointCharge / l;
                        t.px -= o * h, t.py -= a * h
                    }
                }
                return !e.charge
            }
        }

        function e(t) {
            t.px = to.event.x, t.py = to.event.y, l.resume()
        }

        var i, n, r, o, a, s, l = {}, h = to.dispatch("start", "tick", "end"), c = [1, 1], u = .9, d = ss, f = ls,
            p = -30, g = hs, m = .1, y = .64, x = [], b = [];
        return l.tick = function () {
            if ((r *= .99) < .005) return i = null, h.end({type: "end", alpha: r = 0}), !0;
            var e, n, l, d, f, g, v, y, M, A = x.length, w = b.length;
            for (n = 0; w > n; ++n) d = (l = b[n]).source, (g = (y = (f = l.target).x - d.x) * y + (M = f.y - d.y) * M) && (y *= g = r * a[n] * ((g = Math.sqrt(g)) - o[n]) / g, M *= g, f.x -= y * (v = d.weight + f.weight ? d.weight / (d.weight + f.weight) : .5), f.y -= M * v, d.x += y * (v = 1 - v), d.y += M * v);
            if ((v = r * m) && (y = c[0] / 2, M = c[1] / 2, n = -1, v)) for (; ++n < A;) (l = x[n]).x += (y - l.x) * v, l.y += (M - l.y) * v;
            if (p) for (function t(e, i, n) {
                var r = 0, o = 0;
                if (e.charge = 0, !e.leaf) for (var a, s = e.nodes, l = s.length, h = -1; ++h < l;) null != (a = s[h]) && (t(a, i, n), e.charge += a.charge, r += a.charge * a.cx, o += a.charge * a.cy);
                if (e.point) {
                    e.leaf || (e.point.x += Math.random() - .5, e.point.y += Math.random() - .5);
                    var c = i * n[e.point.index];
                    e.charge += e.pointCharge = c, r += c * e.point.x, o += c * e.point.y
                }
                e.cx = r / e.charge, e.cy = o / e.charge
            }(e = to.geom.quadtree(x), r, s), n = -1; ++n < A;) (l = x[n]).fixed || e.visit(t(l));
            for (n = -1; ++n < A;) (l = x[n]).fixed ? (l.x = l.px, l.y = l.py) : (l.x -= (l.px - (l.px = l.x)) * u, l.y -= (l.py - (l.py = l.y)) * u);
            h.tick({type: "tick", alpha: r})
        }, l.nodes = function (t) {
            return arguments.length ? (x = t, l) : x
        }, l.links = function (t) {
            return arguments.length ? (b = t, l) : b
        }, l.size = function (t) {
            return arguments.length ? (c = t, l) : c
        }, l.linkDistance = function (t) {
            return arguments.length ? (d = "function" == typeof t ? t : +t, l) : d
        }, l.distance = l.linkDistance, l.linkStrength = function (t) {
            return arguments.length ? (f = "function" == typeof t ? t : +t, l) : f
        }, l.friction = function (t) {
            return arguments.length ? (u = +t, l) : u
        }, l.charge = function (t) {
            return arguments.length ? (p = "function" == typeof t ? t : +t, l) : p
        }, l.chargeDistance = function (t) {
            return arguments.length ? (g = t * t, l) : Math.sqrt(g)
        }, l.gravity = function (t) {
            return arguments.length ? (m = +t, l) : m
        }, l.theta = function (t) {
            return arguments.length ? (y = t * t, l) : Math.sqrt(y)
        }, l.alpha = function (t) {
            return arguments.length ? (t = +t, r ? t > 0 ? r = t : (i.c = null, i.t = NaN, i = null, h.end({
                type: "end",
                alpha: r = 0
            })) : t > 0 && (h.start({type: "start", alpha: r = t}), i = St(l.tick)), l) : r
        }, l.start = function () {
            function t(t, n) {
                if (!i) {
                    for (i = new Array(r), l = 0; r > l; ++l) i[l] = [];
                    for (l = 0; h > l; ++l) {
                        var o = b[l];
                        i[o.source.index].push(o.target), i[o.target.index].push(o.source)
                    }
                }
                for (var a, s = i[e], l = -1, c = s.length; ++l < c;) if (!isNaN(a = s[l][t])) return a;
                return Math.random() * n
            }

            var e, i, n, r = x.length, h = b.length, u = c[0], g = c[1];
            for (e = 0; r > e; ++e) (n = x[e]).index = e, n.weight = 0;
            for (e = 0; h > e; ++e) "number" == typeof (n = b[e]).source && (n.source = x[n.source]), "number" == typeof n.target && (n.target = x[n.target]), ++n.source.weight, ++n.target.weight;
            for (e = 0; r > e; ++e) n = x[e], isNaN(n.x) && (n.x = t("x", u)), isNaN(n.y) && (n.y = t("y", g)), isNaN(n.px) && (n.px = n.x), isNaN(n.py) && (n.py = n.y);
            if (o = [], "function" == typeof d) for (e = 0; h > e; ++e) o[e] = +d.call(this, b[e], e); else for (e = 0; h > e; ++e) o[e] = d;
            if (a = [], "function" == typeof f) for (e = 0; h > e; ++e) a[e] = +f.call(this, b[e], e); else for (e = 0; h > e; ++e) a[e] = f;
            if (s = [], "function" == typeof p) for (e = 0; r > e; ++e) s[e] = +p.call(this, x[e], e); else for (e = 0; r > e; ++e) s[e] = p;
            return l.resume()
        }, l.resume = function () {
            return l.alpha(.1)
        }, l.stop = function () {
            return l.alpha(0)
        }, l.drag = function () {
            return n || (n = to.behavior.drag().origin(v).on("dragstart.force", yn).on("drag.force", e).on("dragend.force", xn)), arguments.length ? void this.on("mouseover.force", bn).on("mouseout.force", Mn).call(n) : n
        }, to.rebind(l, h, "on")
    };
    var ss = 20, ls = 1, hs = 1 / 0;
    to.layout.hierarchy = function () {
        function t(r) {
            var o, a = [r], s = [];
            for (r.depth = 0; null != (o = a.pop());) if (s.push(o), (h = i.call(t, o, o.depth)) && (l = h.length)) {
                for (var l, h, c; --l >= 0;) a.push(c = h[l]), c.parent = o, c.depth = o.depth + 1;
                n && (o.value = 0), o.children = h
            } else n && (o.value = +n.call(t, o, o.depth) || 0), delete o.children;
            return kn(r, function (t) {
                var i, r;
                e && (i = t.children) && i.sort(e), n && (r = t.parent) && (r.value += t.value)
            }), s
        }

        var e = En, i = Sn, n = Tn;
        return t.sort = function (i) {
            return arguments.length ? (e = i, t) : e
        }, t.children = function (e) {
            return arguments.length ? (i = e, t) : i
        }, t.value = function (e) {
            return arguments.length ? (n = e, t) : n
        }, t.revalue = function (e) {
            return n && (wn(e, function (t) {
                t.children && (t.value = 0)
            }), kn(e, function (e) {
                var i;
                e.children || (e.value = +n.call(t, e, e.depth) || 0), (i = e.parent) && (i.value += e.value)
            })), e
        }, t
    }, to.layout.partition = function () {
        function t(t, n) {
            var r = e.call(this, t, n);
            return function t(e, i, n, r) {
                var o = e.children;
                if (e.x = i, e.y = e.depth * r, e.dx = n, e.dy = r, o && (a = o.length)) {
                    var a, s, l, h = -1;
                    for (n = e.value ? n / e.value : 0; ++h < a;) t(s = o[h], i, l = s.value * n, r), i += l
                }
            }(r[0], 0, i[0], i[1] / function t(e) {
                var i = e.children, n = 0;
                if (i && (r = i.length)) for (var r, o = -1; ++o < r;) n = Math.max(n, t(i[o]));
                return 1 + n
            }(r[0])), r
        }

        var e = to.layout.hierarchy(), i = [1, 1];
        return t.size = function (e) {
            return arguments.length ? (i = e, t) : i
        }, An(t, e)
    }, to.layout.pie = function () {
        function t(a) {
            var s, l = a.length, h = a.map(function (i, n) {
                    return +e.call(t, i, n)
                }), c = +("function" == typeof n ? n.apply(this, arguments) : n),
                u = ("function" == typeof r ? r.apply(this, arguments) : r) - c,
                d = Math.min(Math.abs(u) / l, +("function" == typeof o ? o.apply(this, arguments) : o)),
                f = d * (0 > u ? -1 : 1), p = to.sum(h), g = p ? (u - l * f) / p : 0, m = to.range(l), v = [];
            return null != i && m.sort(i === cs ? function (t, e) {
                return h[e] - h[t]
            } : function (t, e) {
                return i(a[t], a[e])
            }), m.forEach(function (t) {
                v[t] = {data: a[t], value: s = h[t], startAngle: c, endAngle: c += s * g + f, padAngle: d}
            }), v
        }

        var e = Number, i = cs, n = 0, r = _o, o = 0;
        return t.value = function (i) {
            return arguments.length ? (e = i, t) : e
        }, t.sort = function (e) {
            return arguments.length ? (i = e, t) : i
        }, t.startAngle = function (e) {
            return arguments.length ? (n = e, t) : n
        }, t.endAngle = function (e) {
            return arguments.length ? (r = e, t) : r
        }, t.padAngle = function (e) {
            return arguments.length ? (o = e, t) : o
        }, t
    };
    var cs = {};
    to.layout.stack = function () {
        function t(s, l) {
            if (!(d = s.length)) return s;
            var h = s.map(function (i, n) {
                return e.call(t, i, n)
            }), c = h.map(function (e) {
                return e.map(function (e, i) {
                    return [o.call(t, e, i), a.call(t, e, i)]
                })
            }), u = i.call(t, c, l);
            h = to.permute(h, u), c = to.permute(c, u);
            var d, f, p, g, m = n.call(t, c, l), v = h[0].length;
            for (p = 0; v > p; ++p) for (r.call(t, h[0][p], g = m[p], c[0][p][1]), f = 1; d > f; ++f) r.call(t, h[f][p], g += c[f - 1][p][1], c[f][p][1]);
            return s
        }

        var e = v, i = On, n = Ln, r = _n, o = Dn, a = Pn;
        return t.values = function (i) {
            return arguments.length ? (e = i, t) : e
        }, t.order = function (e) {
            return arguments.length ? (i = "function" == typeof e ? e : us.get(e) || On, t) : i
        }, t.offset = function (e) {
            return arguments.length ? (n = "function" == typeof e ? e : ds.get(e) || Ln, t) : n
        }, t.x = function (e) {
            return arguments.length ? (o = e, t) : o
        }, t.y = function (e) {
            return arguments.length ? (a = e, t) : a
        }, t.out = function (e) {
            return arguments.length ? (r = e, t) : r
        }, t
    };
    var us = to.map({
        "inside-out": function (t) {
            var e, i, n = t.length, r = t.map(Nn), o = t.map(zn), a = to.range(n).sort(function (t, e) {
                return r[t] - r[e]
            }), s = 0, l = 0, h = [], c = [];
            for (e = 0; n > e; ++e) i = a[e], l > s ? (s += o[i], h.push(i)) : (l += o[i], c.push(i));
            return c.reverse().concat(h)
        }, reverse: function (t) {
            return to.range(t.length).reverse()
        }, default: On
    }), ds = to.map({
        silhouette: function (t) {
            var e, i, n, r = t.length, o = t[0].length, a = [], s = 0, l = [];
            for (i = 0; o > i; ++i) {
                for (e = 0, n = 0; r > e; e++) n += t[e][i][1];
                n > s && (s = n), a.push(n)
            }
            for (i = 0; o > i; ++i) l[i] = (s - a[i]) / 2;
            return l
        }, wiggle: function (t) {
            var e, i, n, r, o, a, s, l, h, c = t.length, u = t[0], d = u.length, f = [];
            for (f[0] = l = h = 0, i = 1; d > i; ++i) {
                for (e = 0, r = 0; c > e; ++e) r += t[e][i][1];
                for (e = 0, o = 0, s = u[i][0] - u[i - 1][0]; c > e; ++e) {
                    for (n = 0, a = (t[e][i][1] - t[e][i - 1][1]) / (2 * s); e > n; ++n) a += (t[n][i][1] - t[n][i - 1][1]) / s;
                    o += a * t[e][i][1]
                }
                f[i] = l -= r ? o / r * s : 0, h > l && (h = l)
            }
            for (i = 0; d > i; ++i) f[i] -= h;
            return f
        }, expand: function (t) {
            var e, i, n, r = t.length, o = t[0].length, a = 1 / r, s = [];
            for (i = 0; o > i; ++i) {
                for (e = 0, n = 0; r > e; e++) n += t[e][i][1];
                if (n) for (e = 0; r > e; e++) t[e][i][1] /= n; else for (e = 0; r > e; e++) t[e][i][1] = a
            }
            for (i = 0; o > i; ++i) s[i] = 0;
            return s
        }, zero: Ln
    });
    to.layout.histogram = function () {
        function t(t, o) {
            for (var a, s, l = [], h = t.map(i, this), c = n.call(this, h, o), u = r.call(this, c, h, o), d = (o = -1, h.length), f = u.length - 1, p = e ? 1 : 1 / d; ++o < f;) (a = l[o] = []).dx = u[o + 1] - (a.x = u[o]), a.y = 0;
            if (f > 0) for (o = -1; ++o < d;) (s = h[o]) >= c[0] && s <= c[1] && ((a = l[to.bisect(u, s, 1, f) - 1]).y += p, a.push(t[o]));
            return l
        }

        var e = !0, i = Number, n = jn, r = Rn;
        return t.value = function (e) {
            return arguments.length ? (i = e, t) : i
        }, t.range = function (e) {
            return arguments.length ? (n = At(e), t) : n
        }, t.bins = function (e) {
            return arguments.length ? (r = "number" == typeof e ? function (t) {
                return Bn(t, e)
            } : At(e), t) : r
        }, t.frequency = function (i) {
            return arguments.length ? (e = !!i, t) : e
        }, t
    }, to.layout.pack = function () {
        function t(t, o) {
            var a = i.call(this, t, o), s = a[0], l = r[0], h = r[1],
                c = null == e ? Math.sqrt : "function" == typeof e ? e : function () {
                    return e
                };
            if (s.x = s.y = 0, kn(s, function (t) {
                t.r = +c(t.value)
            }), kn(s, Fn), n) {
                var u = n * (e ? 1 : Math.max(2 * s.r / l, 2 * s.r / h)) / 2;
                kn(s, function (t) {
                    t.r += u
                }), kn(s, Fn), kn(s, function (t) {
                    t.r -= u
                })
            }
            return function t(e, i, n, r) {
                var o = e.children;
                if (e.x = i += r * e.x, e.y = n += r * e.y, e.r *= r, o) for (var a = -1, s = o.length; ++a < s;) t(o[a], i, n, r)
            }(s, l / 2, h / 2, e ? 1 : 1 / Math.max(2 * s.r / l, 2 * s.r / h)), a
        }

        var e, i = to.layout.hierarchy().sort(Wn), n = 0, r = [1, 1];
        return t.size = function (e) {
            return arguments.length ? (r = e, t) : r
        }, t.radius = function (i) {
            return arguments.length ? (e = null == i || "function" == typeof i ? i : +i, t) : e
        }, t.padding = function (e) {
            return arguments.length ? (n = +e, t) : n
        }, An(t, i)
    }, to.layout.tree = function () {
        function t(t, l) {
            var h = r.call(this, t, l), c = h[0], u = function (t) {
                for (var e, i = {
                    A: null,
                    children: [t]
                }, n = [i]; null != (e = n.pop());) for (var r, o = e.children, a = 0, s = o.length; s > a; ++a) n.push((o[a] = r = {
                    _: o[a],
                    parent: e,
                    children: (r = o[a].children) && r.slice() || [],
                    A: null,
                    a: null,
                    z: 0,
                    m: 0,
                    c: 0,
                    s: 0,
                    t: null,
                    i: a
                }).a = r);
                return i.children[0]
            }(c);
            if (kn(u, e), u.parent.m = -u.z, wn(u, i), s) wn(c, n); else {
                var d = c, f = c, p = c;
                wn(c, function (t) {
                    t.x < d.x && (d = t), t.x > f.x && (f = t), t.depth > p.depth && (p = t)
                });
                var g = o(d, f) / 2 - d.x, m = a[0] / (f.x + o(f, d) / 2 + g), v = a[1] / (p.depth || 1);
                wn(c, function (t) {
                    t.x = (t.x + g) * m, t.y = t.depth * v
                })
            }
            return h
        }

        function e(t) {
            var e = t.children, i = t.parent.children, n = t.i ? i[t.i - 1] : null;
            if (e.length) {
                !function (t) {
                    for (var e, i = 0, n = 0, r = t.children, o = r.length; --o >= 0;) (e = r[o]).z += i, e.m += i, i += e.s + (n += e.c)
                }(t);
                var r = (e[0].z + e[e.length - 1].z) / 2;
                n ? (t.z = n.z + o(t._, n._), t.m = t.z - r) : t.z = r
            } else n && (t.z = n.z + o(t._, n._));
            t.parent.A = function (t, e, i) {
                if (e) {
                    for (var n, r = t, a = t, s = e, l = r.parent.children[0], h = r.m, c = a.m, u = s.m, d = l.m; s = Kn(s), r = Vn(r), s && r;) l = Vn(l), (a = Kn(a)).a = t, (n = s.z + u - r.z - h + o(s._, r._)) > 0 && (Zn(Jn(s, t, i), t, n), h += n, c += n), u += s.m, h += r.m, d += l.m, c += a.m;
                    s && !Kn(a) && (a.t = s, a.m += u - c), r && !Vn(l) && (l.t = r, l.m += h - d, i = t)
                }
                return i
            }(t, n, t.parent.A || i[0])
        }

        function i(t) {
            t._.x = t.z + t.parent.m, t.m += t.parent.m
        }

        function n(t) {
            t.x *= a[0], t.y = t.depth * a[1]
        }

        var r = to.layout.hierarchy().sort(null).value(null), o = $n, a = [1, 1], s = null;
        return t.separation = function (e) {
            return arguments.length ? (o = e, t) : o
        }, t.size = function (e) {
            return arguments.length ? (s = null == (a = e) ? n : null, t) : s ? null : a
        }, t.nodeSize = function (e) {
            return arguments.length ? (s = null == (a = e) ? null : n, t) : s ? a : null
        }, An(t, r)
    }, to.layout.cluster = function () {
        function t(t, o) {
            var a, s = e.call(this, t, o), l = s[0], h = 0;
            kn(l, function (t) {
                var e = t.children;
                e && e.length ? (t.x = function (t) {
                    return t.reduce(function (t, e) {
                        return t + e.x
                    }, 0) / t.length
                }(e), t.y = function (t) {
                    return 1 + to.max(t, function (t) {
                        return t.y
                    })
                }(e)) : (t.x = a ? h += i(t, a) : 0, t.y = 0, a = t)
            });
            var c = function t(e) {
                var i = e.children;
                return i && i.length ? t(i[0]) : e
            }(l), u = function t(e) {
                var i, n = e.children;
                return n && (i = n.length) ? t(n[i - 1]) : e
            }(l), d = c.x - i(c, u) / 2, f = u.x + i(u, c) / 2;
            return kn(l, r ? function (t) {
                t.x = (t.x - l.x) * n[0], t.y = (l.y - t.y) * n[1]
            } : function (t) {
                t.x = (t.x - d) / (f - d) * n[0], t.y = (1 - (l.y ? t.y / l.y : 1)) * n[1]
            }), s
        }

        var e = to.layout.hierarchy().sort(null).value(null), i = $n, n = [1, 1], r = !1;
        return t.separation = function (e) {
            return arguments.length ? (i = e, t) : i
        }, t.size = function (e) {
            return arguments.length ? (r = null == (n = e), t) : r ? null : n
        }, t.nodeSize = function (e) {
            return arguments.length ? (r = null != (n = e), t) : r ? n : null
        }, An(t, e)
    }, to.layout.treemap = function () {
        function t(t, e) {
            for (var i, n, r = -1, o = t.length; ++r < o;) n = (i = t[r]).value * (0 > e ? 0 : e), i.area = isNaN(n) || 0 >= n ? 0 : n
        }

        function e(i) {
            var o = i.children;
            if (o && o.length) {
                var a, s, l, h = u(i), c = [], d = o.slice(), p = 1 / 0,
                    g = "slice" === f ? h.dx : "dice" === f ? h.dy : "slice-dice" === f ? 1 & i.depth ? h.dy : h.dx : Math.min(h.dx, h.dy);
                for (t(d, h.dx * h.dy / i.value), c.area = 0; (l = d.length) > 0;) c.push(a = d[l - 1]), c.area += a.area, "squarify" !== f || (s = n(c, g)) <= p ? (d.pop(), p = s) : (c.area -= c.pop().area, r(c, g, h, !1), g = Math.min(h.dx, h.dy), c.length = c.area = 0, p = 1 / 0);
                c.length && (r(c, g, h, !0), c.length = c.area = 0), o.forEach(e)
            }
        }

        function i(e) {
            var n = e.children;
            if (n && n.length) {
                var o, a = u(e), s = n.slice(), l = [];
                for (t(s, a.dx * a.dy / e.value), l.area = 0; o = s.pop();) l.push(o), l.area += o.area, null != o.z && (r(l, o.z ? a.dx : a.dy, a, !s.length), l.length = l.area = 0);
                n.forEach(i)
            }
        }

        function n(t, e) {
            for (var i, n = t.area, r = 0, o = 1 / 0, a = -1, s = t.length; ++a < s;) (i = t[a].area) && (o > i && (o = i), i > r && (r = i));
            return e *= e, (n *= n) ? Math.max(e * r * p / n, n / (e * o * p)) : 1 / 0
        }

        function r(t, e, i, n) {
            var r, o = -1, a = t.length, s = i.x, h = i.y, c = e ? l(t.area / e) : 0;
            if (e == i.dx) {
                for ((n || c > i.dy) && (c = i.dy); ++o < a;) (r = t[o]).x = s, r.y = h, r.dy = c, s += r.dx = Math.min(i.x + i.dx - s, c ? l(r.area / c) : 0);
                r.z = !0, r.dx += i.x + i.dx - s, i.y += c, i.dy -= c
            } else {
                for ((n || c > i.dx) && (c = i.dx); ++o < a;) (r = t[o]).x = s, r.y = h, r.dx = c, h += r.dy = Math.min(i.y + i.dy - h, c ? l(r.area / c) : 0);
                r.z = !1, r.dy += i.y + i.dy - h, i.x += c, i.dx -= c
            }
        }

        function o(n) {
            var r = a || s(n), o = r[0];
            return o.x = o.y = 0, o.value ? (o.dx = h[0], o.dy = h[1]) : o.dx = o.dy = 0, a && s.revalue(o), t([o], o.dx * o.dy / o.value), (a ? i : e)(o), d && (a = r), r
        }

        var a, s = to.layout.hierarchy(), l = Math.round, h = [1, 1], c = null, u = Qn, d = !1, f = "squarify",
            p = .5 * (1 + Math.sqrt(5));
        return o.size = function (t) {
            return arguments.length ? (h = t, o) : h
        }, o.padding = function (t) {
            function e(e) {
                return tr(e, t)
            }

            return arguments.length ? (u = null == (c = t) ? Qn : "function" == (i = typeof t) ? function (e) {
                var i = t.call(o, e, e.depth);
                return null == i ? Qn(e) : tr(e, "number" == typeof i ? [i, i, i, i] : i)
            } : "number" === i ? (t = [t, t, t, t], e) : e, o) : c;
            var i
        }, o.round = function (t) {
            return arguments.length ? (l = t ? Math.round : Number, o) : l != Number
        }, o.sticky = function (t) {
            return arguments.length ? (d = t, a = null, o) : d
        }, o.ratio = function (t) {
            return arguments.length ? (p = t, o) : p
        }, o.mode = function (t) {
            return arguments.length ? (f = t + "", o) : f
        }, An(o, s)
    }, to.random = {
        normal: function (t, e) {
            var i = arguments.length;
            return 2 > i && (e = 1), 1 > i && (t = 0), function () {
                var i, n, r;
                do {
                    r = (i = 2 * Math.random() - 1) * i + (n = 2 * Math.random() - 1) * n
                } while (!r || r > 1);
                return t + e * i * Math.sqrt(-2 * Math.log(r) / r)
            }
        }, logNormal: function () {
            var t = to.random.normal.apply(to, arguments);
            return function () {
                return Math.exp(t())
            }
        }, bates: function (t) {
            var e = to.random.irwinHall(t);
            return function () {
                return e() / t
            }
        }, irwinHall: function (t) {
            return function () {
                for (var e = 0, i = 0; t > i; i++) e += Math.random();
                return e
            }
        }
    }, to.scale = {};
    var fs = {floor: v, ceil: v};
    to.scale.linear = function () {
        return function t(e, i, n, r) {
            function o() {
                var t = Math.min(e.length, i.length) > 2 ? ar : nr, o = r ? gn : pn;
                return s = t(e, i, o, n), l = t(i, e, o, Ki), a
            }

            function a(t) {
                return s(t)
            }

            var s, l;
            return a.invert = function (t) {
                return l(t)
            }, a.domain = function (t) {
                return arguments.length ? (e = t.map(Number), o()) : e
            }, a.range = function (t) {
                return arguments.length ? (i = t, o()) : i
            }, a.rangeRound = function (t) {
                return a.range(t).interpolate(ln)
            }, a.clamp = function (t) {
                return arguments.length ? (r = t, o()) : r
            }, a.interpolate = function (t) {
                return arguments.length ? (n = t, o()) : n
            }, a.ticks = function (t) {
                return cr(e, t)
            }, a.tickFormat = function (t, i) {
                return ur(e, t, i)
            }, a.nice = function (t) {
                return lr(e, t), o()
            }, a.copy = function () {
                return t(e, i, n, r)
            }, o()
        }([0, 1], [0, 1], Ki, !1)
    };
    var ps = {s: 1, g: 1, p: 1, r: 1, e: 1};
    to.scale.log = function () {
        return function t(e, i, n, r) {
            function o(t) {
                return (n ? Math.log(0 > t ? 0 : t) : -Math.log(t > 0 ? 0 : -t)) / Math.log(i)
            }

            function a(t) {
                return n ? Math.pow(i, t) : -Math.pow(i, -t)
            }

            function s(t) {
                return e(o(t))
            }

            return s.invert = function (t) {
                return a(e.invert(t))
            }, s.domain = function (t) {
                return arguments.length ? (n = t[0] >= 0, e.domain((r = t.map(Number)).map(o)), s) : r
            }, s.base = function (t) {
                return arguments.length ? (i = +t, e.domain(r.map(o)), s) : i
            }, s.nice = function () {
                var t = rr(r.map(o), n ? Math : ms);
                return e.domain(t), r = t.map(a), s
            }, s.ticks = function () {
                var t = er(r), e = [], s = t[0], l = t[1], h = Math.floor(o(s)), c = Math.ceil(o(l)), u = i % 1 ? 2 : i;
                if (isFinite(c - h)) {
                    if (n) {
                        for (; c > h; h++) for (var d = 1; u > d; d++) e.push(a(h) * d);
                        e.push(a(h))
                    } else for (e.push(a(h)); h++ < c;) for (d = u - 1; d > 0; d--) e.push(a(h) * d);
                    for (h = 0; e[h] < s; h++) ;
                    for (c = e.length; e[c - 1] > l; c--) ;
                    e = e.slice(h, c)
                }
                return e
            }, s.tickFormat = function (t, e) {
                if (!arguments.length) return gs;
                arguments.length < 2 ? e = gs : "function" != typeof e && (e = to.format(e));
                var n = Math.max(1, i * t / s.ticks().length);
                return function (t) {
                    var r = t / a(Math.round(o(t)));
                    return i - .5 > r * i && (r *= i), n >= r ? e(t) : ""
                }
            }, s.copy = function () {
                return t(e.copy(), i, n, r)
            }, sr(s, e)
        }(to.scale.linear().domain([0, 1]), 10, !0, [1, 10])
    };
    var gs = to.format(".0e"), ms = {
        floor: function (t) {
            return -Math.ceil(-t)
        }, ceil: function (t) {
            return -Math.floor(-t)
        }
    };
    to.scale.pow = function () {
        return function t(e, i, n) {
            function r(t) {
                return e(o(t))
            }

            var o = fr(i), a = fr(1 / i);
            return r.invert = function (t) {
                return a(e.invert(t))
            }, r.domain = function (t) {
                return arguments.length ? (e.domain((n = t.map(Number)).map(o)), r) : n
            }, r.ticks = function (t) {
                return cr(n, t)
            }, r.tickFormat = function (t, e) {
                return ur(n, t, e)
            }, r.nice = function (t) {
                return r.domain(lr(n, t))
            }, r.exponent = function (t) {
                return arguments.length ? (o = fr(i = t), a = fr(1 / i), e.domain(n.map(o)), r) : i
            }, r.copy = function () {
                return t(e.copy(), i, n)
            }, sr(r, e)
        }(to.scale.linear(), 1, [0, 1])
    }, to.scale.sqrt = function () {
        return to.scale.pow().exponent(.5)
    }, to.scale.ordinal = function () {
        return function t(e, i) {
            function n(t) {
                return a[((o.get(t) || ("range" === i.t ? o.set(t, e.push(t)) : NaN)) - 1) % a.length]
            }

            function r(t, i) {
                return to.range(e.length).map(function (e) {
                    return t + i * e
                })
            }

            var o, a, s;
            return n.domain = function (t) {
                if (!arguments.length) return e;
                e = [], o = new l;
                for (var r, a = -1, s = t.length; ++a < s;) o.has(r = t[a]) || o.set(r, e.push(r));
                return n[i.t].apply(n, i.a)
            }, n.range = function (t) {
                return arguments.length ? (a = t, s = 0, i = {t: "range", a: arguments}, n) : a
            }, n.rangePoints = function (t, o) {
                arguments.length < 2 && (o = 0);
                var l = t[0], h = t[1], c = e.length < 2 ? (l = (l + h) / 2, 0) : (h - l) / (e.length - 1 + o);
                return a = r(l + c * o / 2, c), s = 0, i = {t: "rangePoints", a: arguments}, n
            }, n.rangeRoundPoints = function (t, o) {
                arguments.length < 2 && (o = 0);
                var l = t[0], h = t[1],
                    c = e.length < 2 ? (l = h = Math.round((l + h) / 2), 0) : (h - l) / (e.length - 1 + o) | 0;
                return a = r(l + Math.round(c * o / 2 + (h - l - (e.length - 1 + o) * c) / 2), c), s = 0, i = {
                    t: "rangeRoundPoints",
                    a: arguments
                }, n
            }, n.rangeBands = function (t, o, l) {
                arguments.length < 2 && (o = 0), arguments.length < 3 && (l = o);
                var h = t[1] < t[0], c = t[h - 0], u = (t[1 - h] - c) / (e.length - o + 2 * l);
                return a = r(c + u * l, u), h && a.reverse(), s = u * (1 - o), i = {t: "rangeBands", a: arguments}, n
            }, n.rangeRoundBands = function (t, o, l) {
                arguments.length < 2 && (o = 0), arguments.length < 3 && (l = o);
                var h = t[1] < t[0], c = t[h - 0], u = t[1 - h], d = Math.floor((u - c) / (e.length - o + 2 * l));
                return a = r(c + Math.round((u - c - (e.length - o) * d) / 2), d), h && a.reverse(), s = Math.round(d * (1 - o)), i = {
                    t: "rangeRoundBands",
                    a: arguments
                }, n
            }, n.rangeBand = function () {
                return s
            }, n.rangeExtent = function () {
                return er(i.a[0])
            }, n.copy = function () {
                return t(e, i)
            }, n.domain(e)
        }([], {t: "range", a: [[]]})
    }, to.scale.category10 = function () {
        return to.scale.ordinal().range(vs)
    }, to.scale.category20 = function () {
        return to.scale.ordinal().range(ys)
    }, to.scale.category20b = function () {
        return to.scale.ordinal().range(xs)
    }, to.scale.category20c = function () {
        return to.scale.ordinal().range(bs)
    };
    var vs = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(gt),
        ys = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(gt),
        xs = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(gt),
        bs = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(gt);
    to.scale.quantile = function () {
        return function t(e, o) {
            function a() {
                var t = 0, i = o.length;
                for (l = []; ++t < i;) l[t - 1] = to.quantile(e, t / i);
                return s
            }

            function s(t) {
                return isNaN(t = +t) ? void 0 : o[to.bisect(l, t)]
            }

            var l;
            return s.domain = function (t) {
                return arguments.length ? (e = t.map(n).filter(r).sort(i), a()) : e
            }, s.range = function (t) {
                return arguments.length ? (o = t, a()) : o
            }, s.quantiles = function () {
                return l
            }, s.invertExtent = function (t) {
                return 0 > (t = o.indexOf(t)) ? [NaN, NaN] : [t > 0 ? l[t - 1] : e[0], t < l.length ? l[t] : e[e.length - 1]]
            }, s.copy = function () {
                return t(e, o)
            }, a()
        }([], [])
    }, to.scale.quantize = function () {
        return function t(e, i, n) {
            function r(t) {
                return n[Math.max(0, Math.min(s, Math.floor(a * (t - e))))]
            }

            function o() {
                return a = n.length / (i - e), s = n.length - 1, r
            }

            var a, s;
            return r.domain = function (t) {
                return arguments.length ? (e = +t[0], i = +t[t.length - 1], o()) : [e, i]
            }, r.range = function (t) {
                return arguments.length ? (n = t, o()) : n
            }, r.invertExtent = function (t) {
                return [t = 0 > (t = n.indexOf(t)) ? NaN : t / a + e, t + 1 / a]
            }, r.copy = function () {
                return t(e, i, n)
            }, o()
        }(0, 1, [0, 1])
    }, to.scale.threshold = function () {
        return function t(e, i) {
            function n(t) {
                return t >= t ? i[to.bisect(e, t)] : void 0
            }

            return n.domain = function (t) {
                return arguments.length ? (e = t, n) : e
            }, n.range = function (t) {
                return arguments.length ? (i = t, n) : i
            }, n.invertExtent = function (t) {
                return t = i.indexOf(t), [e[t - 1], e[t]]
            }, n.copy = function () {
                return t(e, i)
            }, n
        }([.5], [0, 1])
    }, to.scale.identity = function () {
        return function t(e) {
            function i(t) {
                return +t
            }

            return i.invert = i, i.domain = i.range = function (t) {
                return arguments.length ? (e = t.map(i), i) : e
            }, i.ticks = function (t) {
                return cr(e, t)
            }, i.tickFormat = function (t, i) {
                return ur(e, t, i)
            }, i.copy = function () {
                return t(e)
            }, i
        }([0, 1])
    }, to.svg = {}, to.svg.arc = function () {
        function t() {
            var t = Math.max(0, +i.apply(this, arguments)), h = Math.max(0, +n.apply(this, arguments)),
                c = a.apply(this, arguments) - Lo, u = s.apply(this, arguments) - Lo, d = Math.abs(u - c),
                f = c > u ? 0 : 1;
            if (t > h && (p = h, h = t, t = p), d >= Oo) return e(h, f) + (t ? e(t, 1 - f) : "") + "Z";
            var p, g, m, v, y, x, b, M, A, w, k, S, T = 0, E = 0, C = [];
            if ((v = (+l.apply(this, arguments) || 0) / 2) && (m = o === Ms ? Math.sqrt(t * t + h * h) : +o.apply(this, arguments), f || (E *= -1), h && (E = Q(m / h * Math.sin(v))), t && (T = Q(m / t * Math.sin(v)))), h) {
                y = h * Math.cos(c + E), x = h * Math.sin(c + E), b = h * Math.cos(u - E), M = h * Math.sin(u - E);
                var D = Math.abs(u - c - 2 * E) <= Po ? 0 : 1;
                if (E && br(y, x, b, M) === f ^ D) {
                    var P = (c + u) / 2;
                    y = h * Math.cos(P), x = h * Math.sin(P), b = M = null
                }
            } else y = x = 0;
            if (t) {
                A = t * Math.cos(u - T), w = t * Math.sin(u - T), k = t * Math.cos(c + T), S = t * Math.sin(c + T);
                var _ = Math.abs(c - u + 2 * T) <= Po ? 0 : 1;
                if (T && br(A, w, k, S) === 1 - f ^ _) {
                    var O = (c + u) / 2;
                    A = t * Math.cos(O), w = t * Math.sin(O), k = S = null
                }
            } else A = w = 0;
            if (d > Co && (p = Math.min(Math.abs(h - t) / 2, +r.apply(this, arguments))) > .001) {
                g = h > t ^ f ? 0 : 1;
                var L = p, N = p;
                if (Po > d) {
                    var z = null == k ? [A, w] : null == b ? [y, x] : mi([y, x], [k, S], [b, M], [A, w]), I = y - z[0],
                        R = x - z[1], B = b - z[0], j = M - z[1],
                        W = 1 / Math.sin(Math.acos((I * B + R * j) / (Math.sqrt(I * I + R * R) * Math.sqrt(B * B + j * j))) / 2),
                        H = Math.sqrt(z[0] * z[0] + z[1] * z[1]);
                    N = Math.min(p, (t - H) / (W - 1)), L = Math.min(p, (h - H) / (W + 1))
                }
                if (null != b) {
                    var Y = Mr(null == k ? [A, w] : [k, S], [y, x], h, L, f), G = Mr([b, M], [A, w], h, L, f);
                    p === L ? C.push("M", Y[0], "A", L, ",", L, " 0 0,", g, " ", Y[1], "A", h, ",", h, " 0 ", 1 - f ^ br(Y[1][0], Y[1][1], G[1][0], G[1][1]), ",", f, " ", G[1], "A", L, ",", L, " 0 0,", g, " ", G[0]) : C.push("M", Y[0], "A", L, ",", L, " 0 1,", g, " ", G[0])
                } else C.push("M", y, ",", x);
                if (null != k) {
                    var F = Mr([y, x], [k, S], t, -N, f), X = Mr([A, w], null == b ? [y, x] : [b, M], t, -N, f);
                    p === N ? C.push("L", X[0], "A", N, ",", N, " 0 0,", g, " ", X[1], "A", t, ",", t, " 0 ", f ^ br(X[1][0], X[1][1], F[1][0], F[1][1]), ",", 1 - f, " ", F[1], "A", N, ",", N, " 0 0,", g, " ", F[0]) : C.push("L", X[0], "A", N, ",", N, " 0 0,", g, " ", F[0])
                } else C.push("L", A, ",", w)
            } else C.push("M", y, ",", x), null != b && C.push("A", h, ",", h, " 0 ", D, ",", f, " ", b, ",", M), C.push("L", A, ",", w), null != k && C.push("A", t, ",", t, " 0 ", _, ",", 1 - f, " ", k, ",", S);
            return C.push("Z"), C.join("")
        }

        function e(t, e) {
            return "M0," + t + "A" + t + "," + t + " 0 1," + e + " 0," + -t + "A" + t + "," + t + " 0 1," + e + " 0," + t
        }

        var i = gr, n = mr, r = pr, o = Ms, a = vr, s = yr, l = xr;
        return t.innerRadius = function (e) {
            return arguments.length ? (i = At(e), t) : i
        }, t.outerRadius = function (e) {
            return arguments.length ? (n = At(e), t) : n
        }, t.cornerRadius = function (e) {
            return arguments.length ? (r = At(e), t) : r
        }, t.padRadius = function (e) {
            return arguments.length ? (o = e == Ms ? Ms : At(e), t) : o
        }, t.startAngle = function (e) {
            return arguments.length ? (a = At(e), t) : a
        }, t.endAngle = function (e) {
            return arguments.length ? (s = At(e), t) : s
        }, t.padAngle = function (e) {
            return arguments.length ? (l = At(e), t) : l
        }, t.centroid = function () {
            var t = (+i.apply(this, arguments) + +n.apply(this, arguments)) / 2,
                e = (+a.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Lo;
            return [Math.cos(e) * t, Math.sin(e) * t]
        }, t
    };
    var Ms = "auto";
    to.svg.line = function () {
        return Ar(v)
    };
    var As = to.map({
        linear: wr, "linear-closed": kr, step: function (t) {
            for (var e = 0, i = t.length, n = t[0], r = [n[0], ",", n[1]]; ++e < i;) r.push("H", (n[0] + (n = t[e])[0]) / 2, "V", n[1]);
            return i > 1 && r.push("H", n[0]), r.join("")
        }, "step-before": Sr, "step-after": Tr, basis: Dr, "basis-open": function (t) {
            if (t.length < 4) return wr(t);
            for (var e, i = [], n = -1, r = t.length, o = [0], a = [0]; ++n < 3;) e = t[n], o.push(e[0]), a.push(e[1]);
            for (i.push(Pr(Ss, o) + "," + Pr(Ss, a)), --n; ++n < r;) e = t[n], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), _r(i, o, a);
            return i.join("")
        }, "basis-closed": function (t) {
            for (var e, i, n = -1, r = t.length, o = r + 4, a = [], s = []; ++n < 4;) i = t[n % r], a.push(i[0]), s.push(i[1]);
            for (e = [Pr(Ss, a), ",", Pr(Ss, s)], --n; ++n < o;) i = t[n % r], a.shift(), a.push(i[0]), s.shift(), s.push(i[1]), _r(e, a, s);
            return e.join("")
        }, bundle: function (t, e) {
            var i = t.length - 1;
            if (i) for (var n, r, o = t[0][0], a = t[0][1], s = t[i][0] - o, l = t[i][1] - a, h = -1; ++h <= i;) r = h / i, (n = t[h])[0] = e * n[0] + (1 - e) * (o + r * s), n[1] = e * n[1] + (1 - e) * (a + r * l);
            return Dr(t)
        }, cardinal: function (t, e) {
            return t.length < 3 ? wr(t) : t[0] + Er(t, Cr(t, e))
        }, "cardinal-open": function (t, e) {
            return t.length < 4 ? wr(t) : t[1] + Er(t.slice(1, -1), Cr(t, e))
        }, "cardinal-closed": function (t, e) {
            return t.length < 3 ? kr(t) : t[0] + Er((t.push(t[0]), t), Cr([t[t.length - 2]].concat(t, [t[1]]), e))
        }, monotone: function (t) {
            return t.length < 3 ? wr(t) : t[0] + Er(t, Lr(t))
        }
    });
    As.forEach(function (t, e) {
        e.key = t, e.closed = /-closed$/.test(t)
    });
    var ws = [0, 2 / 3, 1 / 3, 0], ks = [0, 1 / 3, 2 / 3, 0], Ss = [0, 1 / 6, 2 / 3, 1 / 6];
    to.svg.line.radial = function () {
        var t = Ar(Nr);
        return t.radius = t.x, delete t.x, t.angle = t.y, delete t.y, t
    }, Sr.reverse = Tr, Tr.reverse = Sr, to.svg.area = function () {
        return zr(v)
    }, to.svg.area.radial = function () {
        var t = zr(Nr);
        return t.radius = t.x, delete t.x, t.innerRadius = t.x0, delete t.x0, t.outerRadius = t.x1, delete t.x1, t.angle = t.y, delete t.y, t.startAngle = t.y0, delete t.y0, t.endAngle = t.y1, delete t.y1, t
    }, to.svg.chord = function () {
        function t(t, a) {
            var s = e(this, r, t, a), l = e(this, o, t, a);
            return "M" + s.p0 + i(s.r, s.p1, s.a1 - s.a0) + (function (t, e) {
                return t.a0 == e.a0 && t.a1 == e.a1
            }(s, l) ? n(s.r, s.p1, s.r, s.p0) : n(s.r, s.p1, l.r, l.p0) + i(l.r, l.p1, l.a1 - l.a0) + n(l.r, l.p1, s.r, s.p0)) + "Z"
        }

        function e(t, e, i, n) {
            var r = e.call(t, i, n), o = a.call(t, r, n), h = s.call(t, r, n) - Lo, c = l.call(t, r, n) - Lo;
            return {r: o, a0: h, a1: c, p0: [o * Math.cos(h), o * Math.sin(h)], p1: [o * Math.cos(c), o * Math.sin(c)]}
        }

        function i(t, e, i) {
            return "A" + t + "," + t + " 0 " + +(i > Po) + ",1 " + e
        }

        function n(t, e, i, n) {
            return "Q 0,0 " + n
        }

        var r = ni, o = ri, a = Ir, s = vr, l = yr;
        return t.radius = function (e) {
            return arguments.length ? (a = At(e), t) : a
        }, t.source = function (e) {
            return arguments.length ? (r = At(e), t) : r
        }, t.target = function (e) {
            return arguments.length ? (o = At(e), t) : o
        }, t.startAngle = function (e) {
            return arguments.length ? (s = At(e), t) : s
        }, t.endAngle = function (e) {
            return arguments.length ? (l = At(e), t) : l
        }, t
    }, to.svg.diagonal = function () {
        function t(t, r) {
            var o = e.call(this, t, r), a = i.call(this, t, r), s = (o.y + a.y) / 2,
                l = [o, {x: o.x, y: s}, {x: a.x, y: s}, a];
            return "M" + (l = l.map(n))[0] + "C" + l[1] + " " + l[2] + " " + l[3]
        }

        var e = ni, i = ri, n = Rr;
        return t.source = function (i) {
            return arguments.length ? (e = At(i), t) : e
        }, t.target = function (e) {
            return arguments.length ? (i = At(e), t) : i
        }, t.projection = function (e) {
            return arguments.length ? (n = e, t) : n
        }, t
    }, to.svg.diagonal.radial = function () {
        var t = to.svg.diagonal(), e = Rr, i = t.projection;
        return t.projection = function (t) {
            return arguments.length ? i(function (t) {
                return function () {
                    var e = t.apply(this, arguments), i = e[0], n = e[1] - Lo;
                    return [i * Math.cos(n), i * Math.sin(n)]
                }
            }(e = t)) : e
        }, t
    }, to.svg.symbol = function () {
        function t(t, n) {
            return (Ts.get(e.call(this, t, n)) || Wr)(i.call(this, t, n))
        }

        var e = jr, i = Br;
        return t.type = function (i) {
            return arguments.length ? (e = At(i), t) : e
        }, t.size = function (e) {
            return arguments.length ? (i = At(e), t) : i
        }, t
    };
    var Ts = to.map({
        circle: Wr, cross: function (t) {
            var e = Math.sqrt(t / 5) / 2;
            return "M" + -3 * e + "," + -e + "H" + -e + "V" + -3 * e + "H" + e + "V" + -e + "H" + 3 * e + "V" + e + "H" + e + "V" + 3 * e + "H" + -e + "V" + e + "H" + -3 * e + "Z"
        }, diamond: function (t) {
            var e = Math.sqrt(t / (2 * Cs)), i = e * Cs;
            return "M0," + -e + "L" + i + ",0 0," + e + " " + -i + ",0Z"
        }, square: function (t) {
            var e = Math.sqrt(t) / 2;
            return "M" + -e + "," + -e + "L" + e + "," + -e + " " + e + "," + e + " " + -e + "," + e + "Z"
        }, "triangle-down": function (t) {
            var e = Math.sqrt(t / Es), i = e * Es / 2;
            return "M0," + i + "L" + e + "," + -i + " " + -e + "," + -i + "Z"
        }, "triangle-up": function (t) {
            var e = Math.sqrt(t / Es), i = e * Es / 2;
            return "M0," + -i + "L" + e + "," + i + " " + -e + "," + i + "Z"
        }
    });
    to.svg.symbolTypes = Ts.keys();
    var Es = Math.sqrt(3), Cs = Math.tan(30 * No);
    bo.transition = function (t) {
        for (var e, i, n = Ds || ++Ls, r = Xr(t), o = [], a = Ps || {
            time: Date.now(),
            ease: nn,
            delay: 0,
            duration: 250
        }, s = -1, l = this.length; ++s < l;) {
            o.push(e = []);
            for (var h = this[s], c = -1, u = h.length; ++c < u;) (i = h[c]) && Ur(i, c, r, n, a), e.push(i)
        }
        return Yr(o, r, n)
    }, bo.interrupt = function (t) {
        return this.each(null == t ? _s : Hr(Xr(t)))
    };
    var Ds, Ps, _s = Hr(Xr()), Os = [], Ls = 0;
    Os.call = bo.call, Os.empty = bo.empty, Os.node = bo.node, Os.size = bo.size, to.transition = function (t, e) {
        return t && t.transition ? Ds ? t.transition(e) : t : to.selection().transition(t)
    }, to.transition.prototype = Os, Os.select = function (t) {
        var e, i, n, r = this.id, o = this.namespace, a = [];
        t = E(t);
        for (var s = -1, l = this.length; ++s < l;) {
            a.push(e = []);
            for (var h = this[s], c = -1, u = h.length; ++c < u;) (n = h[c]) && (i = t.call(n, n.__data__, c, s)) ? ("__data__" in n && (i.__data__ = n.__data__), Ur(i, c, o, r, n[o][r]), e.push(i)) : e.push(null)
        }
        return Yr(a, o, r)
    }, Os.selectAll = function (t) {
        var e, i, n, r, o, a = this.id, s = this.namespace, l = [];
        t = C(t);
        for (var h = -1, c = this.length; ++h < c;) for (var u = this[h], d = -1, f = u.length; ++d < f;) if (n = u[d]) {
            o = n[s][a], i = t.call(n, n.__data__, d, h), l.push(e = []);
            for (var p = -1, g = i.length; ++p < g;) (r = i[p]) && Ur(r, p, s, a, o), e.push(r)
        }
        return Yr(l, s, a)
    }, Os.filter = function (t) {
        var e, i, n = [];
        "function" != typeof t && (t = W(t));
        for (var r = 0, o = this.length; o > r; r++) {
            n.push(e = []);
            for (var a, s = 0, l = (a = this[r]).length; l > s; s++) (i = a[s]) && t.call(i, i.__data__, s, r) && e.push(i)
        }
        return Yr(n, this.namespace, this.id)
    }, Os.tween = function (t, e) {
        var i = this.id, n = this.namespace;
        return arguments.length < 2 ? this.node()[n][i].tween.get(t) : Y(this, null == e ? function (e) {
            e[n][i].tween.remove(t)
        } : function (r) {
            r[n][i].tween.set(t, e)
        })
    }, Os.attr = function (t, e) {
        function i() {
            this.removeAttribute(o)
        }

        function n() {
            this.removeAttributeNS(o.space, o.local)
        }

        if (arguments.length < 2) {
            for (e in t) this.attr(e, t[e]);
            return this
        }
        var r = "transform" == t ? fn : Ki, o = to.ns.qualify(t);
        return Gr(this, "attr." + t, e, o.local ? function (t) {
            return null == t ? n : (t += "", function () {
                var e, i = this.getAttributeNS(o.space, o.local);
                return i !== t && (e = r(i, t), function (t) {
                    this.setAttributeNS(o.space, o.local, e(t))
                })
            })
        } : function (t) {
            return null == t ? i : (t += "", function () {
                var e, i = this.getAttribute(o);
                return i !== t && (e = r(i, t), function (t) {
                    this.setAttribute(o, e(t))
                })
            })
        })
    }, Os.attrTween = function (t, e) {
        var i = to.ns.qualify(t);
        return this.tween("attr." + t, i.local ? function (t, n) {
            var r = e.call(this, t, n, this.getAttributeNS(i.space, i.local));
            return r && function (t) {
                this.setAttributeNS(i.space, i.local, r(t))
            }
        } : function (t, n) {
            var r = e.call(this, t, n, this.getAttribute(i));
            return r && function (t) {
                this.setAttribute(i, r(t))
            }
        })
    }, Os.style = function (t, i, n) {
        function r() {
            this.style.removeProperty(t)
        }

        var o = arguments.length;
        if (3 > o) {
            if ("string" != typeof t) {
                for (n in 2 > o && (i = ""), t) this.style(n, t[n], i);
                return this
            }
            n = ""
        }
        return Gr(this, "style." + t, i, function (i) {
            return null == i ? r : (i += "", function () {
                var r, o = e(this).getComputedStyle(this, null).getPropertyValue(t);
                return o !== i && (r = Ki(o, i), function (e) {
                    this.style.setProperty(t, r(e), n)
                })
            })
        })
    }, Os.styleTween = function (t, i, n) {
        return arguments.length < 3 && (n = ""), this.tween("style." + t, function (r, o) {
            var a = i.call(this, r, o, e(this).getComputedStyle(this, null).getPropertyValue(t));
            return a && function (e) {
                this.style.setProperty(t, a(e), n)
            }
        })
    }, Os.text = function (t) {
        return Gr(this, "text", t, Fr)
    }, Os.remove = function () {
        var t = this.namespace;
        return this.each("end.transition", function () {
            var e;
            this[t].count < 2 && (e = this.parentNode) && e.removeChild(this)
        })
    }, Os.ease = function (t) {
        var e = this.id, i = this.namespace;
        return arguments.length < 1 ? this.node()[i][e].ease : ("function" != typeof t && (t = to.ease.apply(to, arguments)), Y(this, function (n) {
            n[i][e].ease = t
        }))
    }, Os.delay = function (t) {
        var e = this.id, i = this.namespace;
        return arguments.length < 1 ? this.node()[i][e].delay : Y(this, "function" == typeof t ? function (n, r, o) {
            n[i][e].delay = +t.call(n, n.__data__, r, o)
        } : (t = +t, function (n) {
            n[i][e].delay = t
        }))
    }, Os.duration = function (t) {
        var e = this.id, i = this.namespace;
        return arguments.length < 1 ? this.node()[i][e].duration : Y(this, "function" == typeof t ? function (n, r, o) {
            n[i][e].duration = Math.max(1, t.call(n, n.__data__, r, o))
        } : (t = Math.max(1, t), function (n) {
            n[i][e].duration = t
        }))
    }, Os.each = function (t, e) {
        var i = this.id, n = this.namespace;
        if (arguments.length < 2) {
            var r = Ps, o = Ds;
            try {
                Ds = i, Y(this, function (e, r, o) {
                    Ps = e[n][i], t.call(e, e.__data__, r, o)
                })
            } finally {
                Ps = r, Ds = o
            }
        } else Y(this, function (r) {
            var o = r[n][i];
            (o.event || (o.event = to.dispatch("start", "end", "interrupt"))).on(t, e)
        });
        return this
    }, Os.transition = function () {
        for (var t, e, i, n = this.id, r = ++Ls, o = this.namespace, a = [], s = 0, l = this.length; l > s; s++) {
            a.push(t = []);
            for (var h, c = 0, u = (h = this[s]).length; u > c; c++) (e = h[c]) && Ur(e, c, o, r, {
                time: (i = e[o][n]).time,
                ease: i.ease,
                delay: i.delay + i.duration,
                duration: i.duration
            }), t.push(e)
        }
        return Yr(a, o, r)
    }, to.svg.axis = function () {
        function t(t) {
            t.each(function () {
                var t, h = to.select(this), c = this.__chart__ || i, u = this.__chart__ = i.copy(),
                    d = null == l ? u.ticks ? u.ticks.apply(u, s) : u.domain() : l,
                    f = null == e ? u.tickFormat ? u.tickFormat.apply(u, s) : v : e,
                    p = h.selectAll(".tick").data(d, u),
                    g = p.enter().insert("g", ".domain").attr("class", "tick").style("opacity", Co),
                    m = to.transition(p.exit()).style("opacity", Co).remove(),
                    y = to.transition(p.order()).style("opacity", 1), x = Math.max(r, 0) + a, b = ir(u),
                    M = h.selectAll(".domain").data([0]),
                    A = (M.enter().append("path").attr("class", "domain"), to.transition(M));
                g.append("line"), g.append("text");
                var w, k, S, T, E = g.select("line"), C = y.select("line"), D = p.select("text").text(f),
                    P = g.select("text"), _ = y.select("text"), O = "top" === n || "left" === n ? -1 : 1;
                if ("bottom" === n || "top" === n ? (t = qr, w = "x", S = "y", k = "x2", T = "y2", D.attr("dy", 0 > O ? "0em" : ".71em").style("text-anchor", "middle"), A.attr("d", "M" + b[0] + "," + O * o + "V0H" + b[1] + "V" + O * o)) : (t = $r, w = "y", S = "x", k = "y2", T = "x2", D.attr("dy", ".32em").style("text-anchor", 0 > O ? "end" : "start"), A.attr("d", "M" + O * o + "," + b[0] + "H0V" + b[1] + "H" + O * o)), E.attr(T, O * r), P.attr(S, O * x), C.attr(k, 0).attr(T, O * r), _.attr(w, 0).attr(S, O * x), u.rangeBand) {
                    var L = u, N = L.rangeBand() / 2;
                    c = u = function (t) {
                        return L(t) + N
                    }
                } else c.rangeBand ? c = u : m.call(t, u, c);
                g.call(t, c, u), y.call(t, u, u)
            })
        }

        var e, i = to.scale.linear(), n = Ns, r = 6, o = 6, a = 3, s = [10], l = null;
        return t.scale = function (e) {
            return arguments.length ? (i = e, t) : i
        }, t.orient = function (e) {
            return arguments.length ? (n = e in zs ? e + "" : Ns, t) : n
        }, t.ticks = function () {
            return arguments.length ? (s = io(arguments), t) : s
        }, t.tickValues = function (e) {
            return arguments.length ? (l = e, t) : l
        }, t.tickFormat = function (i) {
            return arguments.length ? (e = i, t) : e
        }, t.tickSize = function (e) {
            var i = arguments.length;
            return i ? (r = +e, o = +arguments[i - 1], t) : r
        }, t.innerTickSize = function (e) {
            return arguments.length ? (r = +e, t) : r
        }, t.outerTickSize = function (e) {
            return arguments.length ? (o = +e, t) : o
        }, t.tickPadding = function (e) {
            return arguments.length ? (a = +e, t) : a
        }, t.tickSubdivide = function () {
            return arguments.length && t
        }, t
    };
    var Ns = "bottom", zs = {top: 1, right: 1, bottom: 1, left: 1};
    to.svg.brush = function () {
        function t(e) {
            e.each(function () {
                var e = to.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", o).on("touchstart.brush", o),
                    a = e.selectAll(".background").data([0]);
                a.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"), e.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var s = e.selectAll(".resize").data(g, v);
                s.exit().remove(), s.enter().append("g").attr("class", function (t) {
                    return "resize " + t
                }).style("cursor", function (t) {
                    return Is[t]
                }).append("rect").attr("x", function (t) {
                    return /[ew]$/.test(t) ? -3 : null
                }).attr("y", function (t) {
                    return /^[ns]/.test(t) ? -3 : null
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden"), s.style("display", t.empty() ? "none" : null);
                var l, u = to.transition(e), d = to.transition(a);
                h && (l = ir(h), d.attr("x", l[0]).attr("width", l[1] - l[0]), n(u)), c && (l = ir(c), d.attr("y", l[0]).attr("height", l[1] - l[0]), r(u)), i(u)
            })
        }

        function i(t) {
            t.selectAll(".resize").attr("transform", function (t) {
                return "translate(" + u[+/e$/.test(t)] + "," + d[+/^s/.test(t)] + ")"
            })
        }

        function n(t) {
            t.select(".extent").attr("x", u[0]), t.selectAll(".extent,.n>rect,.s>rect").attr("width", u[1] - u[0])
        }

        function r(t) {
            t.select(".extent").attr("y", d[0]), t.selectAll(".extent,.e>rect,.w>rect").attr("height", d[1] - d[0])
        }

        function o() {
            function o() {
                var t = to.mouse(x), e = !1;
                y && (t[0] += y[0], t[1] += y[1]), E || (to.event.altKey ? (v || (v = [(u[0] + u[1]) / 2, (d[0] + d[1]) / 2]), D[0] = u[+(t[0] < v[0])], D[1] = d[+(t[1] < v[1])]) : v = null), S && g(t, h, 0) && (n(A), e = !0), T && g(t, c, 1) && (r(A), e = !0), e && (i(A), M({
                    type: "brush",
                    mode: E ? "move" : "resize"
                }))
            }

            function g(t, e, i) {
                var n, r, o = ir(e), l = o[0], h = o[1], c = D[i], g = i ? d : u, m = g[1] - g[0];
                return E && (l -= c, h -= m + c), n = (i ? p : f) ? Math.max(l, Math.min(h, t[i])) : t[i], E ? r = (n += c) + m : (v && (c = Math.max(l, Math.min(h, 2 * v[i] - n))), n > c ? (r = n, n = c) : r = c), g[0] != n || g[1] != r ? (i ? s = null : a = null, g[0] = n, g[1] = r, !0) : void 0
            }

            function m() {
                o(), A.style("pointer-events", "all").selectAll(".resize").style("display", t.empty() ? "none" : null), to.select("body").style("cursor", null), P.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null), C(), M({type: "brushend"})
            }

            var v, y, x = this, b = to.select(to.event.target), M = l.of(x, arguments), A = to.select(x), k = b.datum(),
                S = !/^(n|s)$/.test(k) && h, T = !/^(e|w)$/.test(k) && c, E = b.classed("extent"), C = q(x),
                D = to.mouse(x), P = to.select(e(x)).on("keydown.brush", function () {
                    32 == to.event.keyCode && (E || (v = null, D[0] -= u[1], D[1] -= d[1], E = 2), w())
                }).on("keyup.brush", function () {
                    32 == to.event.keyCode && 2 == E && (D[0] += u[1], D[1] += d[1], E = 0, w())
                });
            if (to.event.changedTouches ? P.on("touchmove.brush", o).on("touchend.brush", m) : P.on("mousemove.brush", o).on("mouseup.brush", m), A.interrupt().selectAll("*").interrupt(), E) D[0] = u[0] - D[0], D[1] = d[0] - D[1]; else if (k) {
                var _ = +/w$/.test(k), O = +/^n/.test(k);
                y = [u[1 - _] - D[0], d[1 - O] - D[1]], D[0] = u[_], D[1] = d[O]
            } else to.event.altKey && (v = D.slice());
            A.style("pointer-events", "none").selectAll(".resize").style("display", null), to.select("body").style("cursor", b.style("cursor")), M({type: "brushstart"}), o()
        }

        var a, s, l = S(t, "brushstart", "brush", "brushend"), h = null, c = null, u = [0, 0], d = [0, 0], f = !0,
            p = !0, g = Rs[0];
        return t.event = function (t) {
            t.each(function () {
                var t = l.of(this, arguments), e = {x: u, y: d, i: a, j: s}, i = this.__chart__ || e;
                this.__chart__ = e, Ds ? to.select(this).transition().each("start.brush", function () {
                    a = i.i, s = i.j, u = i.x, d = i.y, t({type: "brushstart"})
                }).tween("brush:brush", function () {
                    var i = Zi(u, e.x), n = Zi(d, e.y);
                    return a = s = null, function (r) {
                        u = e.x = i(r), d = e.y = n(r), t({type: "brush", mode: "resize"})
                    }
                }).each("end.brush", function () {
                    a = e.i, s = e.j, t({type: "brush", mode: "resize"}), t({type: "brushend"})
                }) : (t({type: "brushstart"}), t({type: "brush", mode: "resize"}), t({type: "brushend"}))
            })
        }, t.x = function (e) {
            return arguments.length ? (g = Rs[!(h = e) << 1 | !c], t) : h
        }, t.y = function (e) {
            return arguments.length ? (g = Rs[!h << 1 | !(c = e)], t) : c
        }, t.clamp = function (e) {
            return arguments.length ? (h && c ? (f = !!e[0], p = !!e[1]) : h ? f = !!e : c && (p = !!e), t) : h && c ? [f, p] : h ? f : c ? p : null
        }, t.extent = function (e) {
            var i, n, r, o, l;
            return arguments.length ? (h && (i = e[0], n = e[1], c && (i = i[0], n = n[0]), a = [i, n], h.invert && (i = h(i), n = h(n)), i > n && (l = i, i = n, n = l), i == u[0] && n == u[1] || (u = [i, n])), c && (r = e[0], o = e[1], h && (r = r[1], o = o[1]), s = [r, o], c.invert && (r = c(r), o = c(o)), r > o && (l = r, r = o, o = l), r == d[0] && o == d[1] || (d = [r, o])), t) : (h && (a ? (i = a[0], n = a[1]) : (i = u[0], n = u[1], h.invert && (i = h.invert(i), n = h.invert(n)), i > n && (l = i, i = n, n = l))), c && (s ? (r = s[0], o = s[1]) : (r = d[0], o = d[1], c.invert && (r = c.invert(r), o = c.invert(o)), r > o && (l = r, r = o, o = l))), h && c ? [[i, r], [n, o]] : h ? [i, n] : c && [r, o])
        }, t.clear = function () {
            return t.empty() || (u = [0, 0], d = [0, 0], a = s = null), t
        }, t.empty = function () {
            return !!h && u[0] == u[1] || !!c && d[0] == d[1]
        }, to.rebind(t, l, "on")
    };
    var Is = {
            n: "ns-resize",
            e: "ew-resize",
            s: "ns-resize",
            w: "ew-resize",
            nw: "nwse-resize",
            ne: "nesw-resize",
            se: "nwse-resize",
            sw: "nesw-resize"
        }, Rs = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []], Bs = na.format = ha.timeFormat,
        js = Bs.utc, Ws = js("%Y-%m-%dT%H:%M:%S.%LZ");
    Bs.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? Vr : Ws, Vr.parse = function (t) {
        var e = new Date(t);
        return isNaN(e) ? null : e
    }, Vr.toString = Ws.toString, na.second = Lt(function (t) {
        return new ra(1e3 * Math.floor(t / 1e3))
    }, function (t, e) {
        t.setTime(t.getTime() + 1e3 * Math.floor(e))
    }, function (t) {
        return t.getSeconds()
    }), na.seconds = na.second.range, na.seconds.utc = na.second.utc.range, na.minute = Lt(function (t) {
        return new ra(6e4 * Math.floor(t / 6e4))
    }, function (t, e) {
        t.setTime(t.getTime() + 6e4 * Math.floor(e))
    }, function (t) {
        return t.getMinutes()
    }), na.minutes = na.minute.range, na.minutes.utc = na.minute.utc.range, na.hour = Lt(function (t) {
        var e = t.getTimezoneOffset() / 60;
        return new ra(36e5 * (Math.floor(t / 36e5 - e) + e))
    }, function (t, e) {
        t.setTime(t.getTime() + 36e5 * Math.floor(e))
    }, function (t) {
        return t.getHours()
    }), na.hours = na.hour.range, na.hours.utc = na.hour.utc.range, na.month = Lt(function (t) {
        return (t = na.day(t)).setDate(1), t
    }, function (t, e) {
        t.setMonth(t.getMonth() + e)
    }, function (t) {
        return t.getMonth()
    }), na.months = na.month.range, na.months.utc = na.month.utc.range;
    var Hs = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6],
        Ys = [[na.second, 1], [na.second, 5], [na.second, 15], [na.second, 30], [na.minute, 1], [na.minute, 5], [na.minute, 15], [na.minute, 30], [na.hour, 1], [na.hour, 3], [na.hour, 6], [na.hour, 12], [na.day, 1], [na.day, 2], [na.week, 1], [na.month, 1], [na.month, 3], [na.year, 1]],
        Gs = Bs.multi([[".%L", function (t) {
            return t.getMilliseconds()
        }], [":%S", function (t) {
            return t.getSeconds()
        }], ["%I:%M", function (t) {
            return t.getMinutes()
        }], ["%I %p", function (t) {
            return t.getHours()
        }], ["%a %d", function (t) {
            return t.getDay() && 1 != t.getDate()
        }], ["%b %d", function (t) {
            return 1 != t.getDate()
        }], ["%B", function (t) {
            return t.getMonth()
        }], ["%Y", Me]]), Fs = {
            range: function (t, e, i) {
                return to.range(Math.ceil(t / i) * i, +e, i).map(Zr)
            }, floor: v, ceil: v
        };
    Ys.year = na.year, na.scale = function () {
        return Kr(to.scale.linear(), Ys, Gs)
    };
    var Xs = Ys.map(function (t) {
        return [t[0].utc, t[1]]
    }), Us = js.multi([[".%L", function (t) {
        return t.getUTCMilliseconds()
    }], [":%S", function (t) {
        return t.getUTCSeconds()
    }], ["%I:%M", function (t) {
        return t.getUTCMinutes()
    }], ["%I %p", function (t) {
        return t.getUTCHours()
    }], ["%a %d", function (t) {
        return t.getUTCDay() && 1 != t.getUTCDate()
    }], ["%b %d", function (t) {
        return 1 != t.getUTCDate()
    }], ["%B", function (t) {
        return t.getUTCMonth()
    }], ["%Y", Me]]);
    Xs.year = na.year.utc, na.scale.utc = function () {
        return Kr(to.scale.linear(), Xs, Us)
    }, to.text = wt(function (t) {
        return t.responseText
    }), to.json = function (t, e) {
        return kt(t, "application/json", Jr, e)
    }, to.html = function (t, e) {
        return kt(t, "text/html", Qr, e)
    }, to.xml = wt(function (t) {
        return t.responseXML
    }), "function" == typeof define && define.amd ? (this.d3 = to, define(to)) : "object" == typeof module && module.exports ? module.exports = to : this.d3 = to
}(), function (t, e) {
    "function" == typeof define && define.amd ? define(["d3"], e) : "object" == typeof module && module.exports ? module.exports = function (t) {
        return t.tip = e(t), t.tip
    } : t.d3.tip = e(t.d3)
}(this, function (t) {
    return function () {
        var e = function () {
            return "n"
        }, i = function () {
            return [0, 0]
        }, n = function () {
            return " "
        }, r = u(), o = null, a = null, s = null;

        function l(t) {
            var e;
            o = "svg" === (e = (e = t).node()).tagName.toLowerCase() ? e : e.ownerSVGElement, a = o.createSVGPoint(), document.body.appendChild(r)
        }

        l.show = function () {
            var t = Array.prototype.slice.call(arguments);
            t[t.length - 1] instanceof SVGElement && (s = t.pop());
            var r, o = n.apply(this, t), a = i.apply(this, t), u = e.apply(this, t), f = d(), p = c.length,
                g = document.documentElement.scrollTop || document.body.scrollTop,
                m = document.documentElement.scrollLeft || document.body.scrollLeft;
            for (f.html(o).style({opacity: 1, "pointer-events": "all"}); p--;) f.classed(c[p], !1);
            return r = h.get(u).apply(this), f.classed(u, !0).style({
                top: r.top + a[0] + g + "px",
                left: r.left + a[1] + m + "px"
            }), l
        }, l.hide = function () {
            return d().style({opacity: 0, "pointer-events": "none"}), l
        }, l.attr = function (e, i) {
            if (arguments.length < 2 && "string" == typeof e) return d().attr(e);
            var n = Array.prototype.slice.call(arguments);
            return t.selection.prototype.attr.apply(d(), n), l
        }, l.style = function (e, i) {
            if (arguments.length < 2 && "string" == typeof e) return d().style(e);
            var n = Array.prototype.slice.call(arguments);
            return t.selection.prototype.style.apply(d(), n), l
        }, l.direction = function (i) {
            return arguments.length ? (e = null == i ? i : t.functor(i), l) : e
        }, l.offset = function (e) {
            return arguments.length ? (i = null == e ? e : t.functor(e), l) : i
        }, l.html = function (e) {
            return arguments.length ? (n = null == e ? e : t.functor(e), l) : n
        }, l.destroy = function () {
            return r && (d().remove(), r = null), l
        };
        var h = t.map({
            n: function () {
                var t = f();
                return {top: t.n.y - r.offsetHeight, left: t.n.x - r.offsetWidth / 2}
            }, s: function () {
                var t = f();
                return {top: t.s.y, left: t.s.x - r.offsetWidth / 2}
            }, e: function () {
                var t = f();
                return {top: t.e.y - r.offsetHeight / 2, left: t.e.x}
            }, w: function () {
                var t = f();
                return {top: t.w.y - r.offsetHeight / 2, left: t.w.x - r.offsetWidth}
            }, nw: function () {
                var t = f();
                return {top: t.nw.y - r.offsetHeight, left: t.nw.x - r.offsetWidth}
            }, ne: function () {
                var t = f();
                return {top: t.ne.y - r.offsetHeight, left: t.ne.x}
            }, sw: function () {
                var t = f();
                return {top: t.sw.y, left: t.sw.x - r.offsetWidth}
            }, se: function () {
                var t = f();
                return {top: t.se.y, left: t.e.x}
            }
        }), c = h.keys();

        function u() {
            var e = t.select(document.createElement("div"));
            return e.style({
                position: "absolute",
                top: 0,
                opacity: 0,
                "pointer-events": "none",
                "box-sizing": "border-box"
            }), e.node()
        }

        function d() {
            return null === r && (r = u(), document.body.appendChild(r)), t.select(r)
        }

        function f() {
            for (var e = s || t.event.target; void 0 === e.getScreenCTM && "undefined" === e.parentNode;) e = e.parentNode;
            var i = {}, n = e.getScreenCTM(), r = e.getBBox(), o = r.width, l = r.height, h = r.x, c = r.y;
            return a.x = h, a.y = c, i.nw = a.matrixTransform(n), a.x += o, i.ne = a.matrixTransform(n), a.y += l, i.se = a.matrixTransform(n), a.x -= o, i.sw = a.matrixTransform(n), a.y -= l / 2, i.w = a.matrixTransform(n), a.x += o, i.e = a.matrixTransform(n), a.x -= o / 2, a.y -= l / 2, i.n = a.matrixTransform(n), a.y += l, i.s = a.matrixTransform(n), i
        }

        return l
    }
});
